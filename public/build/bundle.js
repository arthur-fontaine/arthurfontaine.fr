
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.2' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    var e=new class{constructor(){this.eventsName=["siteInit","pageInit","siteLoad","pageLoad","siteIn","pageIn","reveal","pageFetch","pageOut","pageCreate","pageKill","siteReload"],this.events={},this.eventsName.forEach((e=>{this.events[e]={callbacks:[],done:0};})),this.cycles={load:{events:["siteInit","pageInit",["siteLoad","pageLoad"],"siteIn","pageIn","reveal"]},reload:{events:["pageOut","siteReload"]},transition:{events:[["pageFetch","pageOut"],"pageCreate","pageKill","pageInit","pageLoad","pageIn","reveal"]},refresh:{events:["pageKill","pageInit","pageLoad","pageIn","reveal"]}},this.debug=!1;}cycle(e){this.cycles[e]&&(this.cycles[e].current=0,this.debug&&console.log("Start cycle: "+e),this.proceed(e));}proceed(e){const t=this.cycles[e].events,s=this.cycles[e].current;if(s<t.length){const r=t[s];Array.isArray(r)?r.forEach((t=>{this.do(e,t);})):this.do(e,r);}else this.debug&&console.log(e+" cycle ended");}next(e){const t=this,s=this.cycles[e].events,r=this.cycles[e].current;if(r<s.length){const i=s[r];let o=!0,n=[];n="string"==typeof i?Array(i):i,n.length>1&&n.forEach((e=>{(0===t.events[e].done||t.events[e].done<t.events[e].callbacks.length)&&(o=!1);})),o&&(this.cycles[e].current++,requestAnimationFrame(this.proceed.bind(this,e)));}}add(e,t,s=10,r=null){this.events[e]&&this.events[e].callbacks.push({callback:t,position:s,cycle:r});}do(e,t){if(this.events[t].done=0,this.events[t].callbacks.length>0){this.debug&&console.log("Do event: "+t+" ("+e+" cycle)");this.events[t].callbacks.sort(((e,t)=>e.position-t.position)).forEach((s=>{null===s.cycle||s.cycle===e?s.callback((()=>this.done(e,t))):this.done(e,t);}));}else this.done(e,t);}done(e,t){this.events[t].done++,this.debug&&console.log("Done event: "+t+" "+this.events[t].done+"/"+this.events[t].callbacks.length+" ("+e+" cycle)"),this.events[t].done>=this.events[t].callbacks.length&&this.next(e,t);}enableDebug(e=!0){this.debug=e;}};const t={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"},s={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"},r={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"},i={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"},o={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"};class n{static getFirstMatch(e,t){const s=t.match(e);return s&&s.length>0&&s[1]||""}static getSecondMatch(e,t){const s=t.match(e);return s&&s.length>1&&s[2]||""}static matchAndReturnConst(e,t,s){if(e.test(t))return s}static getWindowsVersionName(e){switch(e){case"NT":return "NT";case"XP":return "XP";case"NT 5.0":return "2000";case"NT 5.1":return "XP";case"NT 5.2":return "2003";case"NT 6.0":return "Vista";case"NT 6.1":return "7";case"NT 6.2":return "8";case"NT 6.3":return "8.1";case"NT 10.0":return "10";default:return}}static getMacOSVersionName(e){const t=e.split(".").splice(0,2).map((e=>parseInt(e,10)||0));if(t.push(0),10===t[0])switch(t[1]){case 5:return "Leopard";case 6:return "Snow Leopard";case 7:return "Lion";case 8:return "Mountain Lion";case 9:return "Mavericks";case 10:return "Yosemite";case 11:return "El Capitan";case 12:return "Sierra";case 13:return "High Sierra";case 14:return "Mojave";case 15:return "Catalina";default:return}}static getAndroidVersionName(e){const t=e.split(".").splice(0,2).map((e=>parseInt(e,10)||0));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0}static getVersionPrecision(e){return e.split(".").length}static compareVersions(e,t,s=!1){const r=n.getVersionPrecision(e),i=n.getVersionPrecision(t);let o=Math.max(r,i),a=0;const l=n.map([e,t],(e=>{const t=o-n.getVersionPrecision(e),s=e+new Array(t+1).join(".0");return n.map(s.split("."),(e=>new Array(20-e.length).join("0")+e)).reverse()}));for(s&&(a=o-Math.min(r,i)),o-=1;o>=a;){if(l[0][o]>l[1][o])return 1;if(l[0][o]===l[1][o]){if(o===a)return 0;o-=1;}else if(l[0][o]<l[1][o])return -1}}static map(e,t){const s=[];let r;if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)s.push(t(e[r]));return s}static find(e,t){let s,r;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(s=0,r=e.length;s<r;s+=1){const r=e[s];if(t(r,s))return r}}static assign(e,...t){const s=e;let r,i;if(Object.assign)return Object.assign(e,...t);for(r=0,i=t.length;r<i;r+=1){const e=t[r];if("object"==typeof e&&null!==e){Object.keys(e).forEach((t=>{s[t]=e[t];}));}}return e}static getBrowserAlias(e){return t[e]}static getBrowserTypeByAlias(e){return s[e]||""}}const a=/version\/(\d+(\.?_?\d+)+)/i,l=[{test:[/googlebot/i],describe(e){const t={name:"Googlebot"},s=n.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/opera/i],describe(e){const t={name:"Opera"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/opr\/|opios/i],describe(e){const t={name:"Opera"},s=n.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/SamsungBrowser/i],describe(e){const t={name:"Samsung Internet for Android"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/Whale/i],describe(e){const t={name:"NAVER Whale Browser"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/MZBrowser/i],describe(e){const t={name:"MZ Browser"},s=n.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/focus/i],describe(e){const t={name:"Focus"},s=n.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/swing/i],describe(e){const t={name:"Swing"},s=n.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/coast/i],describe(e){const t={name:"Opera Coast"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe(e){const t={name:"Opera Touch"},s=n.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/yabrowser/i],describe(e){const t={name:"Yandex Browser"},s=n.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/ucbrowser/i],describe(e){const t={name:"UC Browser"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/Maxthon|mxios/i],describe(e){const t={name:"Maxthon"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/epiphany/i],describe(e){const t={name:"Epiphany"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/puffin/i],describe(e){const t={name:"Puffin"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/sleipnir/i],describe(e){const t={name:"Sleipnir"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/k-meleon/i],describe(e){const t={name:"K-Meleon"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/micromessenger/i],describe(e){const t={name:"WeChat"},s=n.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/qqbrowser/i],describe(e){const t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},s=n.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/msie|trident/i],describe(e){const t={name:"Internet Explorer"},s=n.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/\sedg\//i],describe(e){const t={name:"Microsoft Edge"},s=n.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/edg([ea]|ios)/i],describe(e){const t={name:"Microsoft Edge"},s=n.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/vivaldi/i],describe(e){const t={name:"Vivaldi"},s=n.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/seamonkey/i],describe(e){const t={name:"SeaMonkey"},s=n.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/sailfish/i],describe(e){const t={name:"Sailfish"},s=n.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return s&&(t.version=s),t}},{test:[/silk/i],describe(e){const t={name:"Amazon Silk"},s=n.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/phantom/i],describe(e){const t={name:"PhantomJS"},s=n.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/slimerjs/i],describe(e){const t={name:"SlimerJS"},s=n.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(e){const t={name:"BlackBerry"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/(web|hpw)[o0]s/i],describe(e){const t={name:"WebOS Browser"},s=n.getFirstMatch(a,e)||n.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/bada/i],describe(e){const t={name:"Bada"},s=n.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/tizen/i],describe(e){const t={name:"Tizen"},s=n.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/qupzilla/i],describe(e){const t={name:"QupZilla"},s=n.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/firefox|iceweasel|fxios/i],describe(e){const t={name:"Firefox"},s=n.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/electron/i],describe(e){const t={name:"Electron"},s=n.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/MiuiBrowser/i],describe(e){const t={name:"Miui"},s=n.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/chromium/i],describe(e){const t={name:"Chromium"},s=n.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/chrome|crios|crmo/i],describe(e){const t={name:"Chrome"},s=n.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/GSA/i],describe(e){const t={name:"Google Search"},s=n.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test(e){const t=!e.test(/like android/i),s=e.test(/android/i);return t&&s},describe(e){const t={name:"Android Browser"},s=n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/playstation 4/i],describe(e){const t={name:"PlayStation 4"},s=n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/safari|applewebkit/i],describe(e){const t={name:"Safari"},s=n.getFirstMatch(a,e);return s&&(t.version=s),t}},{test:[/.*/i],describe(e){const t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return {name:n.getFirstMatch(t,e),version:n.getSecondMatch(t,e)}}}];var c=[{test:[/Roku\/DVP/],describe(e){const t=n.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return {name:i.Roku,version:t}}},{test:[/windows phone/i],describe(e){const t=n.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return {name:i.WindowsPhone,version:t}}},{test:[/windows /i],describe(e){const t=n.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),s=n.getWindowsVersionName(t);return {name:i.Windows,version:t,versionName:s}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe(e){const t={name:i.iOS},s=n.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return s&&(t.version=s),t}},{test:[/macintosh/i],describe(e){const t=n.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),s=n.getMacOSVersionName(t),r={name:i.MacOS,version:t};return s&&(r.versionName=s),r}},{test:[/(ipod|iphone|ipad)/i],describe(e){const t=n.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return {name:i.iOS,version:t}}},{test(e){const t=!e.test(/like android/i),s=e.test(/android/i);return t&&s},describe(e){const t=n.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),s=n.getAndroidVersionName(t),r={name:i.Android,version:t};return s&&(r.versionName=s),r}},{test:[/(web|hpw)[o0]s/i],describe(e){const t=n.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),s={name:i.WebOS};return t&&t.length&&(s.version=t),s}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe(e){const t=n.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||n.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||n.getFirstMatch(/\bbb(\d+)/i,e);return {name:i.BlackBerry,version:t}}},{test:[/bada/i],describe(e){const t=n.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return {name:i.Bada,version:t}}},{test:[/tizen/i],describe(e){const t=n.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return {name:i.Tizen,version:t}}},{test:[/linux/i],describe:()=>({name:i.Linux})},{test:[/CrOS/],describe:()=>({name:i.ChromeOS})},{test:[/PlayStation 4/],describe(e){const t=n.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return {name:i.PlayStation4,version:t}}}],d=[{test:[/googlebot/i],describe:()=>({type:"bot",vendor:"Google"})},{test:[/huawei/i],describe(e){const t=n.getFirstMatch(/(can-l01)/i,e)&&"Nova",s={type:r.mobile,vendor:"Huawei"};return t&&(s.model=t),s}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:()=>({type:r.tablet,vendor:"Nexus"})},{test:[/ipad/i],describe:()=>({type:r.tablet,vendor:"Apple",model:"iPad"})},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:()=>({type:r.tablet,vendor:"Apple",model:"iPad"})},{test:[/kftt build/i],describe:()=>({type:r.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"})},{test:[/silk/i],describe:()=>({type:r.tablet,vendor:"Amazon"})},{test:[/tablet(?! pc)/i],describe:()=>({type:r.tablet})},{test(e){const t=e.test(/ipod|iphone/i),s=e.test(/like (ipod|iphone)/i);return t&&!s},describe(e){const t=n.getFirstMatch(/(ipod|iphone)/i,e);return {type:r.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:()=>({type:r.mobile,vendor:"Nexus"})},{test:[/[^-]mobi/i],describe:()=>({type:r.mobile})},{test:e=>"blackberry"===e.getBrowserName(!0),describe:()=>({type:r.mobile,vendor:"BlackBerry"})},{test:e=>"bada"===e.getBrowserName(!0),describe:()=>({type:r.mobile})},{test:e=>"windows phone"===e.getBrowserName(),describe:()=>({type:r.mobile,vendor:"Microsoft"})},{test(e){const t=Number(String(e.getOSVersion()).split(".")[0]);return "android"===e.getOSName(!0)&&t>=3},describe:()=>({type:r.tablet})},{test:e=>"android"===e.getOSName(!0),describe:()=>({type:r.mobile})},{test:e=>"macos"===e.getOSName(!0),describe:()=>({type:r.desktop,vendor:"Apple"})},{test:e=>"windows"===e.getOSName(!0),describe:()=>({type:r.desktop})},{test:e=>"linux"===e.getOSName(!0),describe:()=>({type:r.desktop})},{test:e=>"playstation 4"===e.getOSName(!0),describe:()=>({type:r.tv})},{test:e=>"roku"===e.getOSName(!0),describe:()=>({type:r.tv})}],h=[{test:e=>"microsoft edge"===e.getBrowserName(!0),describe(e){if(/\sedg\//i.test(e))return {name:o.Blink};const t=n.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return {name:o.EdgeHTML,version:t}}},{test:[/trident/i],describe(e){const t={name:o.Trident},s=n.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:e=>e.test(/presto/i),describe(e){const t={name:o.Presto},s=n.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test(e){const t=e.test(/gecko/i),s=e.test(/like gecko/i);return t&&!s},describe(e){const t={name:o.Gecko},s=n.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}},{test:[/(apple)?webkit\/537\.36/i],describe:()=>({name:o.Blink})},{test:[/(apple)?webkit/i],describe(e){const t={name:o.WebKit},s=n.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return s&&(t.version=s),t}}];class u{constructor(e,t=!1){if(null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse();}getUA(){return this._ua}test(e){return e.test(this._ua)}parseBrowser(){this.parsedResult.browser={};const e=n.find(l,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.browser=e.describe(this.getUA())),this.parsedResult.browser}getBrowser(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()}getBrowserName(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""}getBrowserVersion(){return this.getBrowser().version}getOS(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()}parseOS(){this.parsedResult.os={};const e=n.find(c,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.os=e.describe(this.getUA())),this.parsedResult.os}getOSName(e){const{name:t}=this.getOS();return e?String(t).toLowerCase()||"":t||""}getOSVersion(){return this.getOS().version}getPlatform(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()}getPlatformType(e=!1){const{type:t}=this.getPlatform();return e?String(t).toLowerCase()||"":t||""}parsePlatform(){this.parsedResult.platform={};const e=n.find(d,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.platform=e.describe(this.getUA())),this.parsedResult.platform}getEngine(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()}getEngineName(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""}parseEngine(){this.parsedResult.engine={};const e=n.find(h,(e=>{if("function"==typeof e.test)return e.test(this);if(e.test instanceof Array)return e.test.some((e=>this.test(e)));throw new Error("Browser's test function is not valid")}));return e&&(this.parsedResult.engine=e.describe(this.getUA())),this.parsedResult.engine}parse(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this}getResult(){return n.assign({},this.parsedResult)}satisfies(e){const t={};let s=0;const r={};let i=0;if(Object.keys(e).forEach((o=>{const n=e[o];"string"==typeof n?(r[o]=n,i+=1):"object"==typeof n&&(t[o]=n,s+=1);})),s>0){const e=Object.keys(t),s=n.find(e,(e=>this.isOS(e)));if(s){const e=this.satisfies(t[s]);if(void 0!==e)return e}const r=n.find(e,(e=>this.isPlatform(e)));if(r){const e=this.satisfies(t[r]);if(void 0!==e)return e}}if(i>0){const e=Object.keys(r),t=n.find(e,(e=>this.isBrowser(e,!0)));if(void 0!==t)return this.compareVersion(r[t])}}isBrowser(e,t=!1){const s=this.getBrowserName().toLowerCase();let r=e.toLowerCase();const i=n.getBrowserTypeByAlias(r);return t&&i&&(r=i.toLowerCase()),r===s}compareVersion(e){let t=[0],s=e,r=!1;const i=this.getBrowserVersion();if("string"==typeof i)return ">"===e[0]||"<"===e[0]?(s=e.substr(1),"="===e[1]?(r=!0,s=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?s=e.substr(1):"~"===e[0]&&(r=!0,s=e.substr(1)),t.indexOf(n.compareVersions(i,s,r))>-1}isOS(e){return this.getOSName(!0)===String(e).toLowerCase()}isPlatform(e){return this.getPlatformType(!0)===String(e).toLowerCase()}isEngine(e){return this.getEngineName(!0)===String(e).toLowerCase()}is(e,t=!1){return this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)}some(e=[]){return e.some((e=>this.is(e)))}}
    /*!
     * Bowser - a browser detector
     * https://github.com/lancedikson/bowser
     * MIT License | (c) Dustin Diaz 2012-2015
     * MIT License | (c) Denis Demchenko 2015-2019
     */var p=new class{constructor(){this.events=[];}on(e,t,s,r=!1){(this.events[e]||(this.events[e]=[])).push({cb:t,context:s,once:r});}once(e,t,s){this.on(e,t,s,!0);}emit(e){const t=this,s=[].slice.call(arguments,1);this.events[e]&&this.events[e].forEach(((r,i)=>{r.cb.apply(r.context,s),r.once&&delete t.events[e][i];}));}off(e,t){const s=this;this.events[e]&&this.events[e].forEach(((r,i)=>{r.cb===t&&delete s.events[e][i];}));}};class g{static isArray(e){return e&&"object"==typeof e&&Array.isArray(e)}static isObject(e){return e&&"object"==typeof e&&!Array.isArray(e)}static isString(e){return e&&"string"==typeof e}static mergeDeep(e,t){const s=Object.assign({},e);return g.isObject(e)&&g.isObject(t)&&Object.keys(t).forEach((r=>{g.isObject(t[r])?r in e?g.isObject(e[r])&&g.isObject(t[r])?s[r]=g.mergeDeep(e[r],t[r]):s[r]=t[r]:Object.assign(s,{[r]:t[r]}):Object.assign(s,{[r]:t[r]});})),s}static toCamelCase(e){return g.isString(e)?e.replace(/(?:^\w|[A-Z]|\b\w)/g,((e,t)=>0===t?e.toLowerCase():e.toUpperCase())).replace(/\W+/g,""):e}static toUpperCamelCase(e){return g.isString(e)?(e=g.toCamelCase(e)).charAt(0).toUpperCase()+e.slice(1):e}static isInPage(e){return e!==document.body&&document.body.contains(e)}}var m=new class{constructor(){this.settings={cursor:{disabled:["tablet","mobile"],inertia:1,trailLength:10},lottie:{renderer:"svg",subFrame:!0},mouse:{inertia:.1},parallax:{inertia:.1},preloader:{duration:0},reveal:{stagger:.1,threshold:.15},scroll:{inertia:.1},smooth:{disabled:["tablet","mobile",{safari:"<=12"}],inertia:.1},sticky:{disabled:["tablet","mobile"]},ticker:{external:!1},transition:{reload:!1}},this.timeouts={resizeThrottle:null,scrollEnd:null},this.windowWidth=1,this.windowHeight=1,this.clientWidth=1,window.scrollTop=window.scrollY,window.unifiedScrollTop=window.scrollTop,window.maxScrollTop=1,window.scrollProgress=0,this.previousScrollTop=window.scrollY,this.isScrolling=!1,window.mouseX=0,window.mouseY=0,window.mouseLastScrollTop=0,window.browser=class{static getParser(e,t=!1){if("string"!=typeof e)throw new Error("UserAgent should be a string");return new u(e,t)}static parse(e){return new u(e).getResult()}static get BROWSER_MAP(){return s}static get ENGINE_MAP(){return o}static get OS_MAP(){return i}static get PLATFORMS_MAP(){return r}}.getParser(window.navigator.userAgent),document.documentElement.classList.add("is-"+window.browser.getPlatformType()),(window.browser.is("mobile")||window.browser.is("tablet"))&&document.documentElement.classList.add("is-handheld"),window.browser.is("Safari")&&(document.documentElement.classList.add("is-safari"),document.documentElement.classList.add("is-safari-"+window.browser.getBrowserVersion())),e.add("siteInit",this.siteInit.bind(this),999),this.bindEvents();}setSettings(e){this.settings=g.mergeDeep(this.settings,e);}siteInit(e){this.scrollHandler(),e();}bindEvents(){window.addEventListener("mousemove",this.mouseHandler.bind(this),{passive:!0}),window.addEventListener("resize",this.resizeThrottle.bind(this)),window.addEventListener("scroll",this.scrollHandler.bind(this),{passive:!0});}mouseHandler(e){const t=e.pageX,s=e.pageY-window.scrollTop;window.mouseX=t,window.mouseY=s,p.emit("mouseMove",e);}resizeThrottle(){clearTimeout(this.timeouts.resizeThrottle),this.timeouts.resizeThrottle=setTimeout(this.resizeHandler,200);}resizeHandler(){this.windowWidth!==window.innerWidth&&(this.windowWidth=window.innerWidth,this.clientWidth=document.body.clientWidth,document.documentElement.style.setProperty("--vw",.01*this.windowWidth+"px"),document.documentElement.style.setProperty("--cw",.01*this.clientWidth+"px")),this.windowHeight!==window.innerHeight&&(this.windowHeight=window.innerHeight,this.clientHeight=document.body.clientHeight,document.documentElement.style.setProperty("--vh",.01*this.windowHeight+"px"),document.documentElement.style.setProperty("--ch",.01*this.clientHeight+"px")),p.emit("resize");}scrollHandler(){window.scrollTop=window.scrollY,this.isScrolling||this.scrollStart(),clearTimeout(this.timeouts.scrollEnd),this.timeouts.scrollEnd=setTimeout(this.scrollEnd.bind(this),200),this.previousScrollTop=window.scrollTop,window.scrollProgress=window.scrollTop/window.maxScrollTop,window.hasSmoothScroll||(window.unifiedScrollTop=window.scrollTop,p.emit("scroll"));}scrollStart(){this.isScrolling=!0,document.documentElement.classList.add("is-scrolling"),p.emit("scrollStart");}scrollEnd(){this.isScrolling=!1,document.documentElement.classList.remove("is-scrolling"),p.emit("scrollEnd");}},f="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},b=function(e){return e&&e.Math==Math&&e},y=b("object"==typeof globalThis&&globalThis)||b("object"==typeof window&&window)||b("object"==typeof self&&self)||b("object"==typeof f&&f)||function(){return this}()||Function("return this")(),w={},v=function(e){try{return !!e()}catch(e){return !0}},S=!v((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),E={},x={}.propertyIsEnumerable,A=Object.getOwnPropertyDescriptor,P=A&&!x.call({1:2},1);E.f=P?function(e){var t=A(this,e);return !!t&&t.enumerable}:x;var M=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},T={}.toString,k=function(e){return T.call(e).slice(8,-1)},O="".split,L=function(e){if(null==e)throw TypeError("Can't call method on "+e);return e},B=v((function(){return !Object("z").propertyIsEnumerable(0)}))?function(e){return "String"==k(e)?O.call(e,""):Object(e)}:Object,F=L,C=function(e){return B(F(e))},I=function(e){return "object"==typeof e?null!==e:"function"==typeof e},_=I,R=function(e,t){if(!_(e))return e;var s,r;if(t&&"function"==typeof(s=e.toString)&&!_(r=s.call(e)))return r;if("function"==typeof(s=e.valueOf)&&!_(r=s.call(e)))return r;if(!t&&"function"==typeof(s=e.toString)&&!_(r=s.call(e)))return r;throw TypeError("Can't convert object to primitive value")},N=L,j=function(e){return Object(N(e))},H={}.hasOwnProperty,q=Object.hasOwn||function(e,t){return H.call(j(e),t)},z=I,D=y.document,K=z(D)&&z(D.createElement),V=function(e){return K?D.createElement(e):{}},W=!S&&!v((function(){return 7!=Object.defineProperty(V("div"),"a",{get:function(){return 7}}).a})),U=S,Y=E,X=M,G=C,Q=R,$=q,Z=W,J=Object.getOwnPropertyDescriptor;w.f=U?J:function(e,t){if(e=G(e),t=Q(t,!0),Z)try{return J(e,t)}catch(e){}if($(e,t))return X(!Y.f.call(e,t),e[t])};var ee={},te=I,se=function(e){if(!te(e))throw TypeError(String(e)+" is not an object");return e},re=S,ie=W,oe=se,ne=R,ae=Object.defineProperty;ee.f=re?ae:function(e,t,s){if(oe(e),t=ne(t,!0),oe(s),ie)try{return ae(e,t,s)}catch(e){}if("get"in s||"set"in s)throw TypeError("Accessors not supported");return "value"in s&&(e[t]=s.value),e};var le=ee,ce=M,de=S?function(e,t,s){return le.f(e,t,ce(1,s))}:function(e,t,s){return e[t]=s,e},he={exports:{}},ue=y,pe=de,ge=function(e,t){try{pe(ue,e,t);}catch(s){ue[e]=t;}return t},me=ge,fe=y["__core-js_shared__"]||me("__core-js_shared__",{}),be=fe,ye=Function.toString;"function"!=typeof be.inspectSource&&(be.inspectSource=function(e){return ye.call(e)});var we=be.inspectSource,ve=we,Se=y.WeakMap,Ee="function"==typeof Se&&/native code/.test(ve(Se)),xe={exports:{}},Ae=fe;(xe.exports=function(e,t){return Ae[e]||(Ae[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.15.2",mode:"global",copyright:" 2021 Denis Pushkarev (zloirock.ru)"});var Pe,Me,Te,ke=0,Oe=Math.random(),Le=xe.exports,Be=function(e){return "Symbol("+String(void 0===e?"":e)+")_"+(++ke+Oe).toString(36)},Fe=Le("keys"),Ce={},Ie=Ee,_e=I,Re=de,Ne=q,je=fe,He=function(e){return Fe[e]||(Fe[e]=Be(e))},qe=Ce,ze=y.WeakMap;if(Ie||je.state){var De=je.state||(je.state=new ze),Ke=De.get,Ve=De.has,We=De.set;Pe=function(e,t){if(Ve.call(De,e))throw new TypeError("Object already initialized");return t.facade=e,We.call(De,e,t),t},Me=function(e){return Ke.call(De,e)||{}},Te=function(e){return Ve.call(De,e)};}else {var Ue=He("state");qe[Ue]=!0,Pe=function(e,t){if(Ne(e,Ue))throw new TypeError("Object already initialized");return t.facade=e,Re(e,Ue,t),t},Me=function(e){return Ne(e,Ue)?e[Ue]:{}},Te=function(e){return Ne(e,Ue)};}var Ye={set:Pe,get:Me,has:Te,enforce:function(e){return Te(e)?Me(e):Pe(e,{})},getterFor:function(e){return function(t){var s;if(!_e(t)||(s=Me(t)).type!==e)throw TypeError("Incompatible receiver, "+e+" required");return s}}},Xe=y,Ge=de,Qe=q,$e=ge,Ze=we,Je=Ye.get,et=Ye.enforce,tt=String(String).split("String");(he.exports=function(e,t,s,r){var i,o=!!r&&!!r.unsafe,n=!!r&&!!r.enumerable,a=!!r&&!!r.noTargetGet;"function"==typeof s&&("string"!=typeof t||Qe(s,"name")||Ge(s,"name",t),(i=et(s)).source||(i.source=tt.join("string"==typeof t?t:""))),e!==Xe?(o?!a&&e[t]&&(n=!0):delete e[t],n?e[t]=s:Ge(e,t,s)):n?e[t]=s:$e(t,s);})(Function.prototype,"toString",(function(){return "function"==typeof this&&Je(this).source||Ze(this)}));var st=y,rt=y,it=function(e){return "function"==typeof e?e:void 0},ot={},nt=Math.ceil,at=Math.floor,lt=function(e){return isNaN(e=+e)?0:(e>0?at:nt)(e)},ct=lt,dt=Math.min,ht=lt,ut=Math.max,pt=Math.min,gt=C,mt=function(e){return e>0?dt(ct(e),9007199254740991):0},ft=function(e,t){var s=ht(e);return s<0?ut(s+t,0):pt(s,t)},bt=function(e){return function(t,s,r){var i,o=gt(t),n=mt(o.length),a=ft(r,n);if(e&&s!=s){for(;n>a;)if((i=o[a++])!=i)return !0}else for(;n>a;a++)if((e||a in o)&&o[a]===s)return e||a||0;return !e&&-1}},yt={includes:bt(!0),indexOf:bt(!1)},wt=q,vt=C,St=yt.indexOf,Et=Ce,xt=function(e,t){var s,r=vt(e),i=0,o=[];for(s in r)!wt(Et,s)&&wt(r,s)&&o.push(s);for(;t.length>i;)wt(r,s=t[i++])&&(~St(o,s)||o.push(s));return o},At=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"].concat("length","prototype");ot.f=Object.getOwnPropertyNames||function(e){return xt(e,At)};var Pt={};Pt.f=Object.getOwnPropertySymbols;var Mt=ot,Tt=Pt,kt=se,Ot=function(e,t){return arguments.length<2?it(st[e])||it(rt[e]):st[e]&&st[e][t]||rt[e]&&rt[e][t]}("Reflect","ownKeys")||function(e){var t=Mt.f(kt(e)),s=Tt.f;return s?t.concat(s(e)):t},Lt=q,Bt=Ot,Ft=w,Ct=ee,It=v,_t=/#|\.prototype\./,Rt=function(e,t){var s=jt[Nt(e)];return s==qt||s!=Ht&&("function"==typeof t?It(t):!!t)},Nt=Rt.normalize=function(e){return String(e).replace(_t,".").toLowerCase()},jt=Rt.data={},Ht=Rt.NATIVE="N",qt=Rt.POLYFILL="P",zt=Rt,Dt=y,Kt=w.f,Vt=de,Wt=he.exports,Ut=ge,Yt=function(e,t){for(var s=Bt(t),r=Ct.f,i=Ft.f,o=0;o<s.length;o++){var n=s[o];Lt(e,n)||r(e,n,i(t,n));}},Xt=zt,Gt=function(e,t){var s,r,i,o,n,a=e.target,l=e.global,c=e.stat;if(s=l?Dt:c?Dt[a]||Ut(a,{}):(Dt[a]||{}).prototype)for(r in t){if(o=t[r],i=e.noTargetGet?(n=Kt(s,r))&&n.value:s[r],!Xt(l?r:a+(c?".":"#")+r,e.forced)&&void 0!==i){if(typeof o==typeof i)continue;Yt(o,i);}(e.sham||i&&i.sham)&&Vt(o,"sham",!0),Wt(s,r,o,e);}},Qt=Math.min,$t=Math.max;Gt({target:"Math",stat:!0},{clamp:function(e,t,s){return Qt(s,$t(t,e))}});var Zt=new class{constructor(){this.callbacks=[],this.onceCallbacks=[],m.settings.ticker.external||(this.fps=60,this.fpsInterval=1e3/this.fps,this.lastTickTime=null,requestAnimationFrame(this.tick.bind(this)));}add(e,t){let s=!1;this.callbacks.forEach((r=>{r.cb===e&&r.context===t&&(s=!0);})),s||this.callbacks.push({cb:e,context:t});}remove(e,t){const s=this;this.callbacks.forEach(((r,i)=>{r.cb===e&&r.context===t&&delete s.callbacks[i];}));}nextTick(e,t){this.onceCallbacks.push({cb:e,context:t});}tick(e){const t=this,s=e-this.lastTickTime;s>this.fpsInterval&&(this.callbacks.forEach((t=>{t.cb.apply(t.context,[e]);})),this.onceCallbacks.forEach(((s,r)=>{s.cb.apply(s.context,[e]),delete t.onceCallbacks[r];})),this.lastTickTime=e-s%this.fpsInterval),m.settings.ticker.external||requestAnimationFrame(this.tick.bind(this));}};var Jt=new class{constructor(){this.elements=[],e.add("pageKill",this.pageKill.bind(this)),e.add("pageInit",this.init.bind(this),20),Zt.add(this.tick,this),this.bindEvents();}bindEvents(){p.on("resize",this.resizeHandler,this),p.on("mouseMove",this.mouseHandler,this);}pageKill(e){this.elements=[],e();}init(e){this.setBounding(),e();}resizeHandler(){this.setBounding();}mouseHandler(){const e=this;this.elements.forEach((t=>{e.setElementPosition(t);})),window.mouseLastScrollTop=window.scrollTop;}setBounding(){const e=this;this.elements.forEach((t=>{e.setElementBounding(t),e.setElementPosition(t);}));}setElementBounding(e){const t=e.getAttribute("style");e.setAttribute("style","");const s=e.getBoundingClientRect(),r={anchor:{x:s.left,y:s.top+window.unifiedScrollTop},width:e.offsetWidth,height:e.offsetHeight};(e.luge||(e.luge={}))&&(e.luge=g.mergeDeep(e.luge,r)),e.setAttribute("style",t);}setElementPosition(e){const t={x:window.mouseX-e.luge.anchor.x,y:window.mouseY-e.luge.anchor.y+window.unifiedScrollTop};t.progressX=Math.clamp(t.x/e.luge.width,0,1),t.progressY=Math.clamp(t.y/e.luge.height,0,1),e.luge.mouse=g.mergeDeep(e.luge.mouse,t);}add(e){this.elements.includes(e)||(this.setElementBounding(e),this.setElementPosition(e),this.elements.push(e));}remove(e){this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}tick(){const e=this;0!==window.scrollTop-window.mouseLastScrollTop&&this.elements.forEach((t=>{e.setElementPosition(t);}));}};var es=new class{constructor(){this.elements=[],this.setMaxScrollTop(),e.add("pageKill",this.pageKill.bind(this)),e.add("pageInit",this.init.bind(this),20),this.bindEvents();}bindEvents(){p.on("resize",this.resizeHandler,this),p.on("scroll",this.scrollHandler,this);}pageKill(e){this.elements=[],e();}init(e){this.setBounding(),this.checkElements(),e();}resizeHandler(){this.setBounding(),this.checkElements();}scrollHandler(){this.checkElements();}setBounding(){const e=this;this.setMaxScrollTop(),this.elements.forEach((t=>{e.setElementBounding(t);}));}setMaxScrollTop(){window.maxScrollTop=Math.max(document.body?document.body.scrollHeight:0,document.body?document.body.offsetHeight:0,document.documentElement.clientHeight,document.documentElement.scrollHeight,document.documentElement.offsetHeight)-window.innerHeight;}setElementBounding(e){const t=e.getAttribute("style");e.setAttribute("style","");const s=e.getBoundingClientRect();e.scrollStart=s.top+window.unifiedScrollTop-window.innerHeight,e.scrollEnd=e.scrollStart+e.clientHeight+window.innerHeight,e.scrollEnd=Math.min(e.scrollEnd,window.maxScrollTop),e.scrollMiddle=e.scrollStart+(e.scrollEnd-e.scrollStart)/2,e.setAttribute("style",t);}checkElements(){this.elements.forEach((e=>{this.checkElement(e);}));}checkElement(e){const t=window.unifiedScrollTop;let s="",r=Math.min(Math.max((t-e.scrollStart)/(e.scrollEnd-e.scrollStart),0),1);isNaN(r)&&(r=0),s=r<=0?"under":r>=1&&e.scrollEnd<window.maxScrollTop?"above":"in",e.scrollProgress=r,e.viewportPosition!==s?(e.viewportPosition=s,e.dispatchEvent(new CustomEvent("viewportintersect")),e.dispatchEvent(new CustomEvent("viewport"+s)),"in"!==s&&e.dispatchEvent(new CustomEvent("viewportout")),e.dispatchEvent(new CustomEvent("scrollprogress"))):r>0&&r<1&&e.dispatchEvent(new CustomEvent("scrollprogress"));}add(e){this.elements.includes(e)||(this.setElementBounding(e),this.checkElement(e),this.elements.push(e));}remove(e){this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}},ts="undefined"!=typeof globalThis&&globalThis||"undefined"!=typeof self&&self||void 0!==ts&&ts,ss="URLSearchParams"in ts,rs="Symbol"in ts&&"iterator"in Symbol,is$1="FileReader"in ts&&"Blob"in ts&&function(){try{return new Blob,!0}catch(e){return !1}}(),os="FormData"in ts,ns="ArrayBuffer"in ts;if(ns)var as=["[object Int8Array]","[object Uint8Array]","[object Uint8ClampedArray]","[object Int16Array]","[object Uint16Array]","[object Int32Array]","[object Uint32Array]","[object Float32Array]","[object Float64Array]"],ls=ArrayBuffer.isView||function(e){return e&&as.indexOf(Object.prototype.toString.call(e))>-1};function cs(e){if("string"!=typeof e&&(e=String(e)),/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(e)||""===e)throw new TypeError('Invalid character in header field name: "'+e+'"');return e.toLowerCase()}function ds(e){return "string"!=typeof e&&(e=String(e)),e}function hs(e){var t={next:function(){var t=e.shift();return {done:void 0===t,value:t}}};return rs&&(t[Symbol.iterator]=function(){return t}),t}function us(e){this.map={},e instanceof us?e.forEach((function(e,t){this.append(t,e);}),this):Array.isArray(e)?e.forEach((function(e){this.append(e[0],e[1]);}),this):e&&Object.getOwnPropertyNames(e).forEach((function(t){this.append(t,e[t]);}),this);}function ps(e){if(e.bodyUsed)return Promise.reject(new TypeError("Already read"));e.bodyUsed=!0;}function gs(e){return new Promise((function(t,s){e.onload=function(){t(e.result);},e.onerror=function(){s(e.error);};}))}function ms(e){var t=new FileReader,s=gs(t);return t.readAsArrayBuffer(e),s}function fs(e){if(e.slice)return e.slice(0);var t=new Uint8Array(e.byteLength);return t.set(new Uint8Array(e)),t.buffer}function bs(){return this.bodyUsed=!1,this._initBody=function(e){var t;this.bodyUsed=this.bodyUsed,this._bodyInit=e,e?"string"==typeof e?this._bodyText=e:is$1&&Blob.prototype.isPrototypeOf(e)?this._bodyBlob=e:os&&FormData.prototype.isPrototypeOf(e)?this._bodyFormData=e:ss&&URLSearchParams.prototype.isPrototypeOf(e)?this._bodyText=e.toString():ns&&is$1&&((t=e)&&DataView.prototype.isPrototypeOf(t))?(this._bodyArrayBuffer=fs(e.buffer),this._bodyInit=new Blob([this._bodyArrayBuffer])):ns&&(ArrayBuffer.prototype.isPrototypeOf(e)||ls(e))?this._bodyArrayBuffer=fs(e):this._bodyText=e=Object.prototype.toString.call(e):this._bodyText="",this.headers.get("content-type")||("string"==typeof e?this.headers.set("content-type","text/plain;charset=UTF-8"):this._bodyBlob&&this._bodyBlob.type?this.headers.set("content-type",this._bodyBlob.type):ss&&URLSearchParams.prototype.isPrototypeOf(e)&&this.headers.set("content-type","application/x-www-form-urlencoded;charset=UTF-8"));},is$1&&(this.blob=function(){var e=ps(this);if(e)return e;if(this._bodyBlob)return Promise.resolve(this._bodyBlob);if(this._bodyArrayBuffer)return Promise.resolve(new Blob([this._bodyArrayBuffer]));if(this._bodyFormData)throw new Error("could not read FormData body as blob");return Promise.resolve(new Blob([this._bodyText]))},this.arrayBuffer=function(){if(this._bodyArrayBuffer){var e=ps(this);return e||(ArrayBuffer.isView(this._bodyArrayBuffer)?Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset,this._bodyArrayBuffer.byteOffset+this._bodyArrayBuffer.byteLength)):Promise.resolve(this._bodyArrayBuffer))}return this.blob().then(ms)}),this.text=function(){var e,t,s,r=ps(this);if(r)return r;if(this._bodyBlob)return e=this._bodyBlob,t=new FileReader,s=gs(t),t.readAsText(e),s;if(this._bodyArrayBuffer)return Promise.resolve(function(e){for(var t=new Uint8Array(e),s=new Array(t.length),r=0;r<t.length;r++)s[r]=String.fromCharCode(t[r]);return s.join("")}(this._bodyArrayBuffer));if(this._bodyFormData)throw new Error("could not read FormData body as text");return Promise.resolve(this._bodyText)},os&&(this.formData=function(){return this.text().then(vs)}),this.json=function(){return this.text().then(JSON.parse)},this}us.prototype.append=function(e,t){e=cs(e),t=ds(t);var s=this.map[e];this.map[e]=s?s+", "+t:t;},us.prototype.delete=function(e){delete this.map[cs(e)];},us.prototype.get=function(e){return e=cs(e),this.has(e)?this.map[e]:null},us.prototype.has=function(e){return this.map.hasOwnProperty(cs(e))},us.prototype.set=function(e,t){this.map[cs(e)]=ds(t);},us.prototype.forEach=function(e,t){for(var s in this.map)this.map.hasOwnProperty(s)&&e.call(t,this.map[s],s,this);},us.prototype.keys=function(){var e=[];return this.forEach((function(t,s){e.push(s);})),hs(e)},us.prototype.values=function(){var e=[];return this.forEach((function(t){e.push(t);})),hs(e)},us.prototype.entries=function(){var e=[];return this.forEach((function(t,s){e.push([s,t]);})),hs(e)},rs&&(us.prototype[Symbol.iterator]=us.prototype.entries);var ys=["DELETE","GET","HEAD","OPTIONS","POST","PUT"];function ws(e,t){if(!(this instanceof ws))throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');var s,r,i=(t=t||{}).body;if(e instanceof ws){if(e.bodyUsed)throw new TypeError("Already read");this.url=e.url,this.credentials=e.credentials,t.headers||(this.headers=new us(e.headers)),this.method=e.method,this.mode=e.mode,this.signal=e.signal,i||null==e._bodyInit||(i=e._bodyInit,e.bodyUsed=!0);}else this.url=String(e);if(this.credentials=t.credentials||this.credentials||"same-origin",!t.headers&&this.headers||(this.headers=new us(t.headers)),this.method=(s=t.method||this.method||"GET",r=s.toUpperCase(),ys.indexOf(r)>-1?r:s),this.mode=t.mode||this.mode||null,this.signal=t.signal||this.signal,this.referrer=null,("GET"===this.method||"HEAD"===this.method)&&i)throw new TypeError("Body not allowed for GET or HEAD requests");if(this._initBody(i),!("GET"!==this.method&&"HEAD"!==this.method||"no-store"!==t.cache&&"no-cache"!==t.cache)){var o=/([?&])_=[^&]*/;if(o.test(this.url))this.url=this.url.replace(o,"$1_="+(new Date).getTime());else {this.url+=(/\?/.test(this.url)?"&":"?")+"_="+(new Date).getTime();}}}function vs(e){var t=new FormData;return e.trim().split("&").forEach((function(e){if(e){var s=e.split("="),r=s.shift().replace(/\+/g," "),i=s.join("=").replace(/\+/g," ");t.append(decodeURIComponent(r),decodeURIComponent(i));}})),t}function Ss(e,t){if(!(this instanceof Ss))throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');t||(t={}),this.type="default",this.status=void 0===t.status?200:t.status,this.ok=this.status>=200&&this.status<300,this.statusText=void 0===t.statusText?"":""+t.statusText,this.headers=new us(t.headers),this.url=t.url||"",this._initBody(e);}ws.prototype.clone=function(){return new ws(this,{body:this._bodyInit})},bs.call(ws.prototype),bs.call(Ss.prototype),Ss.prototype.clone=function(){return new Ss(this._bodyInit,{status:this.status,statusText:this.statusText,headers:new us(this.headers),url:this.url})},Ss.error=function(){var e=new Ss(null,{status:0,statusText:""});return e.type="error",e};var Es=[301,302,303,307,308];Ss.redirect=function(e,t){if(-1===Es.indexOf(t))throw new RangeError("Invalid status code");return new Ss(null,{status:t,headers:{location:e}})};var xs=ts.DOMException;try{new xs;}catch(e){(xs=function(e,t){this.message=e,this.name=t;var s=Error(e);this.stack=s.stack;}).prototype=Object.create(Error.prototype),xs.prototype.constructor=xs;}function As(e,t){return new Promise((function(s,r){var i=new ws(e,t);if(i.signal&&i.signal.aborted)return r(new xs("Aborted","AbortError"));var o=new XMLHttpRequest;function n(){o.abort();}o.onload=function(){var e,t,r={status:o.status,statusText:o.statusText,headers:(e=o.getAllResponseHeaders()||"",t=new us,e.replace(/\r?\n[\t ]+/g," ").split("\r").map((function(e){return 0===e.indexOf("\n")?e.substr(1,e.length):e})).forEach((function(e){var s=e.split(":"),r=s.shift().trim();if(r){var i=s.join(":").trim();t.append(r,i);}})),t)};r.url="responseURL"in o?o.responseURL:r.headers.get("X-Request-URL");var i="response"in o?o.response:o.responseText;setTimeout((function(){s(new Ss(i,r));}),0);},o.onerror=function(){setTimeout((function(){r(new TypeError("Network request failed"));}),0);},o.ontimeout=function(){setTimeout((function(){r(new TypeError("Network request failed"));}),0);},o.onabort=function(){setTimeout((function(){r(new xs("Aborted","AbortError"));}),0);},o.open(i.method,function(e){try{return ""===e&&ts.location.href?ts.location.href:e}catch(t){return e}}(i.url),!0),"include"===i.credentials?o.withCredentials=!0:"omit"===i.credentials&&(o.withCredentials=!1),"responseType"in o&&(is$1?o.responseType="blob":ns&&i.headers.get("Content-Type")&&-1!==i.headers.get("Content-Type").indexOf("application/octet-stream")&&(o.responseType="arraybuffer")),!t||"object"!=typeof t.headers||t.headers instanceof us?i.headers.forEach((function(e,t){o.setRequestHeader(t,e);})):Object.getOwnPropertyNames(t.headers).forEach((function(e){o.setRequestHeader(e,ds(t.headers[e]));})),i.signal&&(i.signal.addEventListener("abort",n),o.onreadystatechange=function(){4===o.readyState&&i.signal.removeEventListener("abort",n);}),o.send(void 0===i._bodyInit?null:i._bodyInit);}))}As.polyfill=!0,ts.fetch||(ts.fetch=As,ts.Headers=us,ts.Request=ws,ts.Response=Ss);var Ps=new class{constructor(){this.url=window.location.href,this.pageFetched=null,this.currentPage=null,this.reload=m.settings.transition.reload,this.transitions={in:{},out:{}},this.listeners={linkHandler:this.linkHandler.bind(this)},e.add("siteInit",this.siteInit.bind(this)),e.add("pageInit",this.pageInit.bind(this)),e.add("pageFetch",this.pageFetch.bind(this)),e.add("pageOut",this.pageOut.bind(this)),e.add("pageIn",this.pageIn.bind(this),10,"transition"),e.add("pageCreate",this.pageCreate.bind(this)),e.add("pageKill",this.pageKill.bind(this),999,"transition");}bindLinksEvent(){document.querySelector("[data-lg-page]")&&document.querySelectorAll("a").forEach((e=>{e.addEventListener("click",this.listeners.linkHandler);}));}unbindLinksEvent(){document.querySelectorAll("a").forEach((e=>{e.removeEventListener("click",this.listeners.linkHandler);}));}linkHandler(e){const t=e.currentTarget,s=t.getAttribute("href");if(s&&0!==s.indexOf("#")&&0!==s.indexOf("tel")&&0!==s.indexOf("mailto")&&!t.closest("#wpadminbar")&&"disabled"!==t.getAttribute("data-lg-transition")&&"_blank"!==t.getAttribute("target")&&(0===s.indexOf(window.location.origin)||0===s.indexOf("/")||-1===s.indexOf("/"))){if(e.preventDefault(),window.location.href===s)return;this.navigateTo(s),history.pushState(null,null,this.url);}}navigateTo(t){if(this.url=t,this.reload){const s=document.createElement("link");s.rel="prefetch",s.href=t,document.head.appendChild(s),e.add("siteReload",(e=>{window.location=t;})),e.cycle("reload");}else e.cycle("transition");}siteInit(e){this.currentPage=document.querySelector("[data-lg-page]"),this.currentPage&&(this.reload=!!this.currentPage.hasAttribute("data-lg-reload")||m.settings.transition.reload),this.initLoader(),e(),this.reload||window.addEventListener("popstate",this.historyStateChanged.bind(this));}pageInit(e){this.bindLinksEvent(),e();}initLoader(){const e=document.querySelector("[data-lg-loader]");if(e&&(e.style.transition="none",e.classList.add("lg-loader","lg-loader--"+e.getAttribute("data-lg-loader")),Zt.nextTick((()=>{e.style.transition="";}))),e&&"lottie"===e.getAttribute("data-lg-loader")&&"object"==typeof lottie){const t=e.getAttribute("data-lg-loader-out");let s=!1,r=e.getAttribute("data-lg-loader-in"),i=!1;t&&(s=lottie.loadAnimation({container:e,renderer:"svg",loop:!1,autoplay:!1,path:t,rendererSettings:{preserveAspectRatio:"none"}})),"reverse"===r&&(r=t),r&&(i=lottie.loadAnimation({container:e,renderer:"svg",loop:!1,autoplay:!1,path:r,rendererSettings:{preserveAspectRatio:"none"}}),r===t&&i.setDirection(-1)),e.playerOut=s,e.playerIn=i;}}pageFetch(e){const t=this;this.url&&fetch(this.url,{credentials:"include"}).then((function(e){return e.text()})).then((function(s){t.pageFetched=s,e();}));}pageCreate(e){const t=(new DOMParser).parseFromString(this.pageFetched,"text/html"),s=t.querySelector("[data-lg-page]");s?(this.currentPage.insertAdjacentElement("beforebegin",s),s.style.opacity=0,this.currentPage.style.opacity=0,this.currentPage.style.position="absolute",this.currentPage.style.top=0,this.currentPage.style.left="-999em",this.currentPage.style.width="100%",document.querySelector("body").className=t.querySelector("body").className,document.querySelectorAll('meta[name="description"], meta[name="keywords"], meta[property="og:image"]').forEach((e=>{e.parentNode.removeChild(e);})),t.querySelectorAll('meta[name="description"], meta[name="keywords"], meta[property="og:image"]').forEach((e=>{document.querySelector("head title").insertAdjacentElement("afterend",e);})),document.querySelector("head title").innerText=t.querySelector("head title").innerText,window.scroll({top:0,left:0,behavior:"instant"}),window.scrollTop=0,window.smoothScrollTop=0,window.unifiedScrollTop=0,p.emit("pageTransition",t),e()):window.location=this.url;}pageKill(e){const t=this.currentPage;t.parentNode.removeChild(t),this.currentPage=document.querySelector("[data-lg-page]"),this.reload=!!this.currentPage.hasAttribute("data-lg-reload")||m.settings.transition.reload,e();}pageOut(e){const t=this,s=document.querySelector("[data-lg-page]");if(s){const r=g.toCamelCase(s.getAttribute("data-lg-page"));let i=!1;if("function"==typeof this.transitions.out[r]?i=this.transitions.out[r]:"function"==typeof s.onpageout?i=s.onpageout:"function"==typeof this.transitions.out.default&&(i=this.transitions.out.default),i)i(s,e);else {const s=document.querySelector("[data-lg-loader]");if(s){if(s.playerOut)s.playerOut.stop(),s.playerOut.renderer.svgElement.style.opacity=1,s.playerOut.play(),s.playerOut.addEventListener("complete",(()=>{t.reload||(s.playerOut.renderer.svgElement.style.opacity=""),e();}),{once:!0});else {const t=window.getComputedStyle(document.querySelector("[data-lg-loader]")).getPropertyValue("transition-duration");""!==t&&"0s"!==t?s.addEventListener("transitionend",e,{once:!0}):e();}s.classList.add("is-visible");}else e();}}else e();this.unbindLinksEvent.bind(this);}pageIn(e){const t=document.querySelector("[data-lg-page]");if(t){const s=g.toCamelCase(t.getAttribute("data-lg-page"));let r=!1;if(t.style.opacity="","function"==typeof this.transitions.in[s]?r=this.transitions.in[s]:"function"==typeof t.onpagein?r=t.onpagein:"function"==typeof this.transitions.in.default&&(r=this.transitions.in.default),r)r(t,e);else {const t=document.querySelector("[data-lg-loader]");if(t&&t.classList.contains("is-visible"))if(t.playerIn)t.playerIn.stop(),t.playerIn.renderer.svgElement.style.opacity=1,"reverse"===t.getAttribute("data-lg-loader-in")?t.playerIn.goToAndPlay(t.playerIn.totalFrames,!0):t.playerIn.play(),t.playerIn.addEventListener("complete",(()=>{t.playerIn.renderer.svgElement.style.opacity="",t.classList.remove("is-visible"),e();}),{once:!0});else {const s=window.getComputedStyle(document.querySelector("[data-lg-loader]")).getPropertyValue("transition-duration");""!==s&&"0s"!==s?t.addEventListener("transitionend",e,{once:!0}):e(),t.classList.remove("is-visible");}else e();}}else e();}historyStateChanged(){""===window.location.hash&&this.navigateTo(window.location.href);}add(e,t="default",s){this.transitions[e]&&(t=g.toCamelCase(t),this.transitions[e][t]?console.log("Transition animation for "+t+" page already exists."):this.transitions[e][t]=s);}};class Ms{constructor(t){this.pluginSlug=t,this.isDisabled=this.disabled(),this.isDisabled?document.documentElement.classList.add("lg-"+this.pluginSlug+"-disabled"):e.add("siteInit",this.initPlugin.bind(this),5);}disabled(){let e=!1;return void 0!==m.settings[this.pluginSlug]&&void 0!==m.settings[this.pluginSlug].disabled&&(e=m.settings[this.pluginSlug].disabled),g.isString(e)?e=window.browser.is(e,!0):g.isArray(e)?e=e.some((e=>g.isString(e)?window.browser.is(e,!0):!!g.isObject(e)&&window.browser.satisfies(e))):g.isObject(e)&&(e=window.browser.satisfies(e)),e}initPlugin(e){this.setAttributes(),e();}setAttributes(){this.pluginAttributes={};}getAttributes(e){const t=this.pluginAttributes,s={};for(const r in t){const i=t[r];let o="lg-"+this.pluginSlug;"root"!==r&&(o+="-"+r),o=g.toCamelCase(o);const n=e.dataset[o];let a,l,c;"object"==typeof i?(a=i[0],c=i[1]):a=i,l=void 0===n&&void 0!==c?a(c):(void 0!==n||a!==Boolean)&&(void 0!==n?a===Boolean?"false"!==n:a(n):void 0),s[r]=l;}return (e.luge||(e.luge={}))&&(e.luge[this.pluginSlug]=s),s}}new class extends Ms{constructor(){super("cursor"),this.isDisabled||(this.cursors=[],this.pointers=[],this.trails=[],this.hoverTags=["a","button"],e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),Zt.add(this.tick,this),this.bindEvents());}setAttributes(){this.pluginAttributes={root:String,inertia:[Number,m.settings.cursor.inertia],length:[Number,m.settings.cursor.trailLength],hide:Boolean};}bindEvents(){document.documentElement.addEventListener("mouseenter",this.hoverHandler.bind(this),{capture:!0,passive:!0}),document.documentElement.addEventListener("mouseleave",this.hoverHandler.bind(this),{capture:!0,passive:!0});}pageInit(e){const t=this,s=document.querySelectorAll("[data-lg-cursor]");s.length>0&&s.forEach((e=>{const s=this.getAttributes(e);s.hide&&document.documentElement.classList.add("lg-cursor-hide");e.querySelectorAll("[data-lg-cursor-pointer").forEach((e=>{e.luge={cursor:{position:{x:0,y:0},smoothPosition:{x:0,y:0}}},e.hasAttribute("data-lg-cursor-inertia")?e.luge.cursor.inertia=Number(e.getAttribute("data-lg-cursor-inertia")):e.luge.cursor.inertia=s.inertia,e.classList.add("lg-cursor-pointer"),t.pointers.push(e);}));e.querySelectorAll("[data-lg-cursor-trail").forEach((e=>{const r=document.createElementNS("http://www.w3.org/2000/svg","svg"),i=document.createElementNS("http://www.w3.org/2000/svg","path");r.appendChild(i),e.appendChild(r),e.luge={cursor:{position:{x:0,y:0},smoothPosition:{x:0,y:0},points:[],path:i}},e.hasAttribute("data-lg-cursor-inertia")?e.luge.cursor.inertia=Number(e.getAttribute("data-lg-cursor-inertia")):e.luge.cursor.inertia=s.inertia,e.hasAttribute("data-lg-cursor-length")?e.luge.cursor.length=Number(e.getAttribute("data-lg-cursor-length")):e.luge.cursor.length=s.length,e.classList.add("lg-cursor-trail"),t.trails.push(e);})),e.classList.add("lg-cursor"),this.cursors.push(e);})),e();}pageKill(e){this.cursors=[],this.pointers=[],this.trails=[],e();}hoverHandler(e){const t=e.target,s=t.tagName.toLowerCase(),r=t.getAttribute("data-lg-hover");let i=null;(this.hoverTags.includes(s)||null!==r)&&(i="mouseenter"===e.type),null!==i&&this.cursors.forEach((e=>{e.classList.toggle("lg-cursor--hover",i),null!==r&&""!==r&&e.classList.toggle("lg-cursor--hover--"+r,i);}));}tick(e){this.pointers.forEach((e=>{const t=e.luge.cursor.position,s=e.luge.cursor.smoothPosition;t.x=window.mouseX,t.y=window.mouseY,s.x+=(t.x-s.x)*e.luge.cursor.inertia,s.y+=(t.y-s.y)*e.luge.cursor.inertia,e.style.transform="translate3d("+s.x+"px, "+s.y+"px, 0)";})),this.trails.forEach((e=>{const t=e.luge.cursor.position,s=e.luge.cursor.smoothPosition;t.x=window.mouseX,t.y=window.mouseY,s.x+=(t.x-s.x)*e.luge.cursor.inertia,s.y+=(t.y-s.y)*e.luge.cursor.inertia;const r=e.luge.cursor.points,i={x:s.x,y:s.y};r.push(i),r.length>e.luge.cursor.length&&r.shift();let o="",n=0;const a=(e,t,s,r)=>{const i=((e,t)=>{const s=t.x-e.x,r=t.y-e.y;return {length:Math.sqrt(Math.pow(s,2)+Math.pow(r,2)),angle:Math.atan2(r,s)}})(t||e,s||e);n+=i.length;const o=i.angle+(r?Math.PI:0),a=.2*i.length;return [e.x+Math.cos(o)*a,e.y+Math.sin(o)*a]};o=((e,t)=>`${e.reduce(((e,s,r,i)=>0===r?`M ${s.x},${s.y}`:`${e} ${t(s,r,i)}`),"")}`)(r,((e,t,s)=>{const[r,i]=a(s[t-1],s[t-2],e),[o,n]=a(e,s[t-1],s[t+1],!0);return `C ${r},${i} ${o},${n} ${e.x},${e.y}`})),e.luge.cursor.path.setAttribute("d",o),e.style.setProperty("--length",n);}));}};new class extends Ms{constructor(){super("lottie"),this.isDisabled||(this.elements=[],this.doneLoad=null,this.onViewportIntersect=this.onViewportIntersect.bind(this),this.onScrollProgress=this.onScrollProgress.bind(this),"object"==typeof lottie&&(e.add("pageInit",this.pageInit.bind(this)),e.add("pageLoad",this.pageLoad.bind(this)),e.add("pageKill",this.pageKill.bind(this)),e.add("reveal",this.reveal.bind(this))));}setAttributes(){this.pluginAttributes={root:String,autoplay:Boolean,scroll:Boolean,loop:Boolean,loopFrame:[Number,0],reverse:Boolean,required:Boolean,force:Boolean,renderer:[String,m.settings.lottie.renderer],subframe:[Boolean,m.settings.lottie.subFrame]};}pageLoad(e){let t=!1;this.elements.length>0&&this.elements.forEach((e=>{e.luge.lottie.required&&!e.player.isLoaded&&(t=!0);})),t?this.doneLoad=e:e();}pageInit(e){const t=this;this.elements=document.querySelectorAll("[data-lg-lottie]"),this.toAutoplay=[],this.toLoad=0,this.requireds=0,this.elements.forEach((e=>{e.player||(es.add(e),t.initPlayer(e),e.addEventListener("revealin",t.play),e.addEventListener("viewportintersect",t.onViewportIntersect));})),e();}pageKill(e){const t=this;let s=[];const r=document.querySelector("[data-lg-page] + [data-lg-page]");s=r?r.querySelectorAll("[data-lg-lottie]"):this.elements,s.forEach((e=>{e.removeEventListener("revealin",t.play),e.removeEventListener("viewportintersect",t.onViewportIntersect),e.hasAttribute("data-lg-lottie-scroll")&&e.removeEventListener("scrollprogress",t.onScrollProgress),e.player&&(e.player.destroy(),delete e.player);})),e();}reveal(e){this.toAutoplay.forEach((e=>{"in"===e.viewportPosition&&e.play();})),e();}onViewportIntersect(e){const t=e.target;t.luge.lottie.force||("in"===t.viewportPosition?t.player.isPaused&&(t.player.scrollPaused||t.hasAttribute("data-lg-lottie-autoplay"))&&(t.player.scrollPaused=!1,t.play()):t.player.isPaused||(t.player.scrollPaused=!0,t.pause()));}initPlayer(e){const t=this;this.toLoad++;const s=this.getAttributes(e);e.player=lottie.loadAnimation({container:e,renderer:s.renderer,loop:s.loop&&!s.reverse,autoplay:!1,path:s.root}),void 0!==s.subframe&&e.player.setSubframe(s.subframe),e.classList.add("lg-lottie"),this.setPlayerStateClasses(e,!1),s.autoplay&&this.toAutoplay.push(e),s.required&&this.requireds++,s.scroll?e.addEventListener("scrollprogress",this.onScrollProgress):s.loop&&e.player.addEventListener("enterFrame",(function(){if(e.player.totalFrames>0){const r=Math.round(e.player.currentFrame);1===e.player.playDirection?r===e.player.totalFrames-1&&(e.player.pause(),s.reverse?Zt.nextTick((()=>{e.player.setDirection(-1),e.player.goToAndPlay(e.player.totalFrames,!0),t.setPlayerStateClasses(e,"backward");}),this):Zt.nextTick((()=>{e.player.goToAndPlay(s.loopFrame,!0);}),this)):r===s.loopFrame&&(e.player.pause(),Zt.nextTick((()=>{e.player.setDirection(1),e.player.goToAndPlay(s.loopFrame,!0),t.setPlayerStateClasses(e,"forward");}),this));}})),e.play=this.play.bind(this,e),e.pause=this.pause.bind(this,e),e.stop=this.stop.bind(this,e),e.player.addEventListener("DOMLoaded",(()=>{e.classList.add("is-loaded"),t.playerLoaded(s.required);}),{once:!0});}setPlayerStateClasses(e,t){e.classList.remove("is-playing","is-playing-forward","is-playing-backward","is-paused"),t?(e.classList.add("is-playing"),"backward"===t?e.classList.add("is-playing-backward"):e.classList.add("is-playing-forward")):e.classList.add("is-paused");}playerLoaded(e=!1){this.toLoad--,e&&this.requireds--,0===this.requireds&&"function"==typeof this.doneLoad&&(this.doneLoad(),this.doneLoad=null),0===this.toLoad&&p.emit("resize");}play(e){e&&e.player&&(e.player.play(),this.setPlayerStateClasses(e,"forward"));}pause(e){e&&e.player&&(e.player.pause(),this.setPlayerStateClasses(e,!1));}stop(e){e&&e.player&&(e.player.stop(),this.setPlayerStateClasses(e,!1));}onScrollProgress(e){const t=e.target;t.player.goToAndStop(t.player.totalFrames*t.scrollProgress,!0);}};new class extends Ms{constructor(){super("mouse"),this.isDisabled||(this.elements=[],this.mouse={x:window.mouseX,y:window.mouseY},window.mouseSpeed=0,e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),Zt.add(this.tick,this),this.getMouseMovement());}setAttributes(){this.pluginAttributes={root:String,inertia:[String,m.settings.mouse.inertia]};}getAttributes(e){const t=super.getAttributes(e);if(t.inertia){const e=t.inertia.match(/\{\s*([0-9]*[.]?[0-9]*)\s*,\s*([0-9]*[.]?[0-9]*)\s*\}/m);t.inertia=e?Number(e[1])+(Number(e[2])-Number(e[1]))*Math.random():Number(t.inertia),t.inertia=Math.max(Math.min(t.inertia,.99),0);}return t}pageInit(e){const t=document.querySelectorAll("[data-lg-mouse]"),s=this;t.forEach((e=>{s.addElement(e);})),e();}addElement(e){this.elements.includes(e)||(this.getAttributes(e),Jt.add(e),e.luge.mouse.smoothX=e.luge.mouse.x,e.luge.mouse.smoothY=e.luge.mouse.y,e.luge.mouse.smoothProgressX=e.luge.mouse.progressX,e.luge.mouse.smoothProgressY=e.luge.mouse.progressY,this.elements.push(e));}removeElement(e){this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}pageKill(e){const t=this;this.elements.forEach((e=>{t.removeElement(e);})),e();}getMouseMovement(){const e=this.mouse.x-window.mouseX,t=this.mouse.y-window.mouseY,s=Math.hypot(e,t);if(window.mouseSpeed+=.5*(s-window.mouseSpeed),window.mouseSpeed<.001&&(window.mouseSpeed=0),s>1){const s=Math.atan2(t,e)*(180/Math.PI)+180;window.mouseAngle=s,window.mouseDirection=s>=45&&s<135?"down":s>=135&&s<225?"left":s>=225&&s<315?"up":"right";}this.mouse={x:window.mouseX,y:window.mouseY},setTimeout(this.getMouseMovement.bind(this),20);}tick(){this.elements.forEach((e=>{const t=e.luge.mouse;if(t.inertia){t.smoothX+=(t.x-t.smoothX)*t.inertia,t.smoothY+=(t.y-t.smoothY)*t.inertia,t.smoothProgressX+=(t.progressX-t.smoothProgressX)*t.inertia,t.smoothProgressY+=(t.progressY-t.smoothProgressY)*t.inertia,e.style.setProperty("--mouse-x",t.smoothX),e.style.setProperty("--mouse-y",t.smoothY),e.style.setProperty("--mouse-progress-x",t.smoothProgressX),e.style.setProperty("--mouse-progress-y",t.smoothProgressY);const s=Math.round(1e3*(t.x-t.smoothX))/1e3,r=Math.round(1e3*(t.y-t.smoothY))/1e3;e.style.setProperty("--abs-diff-x",Math.abs(s)),e.style.setProperty("--diff-x",s),e.style.setProperty("--abs-diff-y",Math.abs(r)),e.style.setProperty("--diff-y",r);}else e.style.setProperty("--mouse-x",t.x),e.style.setProperty("--mouse-y",t.y),e.style.setProperty("--mouse-progress-x",t.progressX),e.style.setProperty("--mouse-progress-y",t.progressY);}));}};new class extends Ms{constructor(){super("parallax"),this.isDisabled||(this.elements=[],this.onScrollProgress=this.onScrollProgress.bind(this),e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),Zt.add(this.tick,this));}setAttributes(){this.pluginAttributes={root:String,disable:String,amplitude:[String,1],anchor:String,inertia:[String,m.settings.parallax.inertia]};}getAttributes(e){const t=super.getAttributes(e);if(t.amplitude){const e=t.amplitude.match(/\{\s*([0-9]*[.]?[0-9]*)\s*,\s*([0-9]*[.]?[0-9]*)\s*\}/m);t.amplitude=e?Number(e[1])+(Number(e[2])-Number(e[1]))*Math.random():Number(t.amplitude);}return t}pageInit(e){document.querySelectorAll("[data-lg-parallax]").forEach((e=>{const t=this.getAttributes(e).disable;let s=!0;t&&("desktop"===t&&window.browser.is("desktop")||"handheld"===t&&!window.browser.is("desktop")||"mobile"===t&&window.browser.is("mobile")||"tablet"===t&&window.browser.is("tablet"))&&(s=!1),s&&this.addElement(e);})),e();}pageKill(e){const t=this;this.elements.forEach((e=>{t.removeElement(e);})),e();}addElement(e){this.elements.includes(e)||(es.add(e),e.addEventListener("scrollprogress",this.onScrollProgress),"child"===e.luge.parallax.root&&(e.style.overflow="hidden",e.luge.parallax.child=e.firstElementChild),e.luge.parallax.movement=0,e.luge.parallax.smoothMovement=0,this.elements.push(e),this.moveElement(e));}removeElement(e){e.removeEventListener("scrollprogress",this.onScrollProgress),this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}onScrollProgress(e){this.moveElement(e.target);}moveElement(e){let t=1-2*e.scrollProgress;"bottom"===e.luge.parallax.anchor?t+=1:"top"===e.luge.parallax.anchor&&(t-=1),"child"===e.luge.parallax.root?e.luge.parallax.movement=5*e.luge.parallax.amplitude*t:e.luge.parallax.movement=e.clientHeight*t*e.luge.parallax.amplitude/2;}tick(){this.elements.forEach((e=>{e.luge.parallax.smoothMovement+=(e.luge.parallax.movement-e.luge.parallax.smoothMovement)*e.luge.parallax.inertia,"child"===e.luge.parallax.root?e.luge.parallax.child.style.transform="translate3d(0, "+e.luge.parallax.smoothMovement+"%, 0) scale(1."+String(Math.abs(e.luge.parallax.amplitude)).replace(".","")+")":e.style.transform="translate3d(0, "+e.luge.parallax.smoothMovement+"px, 0)";}));}};var Ts=new class extends Ms{constructor(){super("preloader"),this.isDisabled||(this.intro=!1,this.playerIn=!1,this.startTime=Date.now(),this.doneLoad=null,e.add("siteInit",this.siteInit.bind(this)),e.add("pageLoad",this.pageLoad.bind(this)));}setAttributes(){this.pluginAttributes={root:[String,""],duration:[Number,m.settings.preloader.duration],in:String,reverse:Boolean};}siteInit(t){this.el=document.querySelector("[data-lg-preloader]"),this.el&&(this.attributes=this.getAttributes(this.el),this.el.classList.add("lg-preloader","lg-preloader--"+this.attributes.root),this.initLottie(),e.add("siteIn",this.siteIn.bind(this))),t();}pageLoad(e){this.attributes&&"lottie"===this.attributes.root&&"object"==typeof lottie?this.doneLoad=e:e();}siteIn(e){const t=(Date.now()-this.startTime)/1e3,s=this.attributes.duration-t;if(s<=0){const t=this.clear.bind(this,e);if(this.playerIn)this.playerIn.play(),this.playerIn.addEventListener("complete",t,{once:!0});else if("function"==typeof this.intro)this.intro(e,this.remove.bind(this));else {const e=window.getComputedStyle(this.el).getPropertyValue("transition-duration");""!==e&&"0s"!==e?(this.el.addEventListener("transitionend",t,{once:!0}),this.el.classList.add("is-hidden")):t();}}else setTimeout(this.siteIn.bind(this,e),1e3*s);}clear(e){this.playerIn&&this.playerIn.destroy(),this.remove(),e();}remove(e){this.el.parentNode.removeChild(this.el),this.el=null;}add(e){this.intro=e;}initLottie(){const e=this;if("lottie"===this.attributes.root&&"object"==typeof lottie){const t=this.attributes.in;let s=!1;t&&(s=lottie.loadAnimation({container:this.el,renderer:"svg",loop:!1,autoplay:!1,path:t,rendererSettings:{preserveAspectRatio:"none"}}),this.attributes.reverse&&s.setDirection(-1)),s.addEventListener("DOMLoaded",(()=>{e.attributes.reverse&&s.goToAndStop(s.totalFrames-1,!0),e.el.setAttribute("style",""),"function"==typeof e.doneLoad&&(e.doneLoad(),e.doneLoad=null);}),{once:!0}),this.playerIn=s;}}};var ks=new class extends Ms{constructor(){super("reveal"),this.isDisabled||(this.elements=[],this.toRevealIn=[],this.toRevealOut=[],this.reveals={in:{},out:{}},this.canReveal=!1,this.onScrollProgress=this.onScrollProgress.bind(this),e.add("pageInit",this.pageInit.bind(this),11),e.add("pageKill",this.pageKill.bind(this)),e.add("reveal",this.reveal.bind(this)),this.bindEvents());}setAttributes(){super.setAttributes(),this.pluginAttributes={root:String,stagger:String,multiple:Boolean,delay:[Number,0]};}getAttributes(e){const t=super.getAttributes(e);return void 0!==t.stagger&&""===t.stagger?t.stagger=m.settings.reveal.stagger:void 0===t.stagger&&(t.stagger=!1),t}bindEvents(){p.on("resize",this.resizeHandler,this),p.on("scroll",this.scrollHandler,this);}pageInit(e){const t=document.querySelectorAll("[data-lg-reveal]:not([data-lg-reveal-manual])"),s=this;t.forEach((e=>{s.addElement(e);})),e();}addElement(e){if(!this.elements.includes(e)){const t=this.getAttributes(e);if(!t.stagger&&null!==e.closest("[data-lg-reveal-stagger]"))return;es.add(e),e.addEventListener("scrollprogress",this.onScrollProgress);const s=t.root;e.luge.reveal.name=g.toCamelCase(s),e.luge.reveal.delay=1e3*t.delay,t.stagger?Array.from(e.children).forEach((e=>{const t=e.dataset.lgReveal;e.style.transition="none",Zt.nextTick((()=>{e.style.transition="";})),e.classList.add("lg-reveal","is-out"),(t||s)&&e.classList.add("lg-reveal--"+(null!=t?t:s)),e.dataset.lgRevealChild="",(e.luge||(e.luge={}))&&(e.luge.reveal={isRevealed:!1});})):(e.style.transition="none",Zt.nextTick((()=>{e.style.transition="";})),e.classList.add("lg-reveal","is-out"),s&&e.classList.add("lg-reveal--"+s)),this.elements.push(e);}}removeElement(e){e.removeEventListener("scrollprogress",this.onScrollProgress),this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}pageKill(e){const t=this;this.canReveal=!1,this.elements.forEach((e=>{t.removeElement(e);})),e();}onScrollProgress(e){const t=e.target,s=m.settings.reveal.threshold;t.scrollProgress>=s&&t.scrollProgress<=1-s&&!t.luge.reveal.isRevealed?(this.toRevealOut.includes(t)&&this.toRevealOut.splice(this.toRevealOut.indexOf(t),1),this.toRevealIn.includes(t)||this.toRevealIn.push(t)):(t.scrollProgress<s||t.scrollProgress>1-s)&&t.luge.reveal.isRevealed&&(this.toRevealIn.includes(t)&&this.toRevealIn.splice(this.toRevealIn.indexOf(t),1),this.toRevealOut.includes(t)||this.toRevealOut.push(t));}reveal(e){this.canReveal=!0,this.elements.forEach((e=>{e.scrollStart<0&&(this.toRevealIn.includes(e)||this.toRevealIn.push(e));})),this.revealElements(),e();}resizeHandler(){this.revealElements();}scrollHandler(){this.revealElements();}revealElements(){const e=this;if(this.canReveal){let t=0;this.toRevealIn.forEach((s=>{const r=g.toCamelCase(s.luge.reveal.root);t+=s.luge.reveal.delay,setTimeout((function(){e.revealCallback(s,r,"in"),s.luge.reveal.stagger?Array.from(s.children).forEach(((t,i)=>{const o=g.toCamelCase(t.dataset.lgReveal);setTimeout((()=>{(o||r)&&e.revealCallback(t,null!=o?o:r,"in"),e.setRevealClasses(t,"is-in");}),i*s.luge.reveal.stagger*1e3);})):e.setRevealClasses(s,"is-in");}),t),t+=1e3*m.settings.reveal.stagger,s.luge.reveal.multiple||e.removeElement(s);})),this.toRevealOut.forEach((t=>{const s=g.toCamelCase(t.luge.reveal.root);void 0!==t.luge.reveal.isRevealed&&e.revealCallback(t,s,"out");let r="";r=t.scrollProgress>.5?"is-out is-out-top":"is-out is-out-bottom",t.luge.reveal.stagger?Array.from(t.children).forEach(((i,o)=>{const n=g.toCamelCase(i.dataset.lgReveal);setTimeout((()=>{(n||s)&&e.revealCallback(i,null!=n?n:s,"out"),e.setRevealClasses(i,r);}),o*t.luge.reveal.stagger*1e3);})):e.setRevealClasses(t,r);})),this.toRevealIn=[],this.toRevealOut=[];}}setRevealClasses(e,t){t=t.split(" "),e.classList.remove("is-in","is-out","is-out-top","is-out-bottom"),t.forEach((t=>{e.classList.add(t);}));}revealCallback(e,t,s){e.dispatchEvent(new CustomEvent("reveal"+s)),e.luge.reveal.isRevealed="in"===s,"function"==typeof this.reveals[s][t]?this.reveals[s][t](e):"function"==typeof e["onreveal"+s]&&e["onreveal"+s]();}add(e,t,s){this.reveals[e]&&(t=g.toCamelCase(t),this.reveals[e][t]?console.log("Reveal animation named "+t+" already exists."):this.reveals[e][t]=s);}};new class extends Ms{constructor(){super("scroll"),this.isDisabled||(this.elements=[],this.allowedProperties=["opacity","background-x","background-y"],this.transformProperties=["x","y","z","translate3d","rotate","rotateX","rotateY","rotateZ","scale","scaleX","scaleY","scaleZ"],this.presets={"background-x":{"background-x":["0%","100%"]},"background-y":{"background-y":["0%","100%"]}},this.onScrollProgress=this.onScrollProgress.bind(this),e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),Zt.add(this.tick,this));}setAttributes(){this.pluginAttributes={root:String,yoyo:Boolean,inertia:[String,m.settings.scroll.inertia],animate:String};}getAttributes(e){const t=super.getAttributes(e);if(t.inertia){const e=t.inertia.match(/\{\s*([0-9]*[.]?[0-9]*)\s*,\s*([0-9]*[.]?[0-9]*)\s*\}/m);t.inertia=e?Number(e[1])+(Number(e[2])-Number(e[1]))*Math.random():Number(t.inertia),t.inertia=Math.max(Math.min(t.inertia,.99),0);}return t}pageInit(e){const t=document.querySelectorAll("[data-lg-scroll]"),s=this;t.forEach((e=>{s.addElement(e);})),e();}addElement(e){if(!this.elements.includes(e)){const t=this.getAttributes(e);es.add(e),e.addEventListener("scrollprogress",this.onScrollProgress);const s={};s.smoothProgress=void 0!==e.scrollProgress?e.scrollProgress:0,s.yoyo=t.yoyo,s.inertia=t.inertia;let r=!1;if(void 0!==t.animate?r=JSON.parse(t.animate.replace(/'/g,'"')):this.presets[t.root]&&(r=this.presets[t.root]),r){const e={};for(const t in r)if(this.allowedProperties.includes(t)||this.transformProperties.includes(t)){const s=r[t];let i=String(s[0]),o=String(s[1]),n=i.match(/\d+([a-zA-Z%]+)/m);n?n=n[1]:0===t.indexOf("rotate")&&(n="deg"),i=Number(i.replace(n,"")),o=Number(o.replace(n,""));let a=t;"background-x"===t?a="background-position-x":"background-y"===t&&(a="background-position-y"),e[a]={from:i,to:o,current:i,unit:n};}s.properties=e;}e.luge.scroll.animation=s,this.elements.push(e);}}removeElement(e){e.removeEventListener("scrollprogress",this.onScrollProgress),this.elements.includes(e)&&this.elements.splice(this.elements.indexOf(e),1);}pageKill(e){const t=this;this.elements.forEach((e=>{t.removeElement(e);})),e();}onScrollProgress(e){e.target.luge.scroll.animation.atDest=!1;}tick(){for(const e of this.elements){if(e.luge.scroll.animation.atDest)continue;let t=e.scrollProgress;if(e.luge.scroll.yoyo&&(t=1-Math.abs(1-2*t)),e.luge.scroll.animation.smoothProgress+=(t-e.luge.scroll.animation.smoothProgress)*(1-e.luge.scroll.inertia),e.luge.scroll.animation.properties){const t={};for(const[s,r]of Object.entries(e.luge.scroll.animation.properties))r.current=r.from+(r.to-r.from)*e.luge.scroll.animation.smoothProgress,["x","y","z"].includes(s)?(t.translate3d||(t.translate3d={}))&&(t.translate3d[s]=r.current+r.unit):t[s]=r.current+r.unit;const s=[];for(const[e,r]of Object.entries(t))if(this.transformProperties.includes(e)){if("object"==typeof r)if("translate3d"===e){const e=Object.assign({x:0,y:0,z:0},r);r.string=e.x+", "+e.y+", "+e.z;}else r.string=Object.values(r).join(", ");s.push(e+"("+("object"!=typeof r?r:r.string)+")");}const r={},i=[];s.length>0&&(r.transform=s.join(" "),i.push("transform"));for(const[e,s]of Object.entries(t))this.transformProperties.includes(e)||(r[e]=s,i.push(e));for(const[t,s]of Object.entries(r))e.style.setProperty(t,s);e.style.setProperty("will-change",i.join(", "));}else {const t=Math.round(1e3*(e.scrollProgress-e.luge.scroll.animation.smoothProgress))/1e3;e.style.setProperty("--progress",e.luge.scroll.animation.smoothProgress),e.style.setProperty("--abs-diff",Math.abs(t)),e.style.setProperty("--diff",t);}Math.abs(t-e.luge.scroll.animation.smoothProgress)<1e-4&&(e.luge.scroll.animation.atDest=!0);}}};new class extends Ms{constructor(){super("smooth"),this.isDisabled||(this.containers=null,window.hasSmoothScroll=!1,window.smoothScrollTop=0,window.smoothScrollProgress=0,e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),this.bindEvents());}setAttributes(){this.pluginAttributes={};}bindEvents(){p.on("resize",this.resizeHandler,this);}pageInit(e){const t=document.querySelectorAll("[data-lg-smooth]");t.length>0?(window.smoothScrollTop=window.scrollTop,window.unifiedScrollTop=window.smoothScrollTop,window.hasSmoothScroll=!0,document.documentElement.classList.add("has-smooth-scroll"),this.containers=Array.from(t).map((e=>({el:e,bounding:e.getBoundingClientRect()}))),Zt.add(this.tick,this)):(window.smoothScrollTop=0,window.unifiedScrollTop=window.scrollTop,window.hasSmoothScroll=!1,document.documentElement.classList.remove("has-smooth-scroll"),this.containers=null,Zt.remove(this.tick,this)),this.resizeHandler(),e();}pageKill(e){this.containers=null,e();}resizeHandler(){this.containers&&(this.containers.forEach((function(e){e.el.removeAttribute("style");})),this.containers.forEach((function(e){const t=e.el.parentNode;e.bounding=e.el.getBoundingClientRect(),t.style.height=e.bounding.bottom+window.scrollTop+"px",e.el.style.position="fixed",e.el.style.transform="translate3d(0, -"+window.smoothScrollTop+"px, 0)",e.el.style.left=0,e.el.style.width="100%",e.el.style.willChange="transform";})));}tick(){if(window.smoothScrollTop!==window.scrollTop){window.smoothScrollTop=Math.max(window.smoothScrollTop+(window.scrollTop-window.smoothScrollTop)*m.settings.smooth.inertia,0);const e=window.smoothScrollTop-window.scrollTop;e>-.1&&e<.1&&(window.smoothScrollTop=window.scrollTop),this.containers&&this.containers.forEach((function(e){e.el.style.transform="translate3d(0, -"+window.smoothScrollTop+"px, 0)";})),window.hasSmoothScroll&&(window.unifiedScrollTop=window.smoothScrollTop,window.smoothScrollProgress=window.smoothScrollTop/window.maxScrollTop,p.emit("scroll"));}}};new class extends Ms{constructor(){super("sticky"),this.isDisabled||(this.elements=[],e.add("pageInit",this.pageInit.bind(this)),e.add("pageKill",this.pageKill.bind(this)),this.bindEvents());}setAttributes(){this.pluginAttributes={root:String};}bindEvents(){p.on("resize",this.resizeHandler,this),p.on("scroll",this.scrollHandler,this);}pageInit(e){const t=document.querySelectorAll("[data-lg-sticky]");t.length>0&&t.forEach((e=>{const t=this.getAttributes(e);this.elements.push({el:e,position:t.root});})),this.resizeHandler(),e();}pageKill(e){this.elements=[],e();}resizeHandler(){this.setBounding(),this.checkElements();}setBounding(){if(this.elements){const e=window.unifiedScrollTop;this.elements.forEach((function(t){t.el.style.top="",t.el.style.transform="";const s=t.el.getBoundingClientRect();if("bottom"===t.position){let r=Math.ceil(window.innerHeight-(s.bottom+e))+1;r=Math.max(r,0),t.el.style.top=r+"px",t.start=s.bottom+r+e-window.innerHeight,t.maxGap=t.el.parentNode.offsetHeight-t.el.offsetHeight-r;}else "top"===t.position?(t.start=s.top+e,t.maxGap=t.el.parentNode.offsetHeight-t.el.offsetHeight):(t.start=s.top+e-(window.innerHeight-t.el.offsetHeight)/2,t.maxGap=t.el.parentNode.offsetHeight-t.el.offsetHeight);}));}}scrollHandler(){this.checkElements();}checkElements(){if(this.elements){const e=window.unifiedScrollTop;this.elements.forEach((function(t){if(e>=t.start){const s=Math.min(e-t.start,t.maxGap);t.el.style.transform="translate3d(0, "+s+"px, 0)",s===t.maxGap?t.el.setAttribute("data-lg-sticky-state","is-fixed is-fixed--bottom"):t.el.setAttribute("data-lg-sticky-state","is-moving");}else e<t.start&&(t.el.style.transform="translate3d(0, 0, 0)",t.el.setAttribute("data-lg-sticky-state","is-fixed is-fixed--top"));}));}}};const Os={cursor:{},emitter:{emit:p.emit.bind(p),off:p.off.bind(p),on:p.on.bind(p),once:p.once.bind(p)},lifecycle:{add:e.add.bind(e),refresh:e.cycle.bind(e,"refresh"),debug:e.enableDebug.bind(e)},mouseobserver:{add:Jt.add.bind(Jt),remove:Jt.remove.bind(Jt)},preloader:{add:Ts.add.bind(Ts)},reveal:{add:ks.add.bind(ks)},scrollobserver:{add:es.add.bind(es),remove:es.remove.bind(es)},ticker:{add:Zt.add.bind(Zt),nextTick:Zt.nextTick.bind(Zt),remove:Zt.remove.bind(Zt),tick:Zt.tick.bind(Zt)},transition:{add:Ps.add.bind(Ps)},settings:m.setSettings.bind(m)};window.luge=Os,"loading"===document.readyState?document.addEventListener("DOMContentLoaded",e.cycle.bind(e,"load"),{once:!0}):Zt.nextTick((()=>{e.cycle("load");}),null);const Ls="background-color: #00FFE5; color: black; font: 400 1em monospace; padding: 0.5em 0; ";console.log("%c powered by %cluge%c / 0.6.1-beta %c > https://luge.cool ",Ls,"background-color: #00FFE5; color: black; font: 400 1em monospace; padding: 0.5em 0; font-weight: bold; ",Ls,"color: black; font: 400 1em monospace; padding: 0.5em 0; ");

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var lottie$1 = createCommonjsModule(function (module) {
    (typeof navigator !== "undefined") && (function(root, factory) {
        if (module.exports) {
            module.exports = factory(root);
        } else {
            root.lottie = factory(root);
            root.bodymovin = root.lottie;
        }
    }((window || {}), function(window) {

    /* exported svgNS, locationHref, initialDefaultFrame, _useWebWorker */

    var svgNS = 'http://www.w3.org/2000/svg';

    var locationHref = '';

    var initialDefaultFrame = -999999;

    var _useWebWorker = false;

    /* global createSizedArray */
    /* exported subframeEnabled, expressionsPlugin, isSafari, cachedColors, bmPow, bmSqrt, bmFloor, bmMax, bmMin, ProjectInterface,
    defaultCurveSegments, degToRads, roundCorner, bmRnd, styleDiv, BMEnterFrameEvent, BMCompleteEvent, BMCompleteLoopEvent,
    BMSegmentStartEvent, BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, BMAnimationConfigErrorEvent, createElementID,
    addSaturationToRGB, addBrightnessToRGB, addHueToRGB, rgbToHex */

    var subframeEnabled = true;
    var idPrefix = '';
    var expressionsPlugin;
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    var bmPow = Math.pow;
    var bmSqrt = Math.sqrt;
    var bmFloor = Math.floor;
    var bmMax = Math.max;
    var bmMin = Math.min;

    var BMMath = {};
    (function () {
      var propertyNames = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'atan2', 'ceil', 'cbrt', 'expm1', 'clz32', 'cos', 'cosh', 'exp', 'floor', 'fround', 'hypot', 'imul', 'log', 'log1p', 'log2', 'log10', 'max', 'min', 'pow', 'random', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc', 'E', 'LN10', 'LN2', 'LOG10E', 'LOG2E', 'PI', 'SQRT1_2', 'SQRT2'];
      var i;
      var len = propertyNames.length;
      for (i = 0; i < len; i += 1) {
        BMMath[propertyNames[i]] = Math[propertyNames[i]];
      }
    }());

    function ProjectInterface() { return {}; }

    BMMath.random = Math.random;
    BMMath.abs = function (val) {
      var tOfVal = typeof val;
      if (tOfVal === 'object' && val.length) {
        var absArr = createSizedArray(val.length);
        var i;
        var len = val.length;
        for (i = 0; i < len; i += 1) {
          absArr[i] = Math.abs(val[i]);
        }
        return absArr;
      }
      return Math.abs(val);
    };
    var defaultCurveSegments = 150;
    var degToRads = Math.PI / 180;
    var roundCorner = 0.5519;

    function styleDiv(element) {
      element.style.position = 'absolute';
      element.style.top = 0;
      element.style.left = 0;
      element.style.display = 'block';
      element.style.transformOrigin = '0 0';
      element.style.webkitTransformOrigin = '0 0';
      element.style.backfaceVisibility = 'visible';
      element.style.webkitBackfaceVisibility = 'visible';
      element.style.transformStyle = 'preserve-3d';
      element.style.webkitTransformStyle = 'preserve-3d';
      element.style.mozTransformStyle = 'preserve-3d';
    }

    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
      this.type = type;
      this.currentTime = currentTime;
      this.totalTime = totalTime;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMCompleteEvent(type, frameMultiplier) {
      this.type = type;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
      this.type = type;
      this.currentLoop = currentLoop;
      this.totalLoops = totalLoops;
      this.direction = frameMultiplier < 0 ? -1 : 1;
    }

    function BMSegmentStartEvent(type, firstFrame, totalFrames) {
      this.type = type;
      this.firstFrame = firstFrame;
      this.totalFrames = totalFrames;
    }

    function BMDestroyEvent(type, target) {
      this.type = type;
      this.target = target;
    }

    function BMRenderFrameErrorEvent(nativeError, currentTime) {
      this.type = 'renderFrameError';
      this.nativeError = nativeError;
      this.currentTime = currentTime;
    }

    function BMConfigErrorEvent(nativeError) {
      this.type = 'configError';
      this.nativeError = nativeError;
    }

    var createElementID = (function () {
      var _count = 0;
      return function createID() {
        _count += 1;
        return idPrefix + '__lottie_element_' + _count;
      };
    }());

    function HSVtoRGB(h, s, v) {
      var r;
      var g;
      var b;
      var i;
      var f;
      var p;
      var q;
      var t;
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0: r = v; g = t; b = p; break;
        case 1: r = q; g = v; b = p; break;
        case 2: r = p; g = v; b = t; break;
        case 3: r = p; g = q; b = v; break;
        case 4: r = t; g = p; b = v; break;
        case 5: r = v; g = p; b = q; break;
      }
      return [r,
        g,
        b];
    }

    function RGBtoHSV(r, g, b) {
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var d = max - min;
      var h;
      var s = (max === 0 ? 0 : d / max);
      var v = max / 255;

      switch (max) {
        case min: h = 0; break;
        case r: h = (g - b) + d * (g < b ? 6 : 0); h /= 6 * d; break;
        case g: h = (b - r) + d * 2; h /= 6 * d; break;
        case b: h = (r - g) + d * 4; h /= 6 * d; break;
      }

      return [
        h,
        s,
        v,
      ];
    }

    function addSaturationToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[1] += offset;
      if (hsv[1] > 1) {
        hsv[1] = 1;
      } else if (hsv[1] <= 0) {
        hsv[1] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }

    function addBrightnessToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[2] += offset;
      if (hsv[2] > 1) {
        hsv[2] = 1;
      } else if (hsv[2] < 0) {
        hsv[2] = 0;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }

    function addHueToRGB(color, offset) {
      var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
      hsv[0] += offset / 360;
      if (hsv[0] > 1) {
        hsv[0] -= 1;
      } else if (hsv[0] < 0) {
        hsv[0] += 1;
      }
      return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
    }

    var rgbToHex = (function () {
      var colorMap = [];
      var i;
      var hex;
      for (i = 0; i < 256; i += 1) {
        hex = i.toString(16);
        colorMap[i] = hex.length === 1 ? '0' + hex : hex;
      }

      return function (r, g, b) {
        if (r < 0) {
          r = 0;
        }
        if (g < 0) {
          g = 0;
        }
        if (b < 0) {
          b = 0;
        }
        return '#' + colorMap[r] + colorMap[g] + colorMap[b];
      };
    }());

    function BaseEvent() {}
    BaseEvent.prototype = {
      triggerEvent: function (eventName, args) {
        if (this._cbs[eventName]) {
          var callbacks = this._cbs[eventName];
          for (var i = 0; i < callbacks.length; i += 1) {
            callbacks[i](args);
          }
        }
      },
      addEventListener: function (eventName, callback) {
        if (!this._cbs[eventName]) {
          this._cbs[eventName] = [];
        }
        this._cbs[eventName].push(callback);

        return function () {
          this.removeEventListener(eventName, callback);
        }.bind(this);
      },
      removeEventListener: function (eventName, callback) {
        if (!callback) {
          this._cbs[eventName] = null;
        } else if (this._cbs[eventName]) {
          var i = 0;
          var len = this._cbs[eventName].length;
          while (i < len) {
            if (this._cbs[eventName][i] === callback) {
              this._cbs[eventName].splice(i, 1);
              i -= 1;
              len -= 1;
            }
            i += 1;
          }
          if (!this._cbs[eventName].length) {
            this._cbs[eventName] = null;
          }
        }
      },
    };

    /* exported createTypedArray, createSizedArray */

    var createTypedArray = (function () {
      function createRegularArray(type, len) {
        var i = 0;
        var arr = [];
        var value;
        switch (type) {
          case 'int16':
          case 'uint8c':
            value = 1;
            break;
          default:
            value = 1.1;
            break;
        }
        for (i = 0; i < len; i += 1) {
          arr.push(value);
        }
        return arr;
      }
      function createTypedArrayFactory(type, len) {
        if (type === 'float32') {
          return new Float32Array(len);
        } if (type === 'int16') {
          return new Int16Array(len);
        } if (type === 'uint8c') {
          return new Uint8ClampedArray(len);
        }
        return createRegularArray(type, len);
      }
      if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {
        return createTypedArrayFactory;
      }
      return createRegularArray;
    }());

    function createSizedArray(len) {
      return Array.apply(null, { length: len });
    }

    /* global svgNS */
    /* exported createNS */

    function createNS(type) {
      // return {appendChild:function(){},setAttribute:function(){},style:{}}
      return document.createElementNS(svgNS, type);
    }

    /* exported createTag */

    function createTag(type) {
      // return {appendChild:function(){},setAttribute:function(){},style:{}}
      return document.createElement(type);
    }

    function DynamicPropertyContainer() {}
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function (prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
          this.container.addDynamicProperty(this);
          this._isAnimated = true;
        }
      },
      iterateDynamicProperties: function () {
        this._mdf = false;
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          this.dynamicProperties[i].getValue();
          if (this.dynamicProperties[i]._mdf) {
            this._mdf = true;
          }
        }
      },
      initDynamicPropertyContainer: function (container) {
        this.container = container;
        this.dynamicProperties = [];
        this._mdf = false;
        this._isAnimated = false;
      },
    };

    /* exported getBlendMode */

    var getBlendMode = (function () {
      var blendModeEnums = {
        0: 'source-over',
        1: 'multiply',
        2: 'screen',
        3: 'overlay',
        4: 'darken',
        5: 'lighten',
        6: 'color-dodge',
        7: 'color-burn',
        8: 'hard-light',
        9: 'soft-light',
        10: 'difference',
        11: 'exclusion',
        12: 'hue',
        13: 'saturation',
        14: 'color',
        15: 'luminosity',
      };

      return function (mode) {
        return blendModeEnums[mode] || '';
      };
    }());

    /* exported lineCapEnum, lineJoinEnum */

    var lineCapEnum = {
      1: 'butt',
      2: 'round',
      3: 'square',
    };

    var lineJoinEnum = {
      1: 'miter',
      2: 'round',
      3: 'bevel',
    };

    /* global createTypedArray */

    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */

    /**
     * 2D transformation matrix object initialized with identity matrix.
     *
     * The matrix can synchronize a canvas context by supplying the context
     * as an argument, or later apply current absolute transform to an
     * existing context.
     *
     * All values are handled as floating point values.
     *
     * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
     * @prop {number} a - scale x
     * @prop {number} b - shear y
     * @prop {number} c - shear x
     * @prop {number} d - scale y
     * @prop {number} e - translate x
     * @prop {number} f - translate y
     * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
     * @constructor
     */

    var Matrix = (function () {
      var _cos = Math.cos;
      var _sin = Math.sin;
      var _tan = Math.tan;
      var _rnd = Math.round;

      function reset() {
        this.props[0] = 1;
        this.props[1] = 0;
        this.props[2] = 0;
        this.props[3] = 0;
        this.props[4] = 0;
        this.props[5] = 1;
        this.props[6] = 0;
        this.props[7] = 0;
        this.props[8] = 0;
        this.props[9] = 0;
        this.props[10] = 1;
        this.props[11] = 0;
        this.props[12] = 0;
        this.props[13] = 0;
        this.props[14] = 0;
        this.props[15] = 1;
        return this;
      }

      function rotate(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }

      function rotateX(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
      }

      function rotateY(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
      }

      function rotateZ(angle) {
        if (angle === 0) {
          return this;
        }
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }

      function shear(sx, sy) {
        return this._t(1, sy, sx, 1, 0, 0);
      }

      function skew(ax, ay) {
        return this.shear(_tan(ax), _tan(ay));
      }

      function skewFromAxis(ax, angle) {
        var mCos = _cos(angle);
        var mSin = _sin(angle);
        return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
          ._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
          ._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
      }

      function scale(sx, sy, sz) {
        if (!sz && sz !== 0) {
          sz = 1;
        }
        if (sx === 1 && sy === 1 && sz === 1) {
          return this;
        }
        return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
      }

      function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
        this.props[0] = a;
        this.props[1] = b;
        this.props[2] = c;
        this.props[3] = d;
        this.props[4] = e;
        this.props[5] = f;
        this.props[6] = g;
        this.props[7] = h;
        this.props[8] = i;
        this.props[9] = j;
        this.props[10] = k;
        this.props[11] = l;
        this.props[12] = m;
        this.props[13] = n;
        this.props[14] = o;
        this.props[15] = p;
        return this;
      }

      function translate(tx, ty, tz) {
        tz = tz || 0;
        if (tx !== 0 || ty !== 0 || tz !== 0) {
          return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
        }
        return this;
      }

      function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {
        var _p = this.props;

        if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {
          // NOTE: commenting this condition because TurboFan deoptimizes code when present
          // if(m2 !== 0 || n2 !== 0 || o2 !== 0){
          _p[12] = _p[12] * a2 + _p[15] * m2;
          _p[13] = _p[13] * f2 + _p[15] * n2;
          _p[14] = _p[14] * k2 + _p[15] * o2;
          _p[15] *= p2;
          // }
          this._identityCalculated = false;
          return this;
        }

        var a1 = _p[0];
        var b1 = _p[1];
        var c1 = _p[2];
        var d1 = _p[3];
        var e1 = _p[4];
        var f1 = _p[5];
        var g1 = _p[6];
        var h1 = _p[7];
        var i1 = _p[8];
        var j1 = _p[9];
        var k1 = _p[10];
        var l1 = _p[11];
        var m1 = _p[12];
        var n1 = _p[13];
        var o1 = _p[14];
        var p1 = _p[15];

        /* matrix order (canvas compatible):
             * ace
             * bdf
             * 001
             */
        _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;
        _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;
        _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;
        _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;

        _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;
        _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;
        _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;
        _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;

        _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;
        _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;
        _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;
        _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;

        _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;
        _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;
        _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;
        _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;

        this._identityCalculated = false;
        return this;
      }

      function isIdentity() {
        if (!this._identityCalculated) {
          this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
          this._identityCalculated = true;
        }
        return this._identity;
      }

      function equals(matr) {
        var i = 0;
        while (i < 16) {
          if (matr.props[i] !== this.props[i]) {
            return false;
          }
          i += 1;
        }
        return true;
      }

      function clone(matr) {
        var i;
        for (i = 0; i < 16; i += 1) {
          matr.props[i] = this.props[i];
        }
        return matr;
      }

      function cloneFromProps(props) {
        var i;
        for (i = 0; i < 16; i += 1) {
          this.props[i] = props[i];
        }
      }

      function applyToPoint(x, y, z) {
        return {
          x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
          y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
          z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
        };
        /* return {
             x: x * me.a + y * me.c + me.e,
             y: x * me.b + y * me.d + me.f
             }; */
      }
      function applyToX(x, y, z) {
        return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];
      }
      function applyToY(x, y, z) {
        return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];
      }
      function applyToZ(x, y, z) {
        return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];
      }

      function getInverseMatrix() {
        var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
        var a = this.props[5] / determinant;
        var b = -this.props[1] / determinant;
        var c = -this.props[4] / determinant;
        var d = this.props[0] / determinant;
        var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
        var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
        var inverseMatrix = new Matrix();
        inverseMatrix.props[0] = a;
        inverseMatrix.props[1] = b;
        inverseMatrix.props[4] = c;
        inverseMatrix.props[5] = d;
        inverseMatrix.props[12] = e;
        inverseMatrix.props[13] = f;
        return inverseMatrix;
      }

      function inversePoint(pt) {
        var inverseMatrix = this.getInverseMatrix();
        return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);
      }

      function inversePoints(pts) {
        var i;
        var len = pts.length;
        var retPts = [];
        for (i = 0; i < len; i += 1) {
          retPts[i] = inversePoint(pts[i]);
        }
        return retPts;
      }

      function applyToTriplePoints(pt1, pt2, pt3) {
        var arr = createTypedArray('float32', 6);
        if (this.isIdentity()) {
          arr[0] = pt1[0];
          arr[1] = pt1[1];
          arr[2] = pt2[0];
          arr[3] = pt2[1];
          arr[4] = pt3[0];
          arr[5] = pt3[1];
        } else {
          var p0 = this.props[0];
          var p1 = this.props[1];
          var p4 = this.props[4];
          var p5 = this.props[5];
          var p12 = this.props[12];
          var p13 = this.props[13];
          arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
          arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
          arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
          arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
          arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
          arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
        }
        return arr;
      }

      function applyToPointArray(x, y, z) {
        var arr;
        if (this.isIdentity()) {
          arr = [x, y, z];
        } else {
          arr = [
            x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],
            x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],
            x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14],
          ];
        }
        return arr;
      }

      function applyToPointStringified(x, y) {
        if (this.isIdentity()) {
          return x + ',' + y;
        }
        var _p = this.props;
        return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;
      }

      function toCSS() {
        // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
        /* if(this.isIdentity()) {
                return '';
            } */
        var i = 0;
        var props = this.props;
        var cssValue = 'matrix3d(';
        var v = 10000;
        while (i < 16) {
          cssValue += _rnd(props[i] * v) / v;
          cssValue += i === 15 ? ')' : ',';
          i += 1;
        }
        return cssValue;
      }

      function roundMatrixProperty(val) {
        var v = 10000;
        if ((val < 0.000001 && val > 0) || (val > -0.000001 && val < 0)) {
          return _rnd(val * v) / v;
        }
        return val;
      }

      function to2dCSS() {
        // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
        /* if(this.isIdentity()) {
                return '';
            } */
        var props = this.props;
        var _a = roundMatrixProperty(props[0]);
        var _b = roundMatrixProperty(props[1]);
        var _c = roundMatrixProperty(props[4]);
        var _d = roundMatrixProperty(props[5]);
        var _e = roundMatrixProperty(props[12]);
        var _f = roundMatrixProperty(props[13]);
        return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';
      }

      return function () {
        this.reset = reset;
        this.rotate = rotate;
        this.rotateX = rotateX;
        this.rotateY = rotateY;
        this.rotateZ = rotateZ;
        this.skew = skew;
        this.skewFromAxis = skewFromAxis;
        this.shear = shear;
        this.scale = scale;
        this.setTransform = setTransform;
        this.translate = translate;
        this.transform = transform;
        this.applyToPoint = applyToPoint;
        this.applyToX = applyToX;
        this.applyToY = applyToY;
        this.applyToZ = applyToZ;
        this.applyToPointArray = applyToPointArray;
        this.applyToTriplePoints = applyToTriplePoints;
        this.applyToPointStringified = applyToPointStringified;
        this.toCSS = toCSS;
        this.to2dCSS = to2dCSS;
        this.clone = clone;
        this.cloneFromProps = cloneFromProps;
        this.equals = equals;
        this.inversePoints = inversePoints;
        this.inversePoint = inversePoint;
        this.getInverseMatrix = getInverseMatrix;
        this._t = this.transform;
        this.isIdentity = isIdentity;
        this._identity = true;
        this._identityCalculated = false;

        this.props = createTypedArray('float32', 16);
        this.reset();
      };
    }());

    /* eslint-disable */
    /*
     Copyright 2014 David Bau.

     Permission is hereby granted, free of charge, to any person obtaining
     a copy of this software and associated documentation files (the
     "Software"), to deal in the Software without restriction, including
     without limitation the rights to use, copy, modify, merge, publish,
     distribute, sublicense, and/or sell copies of the Software, and to
     permit persons to whom the Software is furnished to do so, subject to
     the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
     IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
     CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
     TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
     SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

     */

    (function (pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //
        var global = this,
            width = 256,        // each RC4 output is 0 <= x < 256
            chunks = 6,         // at least six RC4 outputs for each double
            digits = 52,        // there are 52 significant digits in a double
            rngname = 'random', // rngname: name for Math.random and Math.seedrandom
            startdenom = math.pow(width, chunks),
            significance = math.pow(2, digits),
            overflow = significance * 2,
            mask = width - 1,
            nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
        function seedrandom(seed, options, callback) {
            var key = [];
            options = (options === true) ? { entropy: true } : (options || {});

            // Flatten the seed string or build one from local entropy if needed.
            var shortseed = mixkey(flatten(
                options.entropy ? [seed, tostring(pool)] :
                    (seed === null) ? autoseed() : seed, 3), key);

            // Use the seed to initialize an ARC4 generator.
            var arc4 = new ARC4(key);

            // This function returns a random double in [0, 1) that contains
            // randomness in every bit of the mantissa of the IEEE 754 value.
            var prng = function() {
                var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
                    d = startdenom,                 //   and denominator d = 2 ^ 48.
                    x = 0;                          //   and no 'extra last byte'.
                while (n < significance) {          // Fill up all significant digits by
                    n = (n + x) * width;              //   shifting numerator and
                    d *= width;                       //   denominator and generating a
                    x = arc4.g(1);                    //   new least-significant-byte.
                }
                while (n >= overflow) {             // To avoid rounding up, before adding
                    n /= 2;                           //   last byte, shift everything
                    d /= 2;                           //   right using integer math until
                    x >>>= 1;                         //   we have exactly the desired bits.
                }
                return (n + x) / d;                 // Form the number within [0, 1).
            };

            prng.int32 = function() { return arc4.g(4) | 0; };
            prng.quick = function() { return arc4.g(4) / 0x100000000; };
            prng.double = prng;

            // Mix the randomness into accumulated entropy.
            mixkey(tostring(arc4.S), pool);

            // Calling convention: what to return as a function of prng, seed, is_math.
            return (options.pass || callback ||
            function(prng, seed, is_math_call, state) {
                if (state) {
                    // Load the arc4 state from the given state if it has an S array.
                    if (state.S) { copy(state, arc4); }
                    // Only provide the .state method if requested via options.state.
                    prng.state = function() { return copy(arc4, {}); };
                }

                // If called as a method of Math (Math.seedrandom()), mutate
                // Math.random because that is how seedrandom.js has worked since v1.0.
                if (is_math_call) { math[rngname] = prng; return seed; }

                // Otherwise, it is a newer calling convention, so return the
                // prng directly.
                else return prng;
            })(
                prng,
                shortseed,
                'global' in options ? options.global : (this == math),
                options.state);
        }
        math['seed' + rngname] = seedrandom;

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
        function ARC4(key) {
            var t, keylen = key.length,
                me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

            // The empty key [] is treated as [0].
            if (!keylen) { key = [keylen++]; }

            // Set up S using the standard key scheduling algorithm.
            while (i < width) {
                s[i] = i++;
            }
            for (i = 0; i < width; i++) {
                s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
                s[j] = t;
            }

            // The "g" method returns the next (count) outputs as one number.
            me.g = function(count) {
                // Using instance members instead of closure state nearly doubles speed.
                var t, r = 0,
                    i = me.i, j = me.j, s = me.S;
                while (count--) {
                    t = s[i = mask & (i + 1)];
                    r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
                }
                me.i = i; me.j = j;
                return r;
                // For robust unpredictability, the function call below automatically
                // discards an initial batch of values.  This is called RC4-drop[256].
                // See http://google.com/search?q=rsa+fluhrer+response&btnI
            };
        }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
        function copy(f, t) {
            t.i = f.i;
            t.j = f.j;
            t.S = f.S.slice();
            return t;
        }

    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
        function flatten(obj, depth) {
            var result = [], typ = (typeof obj), prop;
            if (depth && typ == 'object') {
                for (prop in obj) {
                    try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
                }
            }
            return (result.length ? result : typ == 'string' ? obj : obj + '\0');
        }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
        function mixkey(seed, key) {
            var stringseed = seed + '', smear, j = 0;
            while (j < stringseed.length) {
                key[mask & j] =
                    mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
            }
            return tostring(key);
        }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
        function autoseed() {
            try {
                if (nodecrypto) ;
                var out = new Uint8Array(width);
                (global.crypto || global.msCrypto).getRandomValues(out);
                return tostring(out);
            } catch (e) {
                var browser = global.navigator,
                    plugins = browser && browser.plugins;
                return [+new Date(), global, plugins, global.screen, tostring(pool)];
            }
        }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
        function tostring(a) {
            return String.fromCharCode.apply(0, a);
        }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
        mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //

    // End anonymous scope, and pass initial values.
    })(
        [],     // pool: entropy pool starts empty
        BMMath    // math: package containing random, pow, and seedrandom
    );
    /* eslint-disable */
    var BezierFactory = (function () {
      /**
         * BezierEasing - use bezier curve for transition easing function
         * by Gatan Renaudeau 2014 - 2015  MIT License
         *
         * Credits: is based on Firefox's nsSMILKeySpline.cpp
         * Usage:
         * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
         * spline.get(x) => returns the easing value | x must be in [0, 1] range
         *
         */

      var ob = {};
      ob.getBezierEasing = getBezierEasing;
      var beziers = {};

      function getBezierEasing(a, b, c, d, nm) {
        var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\./g, 'p');
        if (beziers[str]) {
          return beziers[str];
        }
        var bezEasing = new BezierEasing([a, b, c, d]);
        beziers[str] = bezEasing;
        return bezEasing;
      }

      // These values are established by empiricism with tests (tradeoff: performance VS precision)
      var NEWTON_ITERATIONS = 4;
      var NEWTON_MIN_SLOPE = 0.001;
      var SUBDIVISION_PRECISION = 0.0000001;
      var SUBDIVISION_MAX_ITERATIONS = 10;

      var kSplineTableSize = 11;
      var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

      var float32ArraySupported = typeof Float32Array === 'function';

      function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
      function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
      function C(aA1) { return 3.0 * aA1; }

      // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
      function calcBezier(aT, aA1, aA2) {
        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
      }

      // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
      function getSlope(aT, aA1, aA2) {
        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
      }

      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX,
          currentT,
          i = 0;
        do {
          currentT = aA + (aB - aA) / 2.0;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0.0) {
            aB = currentT;
          } else {
            aA = currentT;
          }
        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
        return currentT;
      }

      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0.0) return aGuessT;
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }

      /**
         * points is an array of [ mX1, mY1, mX2, mY2 ]
         */
      function BezierEasing(points) {
        this._p = points;
        this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
        this._precomputed = false;

        this.get = this.get.bind(this);
      }

      BezierEasing.prototype = {

        get: function (x) {
          var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
          if (!this._precomputed) this._precompute();
          if (mX1 === mY1 && mX2 === mY2) return x; // linear
          // Because JavaScript number are imprecise, we should guarantee the extremes are right.
          if (x === 0) return 0;
          if (x === 1) return 1;
          return calcBezier(this._getTForX(x), mY1, mY2);
        },

        // Private part

        _precompute: function () {
          var mX1 = this._p[0],
            mY1 = this._p[1],
            mX2 = this._p[2],
            mY2 = this._p[3];
          this._precomputed = true;
          if (mX1 !== mY1 || mX2 !== mY2) { this._calcSampleValues(); }
        },

        _calcSampleValues: function () {
          var mX1 = this._p[0],
            mX2 = this._p[2];
          for (var i = 0; i < kSplineTableSize; ++i) {
            this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
          }
        },

        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function (aX) {
          var mX1 = this._p[0],
            mX2 = this._p[2],
            mSampleValues = this._mSampleValues;

          var intervalStart = 0.0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }
          --currentSample;

          // Interpolate to provide an initial guess for t
          var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;

          var initialSlope = getSlope(guessForT, mX1, mX2);
          if (initialSlope >= NEWTON_MIN_SLOPE) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } if (initialSlope === 0.0) {
            return guessForT;
          }
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        },
      };

      return ob;
    }());

    (function () {
      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) { // eslint-disable-line no-plusplus
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
      }
      if (!window.requestAnimationFrame) {
        window.requestAnimationFrame = function (callback) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = setTimeout(function () {
            callback(currTime + timeToCall);
          },
          timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }
      if (!window.cancelAnimationFrame) {
        window.cancelAnimationFrame = function (id) {
          clearTimeout(id);
        };
      }
    }());

    /* exported extendPrototype, getDescriptor, createProxyFunction */

    function extendPrototype(sources, destination) {
      var i;
      var len = sources.length;
      var sourcePrototype;
      for (i = 0; i < len; i += 1) {
        sourcePrototype = sources[i].prototype;
        for (var attr in sourcePrototype) {
          if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
        }
      }
    }

    function getDescriptor(object, prop) {
      return Object.getOwnPropertyDescriptor(object, prop);
    }

    function createProxyFunction(prototype) {
      function ProxyFunction() {}
      ProxyFunction.prototype = prototype;
      return ProxyFunction;
    }

    /* global segmentsLengthPool, defaultCurveSegments, createSizedArray, bmPow, bmSqrt, bmFloor, createTypedArray, bezierLengthPool */
    /* exported bez */

    function bezFunction() {
      var math = Math;

      function pointOnLine2D(x1, y1, x2, y2, x3, y3) {
        var det1 = (x1 * y2) + (y1 * x3) + (x2 * y3) - (x3 * y2) - (y3 * x1) - (x2 * y1);
        return det1 > -0.001 && det1 < 0.001;
      }

      function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {
        if (z1 === 0 && z2 === 0 && z3 === 0) {
          return pointOnLine2D(x1, y1, x2, y2, x3, y3);
        }
        var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));
        var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
        var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));
        var diffDist;
        if (dist1 > dist2) {
          if (dist1 > dist3) {
            diffDist = dist1 - dist2 - dist3;
          } else {
            diffDist = dist3 - dist2 - dist1;
          }
        } else if (dist3 > dist2) {
          diffDist = dist3 - dist2 - dist1;
        } else {
          diffDist = dist2 - dist1 - dist3;
        }
        return diffDist > -0.0001 && diffDist < 0.0001;
      }

      var getBezierLength = (function () {
        return function (pt1, pt2, pt3, pt4) {
          var curveSegments = defaultCurveSegments;
          var k;
          var i;
          var len;
          var ptCoord;
          var perc;
          var addedLength = 0;
          var ptDistance;
          var point = [];
          var lastPoint = [];
          var lengthData = bezierLengthPool.newElement();
          len = pt3.length;
          for (k = 0; k < curveSegments; k += 1) {
            perc = k / (curveSegments - 1);
            ptDistance = 0;
            for (i = 0; i < len; i += 1) {
              ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];
              point[i] = ptCoord;
              if (lastPoint[i] !== null) {
                ptDistance += bmPow(point[i] - lastPoint[i], 2);
              }
              lastPoint[i] = point[i];
            }
            if (ptDistance) {
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
            }
            lengthData.percents[k] = perc;
            lengthData.lengths[k] = addedLength;
          }
          lengthData.addedLength = addedLength;
          return lengthData;
        };
      }());

      function getSegmentsLength(shapeData) {
        var segmentsLength = segmentsLengthPool.newElement();
        var closed = shapeData.c;
        var pathV = shapeData.v;
        var pathO = shapeData.o;
        var pathI = shapeData.i;
        var i;
        var len = shapeData._length;
        var lengths = segmentsLength.lengths;
        var totalLength = 0;
        for (i = 0; i < len - 1; i += 1) {
          lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);
          totalLength += lengths[i].addedLength;
        }
        if (closed && len) {
          lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);
          totalLength += lengths[i].addedLength;
        }
        segmentsLength.totalLength = totalLength;
        return segmentsLength;
      }

      function BezierData(length) {
        this.segmentLength = 0;
        this.points = new Array(length);
      }

      function PointData(partial, point) {
        this.partialLength = partial;
        this.point = point;
      }

      var buildBezierData = (function () {
        var storedData = {};

        return function (pt1, pt2, pt3, pt4) {
          var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\./g, 'p');
          if (!storedData[bezierName]) {
            var curveSegments = defaultCurveSegments;
            var k;
            var i;
            var len;
            var ptCoord;
            var perc;
            var addedLength = 0;
            var ptDistance;
            var point;
            var lastPoint = null;
            if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
              curveSegments = 2;
            }
            var bezierData = new BezierData(curveSegments);
            len = pt3.length;
            for (k = 0; k < curveSegments; k += 1) {
              point = createSizedArray(len);
              perc = k / (curveSegments - 1);
              ptDistance = 0;
              for (i = 0; i < len; i += 1) {
                ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];
                point[i] = ptCoord;
                if (lastPoint !== null) {
                  ptDistance += bmPow(point[i] - lastPoint[i], 2);
                }
              }
              ptDistance = bmSqrt(ptDistance);
              addedLength += ptDistance;
              bezierData.points[k] = new PointData(ptDistance, point);
              lastPoint = point;
            }
            bezierData.segmentLength = addedLength;
            storedData[bezierName] = bezierData;
          }
          return storedData[bezierName];
        };
      }());

      function getDistancePerc(perc, bezierData) {
        var percents = bezierData.percents;
        var lengths = bezierData.lengths;
        var len = percents.length;
        var initPos = bmFloor((len - 1) * perc);
        var lengthPos = perc * bezierData.addedLength;
        var lPerc = 0;
        if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
          return percents[initPos];
        }
        var dir = lengths[initPos] > lengthPos ? -1 : 1;
        var flag = true;
        while (flag) {
          if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
            lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
            flag = false;
          } else {
            initPos += dir;
          }
          if (initPos < 0 || initPos >= len - 1) {
            // FIX for TypedArrays that don't store floating point values with enough accuracy
            if (initPos === len - 1) {
              return percents[initPos];
            }
            flag = false;
          }
        }
        return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
      }

      function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
        var t1 = getDistancePerc(percent, bezierData);
        var u1 = 1 - t1;
        var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;
        var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;
        return [ptX, ptY];
      }

      var bezierSegmentPoints = createTypedArray('float32', 8);

      function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
        if (startPerc < 0) {
          startPerc = 0;
        } else if (startPerc > 1) {
          startPerc = 1;
        }
        var t0 = getDistancePerc(startPerc, bezierData);
        endPerc = endPerc > 1 ? 1 : endPerc;
        var t1 = getDistancePerc(endPerc, bezierData);
        var i;
        var len = pt1.length;
        var u0 = 1 - t0;
        var u1 = 1 - t1;
        var u0u0u0 = u0 * u0 * u0;
        var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase
        var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase
        var t0t0t0 = t0 * t0 * t0;
        //
        var u0u0u1 = u0 * u0 * u1;
        var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase
        var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase
        var t0t0t1 = t0 * t0 * t1;
        //
        var u0u1u1 = u0 * u1 * u1;
        var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase
        var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase
        var t0t1t1 = t0 * t1 * t1;
        //
        var u1u1u1 = u1 * u1 * u1;
        var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase
        var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase
        var t1t1t1 = t1 * t1 * t1;
        for (i = 0; i < len; i += 1) {
          bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
          bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
          bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
          bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase
        }

        return bezierSegmentPoints;
      }

      return {
        getSegmentsLength: getSegmentsLength,
        getNewSegment: getNewSegment,
        getPointInSegment: getPointInSegment,
        buildBezierData: buildBezierData,
        pointOnLine2D: pointOnLine2D,
        pointOnLine3D: pointOnLine3D,
      };
    }

    var bez = bezFunction();

    /* global _useWebWorker */

    var dataManager = (function () {
      var _counterId = 1;
      var processes = [];
      var workerFn;
      var workerInstance;
      var workerProxy = {
        onmessage: function () {

        },
        postMessage: function (path) {
          workerFn({
            data: path,
          });
        },
      };
      var _workerSelf = {
        postMessage: function (data) {
          workerProxy.onmessage({
            data: data,
          });
        },
      };
      function createWorker(fn) {
        if (window.Worker && window.Blob && _useWebWorker) {
          var blob = new Blob(['var _workerSelf = self; self.onmessage = ', fn.toString()], { type: 'text/javascript' });
          // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });
          var url = URL.createObjectURL(blob);
          return new Worker(url);
        }
        workerFn = fn;
        return workerProxy;
      }

      function setupWorker() {
        if (!workerInstance) {
          workerInstance = createWorker(function workerStart(e) {
            /* exported dataManager */

            function dataFunctionManager() {
              // var tCanvasHelper = createTag('canvas').getContext('2d');

              function completeLayers(layers, comps) {
                var layerData;
                var i;
                var len = layers.length;
                var j;
                var jLen;
                var k;
                var kLen;
                for (i = 0; i < len; i += 1) {
                  layerData = layers[i];
                  if (('ks' in layerData) && !layerData.completed) {
                    layerData.completed = true;
                    if (layerData.tt) {
                      layers[i - 1].td = layerData.tt;
                    }
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          convertPathsToAbsoluteValues(maskProps[j].pt.k);
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);
                            }
                            if (maskProps[j].pt.k[k].e) {
                              convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 0) {
                      layerData.layers = findCompLayers(layerData.refId, comps);
                      completeLayers(layerData.layers, comps);
                    } else if (layerData.ty === 4) {
                      completeShapes(layerData.shapes);
                    } else if (layerData.ty === 5) {
                      completeText(layerData);
                    }
                  }
                }
              }

              function findCompLayers(id, comps) {
                var i = 0;
                var len = comps.length;
                while (i < len) {
                  if (comps[i].id === id) {
                    if (!comps[i].layers.__used) {
                      comps[i].layers.__used = true;
                      return comps[i].layers;
                    }
                    return JSON.parse(JSON.stringify(comps[i].layers));
                  }
                  i += 1;
                }
                return null;
              }

              function completeShapes(arr) {
                var i;
                var len = arr.length;
                var j;
                var jLen;
                for (i = len - 1; i >= 0; i -= 1) {
                  if (arr[i].ty === 'sh') {
                    if (arr[i].ks.k.i) {
                      convertPathsToAbsoluteValues(arr[i].ks.k);
                    } else {
                      jLen = arr[i].ks.k.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (arr[i].ks.k[j].s) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);
                        }
                        if (arr[i].ks.k[j].e) {
                          convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);
                        }
                      }
                    }
                  } else if (arr[i].ty === 'gr') {
                    completeShapes(arr[i].it);
                  }
                }
              }

              function convertPathsToAbsoluteValues(path) {
                var i;
                var len = path.i.length;
                for (i = 0; i < len; i += 1) {
                  path.i[i][0] += path.v[i][0];
                  path.i[i][1] += path.v[i][1];
                  path.o[i][0] += path.v[i][0];
                  path.o[i][1] += path.v[i][1];
                }
              }

              function checkVersion(minimum, animVersionString) {
                var animVersion = animVersionString ? animVersionString.split('.') : [100, 100, 100];
                if (minimum[0] > animVersion[0]) {
                  return true;
                } if (animVersion[0] > minimum[0]) {
                  return false;
                }
                if (minimum[1] > animVersion[1]) {
                  return true;
                } if (animVersion[1] > minimum[1]) {
                  return false;
                }
                if (minimum[2] > animVersion[2]) {
                  return true;
                } if (animVersion[2] > minimum[2]) {
                  return false;
                }
                return null;
              }

              var checkText = (function () {
                var minimumVersion = [4, 4, 14];

                function updateTextLayer(textLayer) {
                  var documentData = textLayer.t.d;
                  textLayer.t.d = {
                    k: [
                      {
                        s: documentData,
                        t: 0,
                      },
                    ],
                  };
                }

                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }

                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }());

              var checkChars = (function () {
                var minimumVersion = [4, 7, 99];
                return function (animationData) {
                  if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {
                    var i;
                    var len = animationData.chars.length;
                    var j;
                    var jLen;
                    var pathData;
                    var paths;
                    for (i = 0; i < len; i += 1) {
                      if (animationData.chars[i].data && animationData.chars[i].data.shapes) {
                        paths = animationData.chars[i].data.shapes[0].it;
                        jLen = paths.length;

                        for (j = 0; j < jLen; j += 1) {
                          pathData = paths[j].ks.k;
                          if (!pathData.__converted) {
                            convertPathsToAbsoluteValues(paths[j].ks.k);
                            pathData.__converted = true;
                          }
                        }
                      }
                    }
                  }
                };
              }());

              var checkPathProperties = (function () {
                var minimumVersion = [5, 7, 15];

                function updateTextLayer(textLayer) {
                  var pathData = textLayer.t.p;
                  if (typeof pathData.a === 'number') {
                    pathData.a = {
                      a: 0,
                      k: pathData.a,
                    };
                  }
                  if (typeof pathData.p === 'number') {
                    pathData.p = {
                      a: 0,
                      k: pathData.p,
                    };
                  }
                  if (typeof pathData.r === 'number') {
                    pathData.r = {
                      a: 0,
                      k: pathData.r,
                    };
                  }
                }

                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 5) {
                      updateTextLayer(layers[i]);
                    }
                  }
                }

                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }());

              var checkColors = (function () {
                var minimumVersion = [4, 1, 9];

                function iterateShapes(shapes) {
                  var i;
                  var len = shapes.length;
                  var j;
                  var jLen;
                  for (i = 0; i < len; i += 1) {
                    if (shapes[i].ty === 'gr') {
                      iterateShapes(shapes[i].it);
                    } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {
                      if (shapes[i].c.k && shapes[i].c.k[0].i) {
                        jLen = shapes[i].c.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (shapes[i].c.k[j].s) {
                            shapes[i].c.k[j].s[0] /= 255;
                            shapes[i].c.k[j].s[1] /= 255;
                            shapes[i].c.k[j].s[2] /= 255;
                            shapes[i].c.k[j].s[3] /= 255;
                          }
                          if (shapes[i].c.k[j].e) {
                            shapes[i].c.k[j].e[0] /= 255;
                            shapes[i].c.k[j].e[1] /= 255;
                            shapes[i].c.k[j].e[2] /= 255;
                            shapes[i].c.k[j].e[3] /= 255;
                          }
                        }
                      } else {
                        shapes[i].c.k[0] /= 255;
                        shapes[i].c.k[1] /= 255;
                        shapes[i].c.k[2] /= 255;
                        shapes[i].c.k[3] /= 255;
                      }
                    }
                  }
                }

                function iterateLayers(layers) {
                  var i;
                  var len = layers.length;
                  for (i = 0; i < len; i += 1) {
                    if (layers[i].ty === 4) {
                      iterateShapes(layers[i].shapes);
                    }
                  }
                }

                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }());

              var checkShapes = (function () {
                var minimumVersion = [4, 4, 18];

                function completeClosingShapes(arr) {
                  var i;
                  var len = arr.length;
                  var j;
                  var jLen;
                  for (i = len - 1; i >= 0; i -= 1) {
                    if (arr[i].ty === 'sh') {
                      if (arr[i].ks.k.i) {
                        arr[i].ks.k.c = arr[i].closed;
                      } else {
                        jLen = arr[i].ks.k.length;
                        for (j = 0; j < jLen; j += 1) {
                          if (arr[i].ks.k[j].s) {
                            arr[i].ks.k[j].s[0].c = arr[i].closed;
                          }
                          if (arr[i].ks.k[j].e) {
                            arr[i].ks.k[j].e[0].c = arr[i].closed;
                          }
                        }
                      }
                    } else if (arr[i].ty === 'gr') {
                      completeClosingShapes(arr[i].it);
                    }
                  }
                }

                function iterateLayers(layers) {
                  var layerData;
                  var i;
                  var len = layers.length;
                  var j;
                  var jLen;
                  var k;
                  var kLen;
                  for (i = 0; i < len; i += 1) {
                    layerData = layers[i];
                    if (layerData.hasMask) {
                      var maskProps = layerData.masksProperties;
                      jLen = maskProps.length;
                      for (j = 0; j < jLen; j += 1) {
                        if (maskProps[j].pt.k.i) {
                          maskProps[j].pt.k.c = maskProps[j].cl;
                        } else {
                          kLen = maskProps[j].pt.k.length;
                          for (k = 0; k < kLen; k += 1) {
                            if (maskProps[j].pt.k[k].s) {
                              maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;
                            }
                            if (maskProps[j].pt.k[k].e) {
                              maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;
                            }
                          }
                        }
                      }
                    }
                    if (layerData.ty === 4) {
                      completeClosingShapes(layerData.shapes);
                    }
                  }
                }

                return function (animationData) {
                  if (checkVersion(minimumVersion, animationData.v)) {
                    iterateLayers(animationData.layers);
                    if (animationData.assets) {
                      var i;
                      var len = animationData.assets.length;
                      for (i = 0; i < len; i += 1) {
                        if (animationData.assets[i].layers) {
                          iterateLayers(animationData.assets[i].layers);
                        }
                      }
                    }
                  }
                };
              }());

              function completeData(animationData) {
                if (animationData.__complete) {
                  return;
                }
                checkColors(animationData);
                checkText(animationData);
                checkChars(animationData);
                checkPathProperties(animationData);
                checkShapes(animationData);
                completeLayers(animationData.layers, animationData.assets);
                animationData.__complete = true;
              }

              function completeText(data) {
                if (data.t.a.length === 0 && !('m' in data.t.p)) {
                  data.singleShape = true;
                }
              }

              var moduleOb = {};
              moduleOb.completeData = completeData;
              moduleOb.checkColors = checkColors;
              moduleOb.checkChars = checkChars;
              moduleOb.checkPathProperties = checkPathProperties;
              moduleOb.checkShapes = checkShapes;
              moduleOb.completeLayers = completeLayers;

              return moduleOb;
            }
            if (!_workerSelf.dataManager) {
              _workerSelf.dataManager = dataFunctionManager();
            }

            /* exported assetLoader */
            if (!_workerSelf.assetLoader) {
              _workerSelf.assetLoader = (function () {
                function formatResponse(xhr) {
                  // using typeof doubles the time of execution of this method,
                  // so if available, it's better to use the header to validate the type
                  var contentTypeHeader = xhr.getResponseHeader('content-type');
                  if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {
                    return xhr.response;
                  }
                  if (xhr.response && typeof xhr.response === 'object') {
                    return xhr.response;
                  } if (xhr.response && typeof xhr.response === 'string') {
                    return JSON.parse(xhr.response);
                  } if (xhr.responseText) {
                    return JSON.parse(xhr.responseText);
                  }
                  return null;
                }

                function loadAsset(path, fullPath, callback, errorCallback) {
                  var response;
                  var xhr = new XMLHttpRequest();
                  // set responseType after calling open or IE will break.
                  try {
                    // This crashes on Android WebView prior to KitKat
                    xhr.responseType = 'json';
                  } catch (err) {} // eslint-disable-line no-empty
                  xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                      if (xhr.status === 200) {
                        response = formatResponse(xhr);
                        callback(response);
                      } else {
                        try {
                          response = formatResponse(xhr);
                          callback(response);
                        } catch (err) {
                          if (errorCallback) {
                            errorCallback(err);
                          }
                        }
                      }
                    }
                  };
                  try {
                    xhr.open('GET', path, true);
                  } catch (error) {
                    xhr.open('GET', fullPath + '/' + path, true);
                  }
                  xhr.send();
                }
                return {
                  load: loadAsset,
                };
              }());
            }

            if (e.data.type === 'loadAnimation') {
              _workerSelf.assetLoader.load(
                e.data.path,
                e.data.fullPath,
                function (data) {
                  _workerSelf.dataManager.completeData(data);
                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data,
                    status: 'success',
                  });
                },
                function () {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: 'error',
                  });
                }
              );
            } else if (e.data.type === 'complete') {
              var animation = e.data.animation;
              _workerSelf.dataManager.completeData(animation);
              _workerSelf.postMessage({
                id: e.data.id,
                payload: animation,
                status: 'success',
              });
            } else if (e.data.type === 'loadData') {
              _workerSelf.assetLoader.load(
                e.data.path,
                e.data.fullPath,
                function (data) {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    payload: data,
                    status: 'success',
                  });
                },
                function () {
                  _workerSelf.postMessage({
                    id: e.data.id,
                    status: 'error',
                  });
                }
              );
            }
          });

          workerInstance.onmessage = function (event) {
            var data = event.data;
            var id = data.id;
            var process = processes[id];
            processes[id] = null;
            if (data.status === 'success') {
              process.onComplete(data.payload);
            } else if (process.onError) {
              process.onError();
            }
          };
        }
      }

      function createProcess(onComplete, onError) {
        _counterId += 1;
        var id = 'processId_' + _counterId;
        processes[id] = {
          onComplete: onComplete,
          onError: onError,
        };
        return id;
      }

      function loadAnimation(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'loadAnimation',
          path: path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId,
        });
      }

      function loadData(path, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'loadData',
          path: path,
          fullPath: window.location.origin + window.location.pathname,
          id: processId,
        });
      }

      function completeAnimation(anim, onComplete, onError) {
        setupWorker();
        var processId = createProcess(onComplete, onError);
        workerInstance.postMessage({
          type: 'complete',
          animation: anim,
          id: processId,
        });
      }

      return {
        loadAnimation: loadAnimation,
        loadData: loadData,
        completeAnimation: completeAnimation,
      };
    }());

    /* exported getFontProperties */

    function getFontProperties(fontData) {
      var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];

      var fWeight = 'normal'; var
        fStyle = 'normal';
      var len = styles.length;
      var styleName;
      for (var i = 0; i < len; i += 1) {
        styleName = styles[i].toLowerCase();
        switch (styleName) {
          case 'italic':
            fStyle = 'italic';
            break;
          case 'bold':
            fWeight = '700';
            break;
          case 'black':
            fWeight = '900';
            break;
          case 'medium':
            fWeight = '500';
            break;
          case 'regular':
          case 'normal':
            fWeight = '400';
            break;
          case 'light':
          case 'thin':
            fWeight = '200';
            break;
        }
      }

      return {
        style: fStyle,
        weight: fontData.fWeight || fWeight,
      };
    }

    /* global createNS, createTag, getFontProperties */
    /* exported FontManager */

    var FontManager = (function () {
      var maxWaitingTime = 5000;
      var emptyChar = {
        w: 0,
        size: 0,
        shapes: [],
      };
      var combinedCharacters = [];
      // Hindi characters
      combinedCharacters = combinedCharacters.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366,
        2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379,
        2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);

      var surrogateModifiers = [
        'd83cdffb',
        'd83cdffc',
        'd83cdffd',
        'd83cdffe',
        'd83cdfff',
      ];

      var zeroWidthJoiner = [65039, 8205];

      function trimFontOptions(font) {
        var familyArray = font.split(',');
        var i;
        var len = familyArray.length;
        var enabledFamilies = [];
        for (i = 0; i < len; i += 1) {
          if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {
            enabledFamilies.push(familyArray[i]);
          }
        }
        return enabledFamilies.join(',');
      }

      function setUpNode(font, family) {
        var parentNode = createTag('span');
        // Node is invisible to screen readers.
        parentNode.setAttribute('aria-hidden', true);
        parentNode.style.fontFamily = family;
        var node = createTag('span');
        // Characters that vary significantly among different fonts
        node.innerText = 'giItT1WQy@!-/#';
        // Visible - so we can measure it - but not on the screen
        parentNode.style.position = 'absolute';
        parentNode.style.left = '-10000px';
        parentNode.style.top = '-10000px';
        // Large font size makes even subtle changes obvious
        parentNode.style.fontSize = '300px';
        // Reset any font properties
        parentNode.style.fontVariant = 'normal';
        parentNode.style.fontStyle = 'normal';
        parentNode.style.fontWeight = 'normal';
        parentNode.style.letterSpacing = '0';
        parentNode.appendChild(node);
        document.body.appendChild(parentNode);

        // Remember width with no applied web font
        var width = node.offsetWidth;
        node.style.fontFamily = trimFontOptions(font) + ', ' + family;
        return { node: node, w: width, parent: parentNode };
      }

      function checkLoadedFonts() {
        var i;
        var len = this.fonts.length;
        var node;
        var w;
        var loadedCount = len;
        for (i = 0; i < len; i += 1) {
          if (this.fonts[i].loaded) {
            loadedCount -= 1;
          } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {
            this.fonts[i].loaded = true;
          } else {
            node = this.fonts[i].monoCase.node;
            w = this.fonts[i].monoCase.w;
            if (node.offsetWidth !== w) {
              loadedCount -= 1;
              this.fonts[i].loaded = true;
            } else {
              node = this.fonts[i].sansCase.node;
              w = this.fonts[i].sansCase.w;
              if (node.offsetWidth !== w) {
                loadedCount -= 1;
                this.fonts[i].loaded = true;
              }
            }
            if (this.fonts[i].loaded) {
              this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);
              this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);
            }
          }
        }

        if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
          setTimeout(this.checkLoadedFontsBinded, 20);
        } else {
          setTimeout(this.setIsLoadedBinded, 10);
        }
      }

      function createHelper(def, fontData) {
        var tHelper = createNS('text');
        tHelper.style.fontSize = '100px';
        // tHelper.style.fontFamily = fontData.fFamily;

        var fontProps = getFontProperties(fontData);
        tHelper.setAttribute('font-family', fontData.fFamily);
        tHelper.setAttribute('font-style', fontProps.style);
        tHelper.setAttribute('font-weight', fontProps.weight);
        tHelper.textContent = '1';
        if (fontData.fClass) {
          tHelper.style.fontFamily = 'inherit';
          tHelper.setAttribute('class', fontData.fClass);
        } else {
          tHelper.style.fontFamily = fontData.fFamily;
        }
        def.appendChild(tHelper);
        var tCanvasHelper = createTag('canvas').getContext('2d');
        tCanvasHelper.font = fontData.fWeight + ' ' + fontData.fStyle + ' 100px ' + fontData.fFamily;
        // tCanvasHelper.font = ' 100px '+ fontData.fFamily;
        return tHelper;
      }

      function addFonts(fontData, defs) {
        if (!fontData) {
          this.isLoaded = true;
          return;
        }
        if (this.chars) {
          this.isLoaded = true;
          this.fonts = fontData.list;
          return;
        }

        var fontArr = fontData.list;
        var i;
        var len = fontArr.length;
        var _pendingFonts = len;
        for (i = 0; i < len; i += 1) {
          var shouldLoadFont = true;
          var loadedSelector;
          var j;
          fontArr[i].loaded = false;
          fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');
          fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');
          if (!fontArr[i].fPath) {
            fontArr[i].loaded = true;
            _pendingFonts -= 1;
          } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {
            loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i].fFamily + '"]');

            if (loadedSelector.length > 0) {
              shouldLoadFont = false;
            }

            if (shouldLoadFont) {
              var s = createTag('style');
              s.setAttribute('f-forigin', fontArr[i].fOrigin);
              s.setAttribute('f-origin', fontArr[i].origin);
              s.setAttribute('f-family', fontArr[i].fFamily);
              s.type = 'text/css';
              s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + "; font-style: normal; src: url('" + fontArr[i].fPath + "');}";
              defs.appendChild(s);
            }
          } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {
            loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');

            for (j = 0; j < loadedSelector.length; j += 1) {
              if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {
                // Font is already loaded
                shouldLoadFont = false;
              }
            }

            if (shouldLoadFont) {
              var l = createTag('link');
              l.setAttribute('f-forigin', fontArr[i].fOrigin);
              l.setAttribute('f-origin', fontArr[i].origin);
              l.type = 'text/css';
              l.rel = 'stylesheet';
              l.href = fontArr[i].fPath;
              document.body.appendChild(l);
            }
          } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {
            loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');

            for (j = 0; j < loadedSelector.length; j += 1) {
              if (fontArr[i].fPath === loadedSelector[j].src) {
                // Font is already loaded
                shouldLoadFont = false;
              }
            }

            if (shouldLoadFont) {
              var sc = createTag('link');
              sc.setAttribute('f-forigin', fontArr[i].fOrigin);
              sc.setAttribute('f-origin', fontArr[i].origin);
              sc.setAttribute('rel', 'stylesheet');
              sc.setAttribute('href', fontArr[i].fPath);
              defs.appendChild(sc);
            }
          }
          fontArr[i].helper = createHelper(defs, fontArr[i]);
          fontArr[i].cache = {};
          this.fonts.push(fontArr[i]);
        }
        if (_pendingFonts === 0) {
          this.isLoaded = true;
        } else {
          // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
          // Adding this timeout seems to fix it
          setTimeout(this.checkLoadedFonts.bind(this), 100);
        }
      }

      function addChars(chars) {
        if (!chars) {
          return;
        }
        if (!this.chars) {
          this.chars = [];
        }
        var i;
        var len = chars.length;
        var j;
        var jLen = this.chars.length;
        var found;
        for (i = 0; i < len; i += 1) {
          j = 0;
          found = false;
          while (j < jLen) {
            if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {
              found = true;
            }
            j += 1;
          }
          if (!found) {
            this.chars.push(chars[i]);
            jLen += 1;
          }
        }
      }

      function getCharData(char, style, font) {
        var i = 0;
        var len = this.chars.length;
        while (i < len) {
          if (this.chars[i].ch === char && this.chars[i].style === style && this.chars[i].fFamily === font) {
            return this.chars[i];
          }
          i += 1;
        }
        if (((typeof char === 'string' && char.charCodeAt(0) !== 13) || !char)
                && console
                && console.warn // eslint-disable-line no-console
                && !this._warned
        ) {
          this._warned = true;
          console.warn('Missing character from exported characters list: ', char, style, font); // eslint-disable-line no-console
        }
        return emptyChar;
      }

      function measureText(char, fontName, size) {
        var fontData = this.getFontByName(fontName);
        var index = char.charCodeAt(0);
        if (!fontData.cache[index + 1]) {
          var tHelper = fontData.helper;
          // Canvas version
          // fontData.cache[index] = tHelper.measureText(char).width / 100;
          // SVG version
          // console.log(tHelper.getBBox().width)
          if (char === ' ') {
            tHelper.textContent = '|' + char + '|';
            var doubleSize = tHelper.getComputedTextLength();
            tHelper.textContent = '||';
            var singleSize = tHelper.getComputedTextLength();
            fontData.cache[index + 1] = (doubleSize - singleSize) / 100;
          } else {
            tHelper.textContent = char;
            fontData.cache[index + 1] = (tHelper.getComputedTextLength()) / 100;
          }
        }
        return fontData.cache[index + 1] * size;
      }

      function getFontByName(name) {
        var i = 0;
        var len = this.fonts.length;
        while (i < len) {
          if (this.fonts[i].fName === name) {
            return this.fonts[i];
          }
          i += 1;
        }
        return this.fonts[0];
      }

      function isModifier(firstCharCode, secondCharCode) {
        var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
        return surrogateModifiers.indexOf(sum) !== -1;
      }

      function isZeroWidthJoiner(firstCharCode, secondCharCode) {
        if (!secondCharCode) {
          return firstCharCode === zeroWidthJoiner[1];
        }
        return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
      }

      function isCombinedCharacter(char) {
        return combinedCharacters.indexOf(char) !== -1;
      }

      function setIsLoaded() {
        this.isLoaded = true;
      }

      var Font = function () {
        this.fonts = [];
        this.chars = null;
        this.typekitLoaded = 0;
        this.isLoaded = false;
        this._warned = false;
        this.initTime = Date.now();
        this.setIsLoadedBinded = this.setIsLoaded.bind(this);
        this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      Font.isModifier = isModifier;
      Font.isZeroWidthJoiner = isZeroWidthJoiner;
      Font.isCombinedCharacter = isCombinedCharacter;

      var fontPrototype = {
        addChars: addChars,
        addFonts: addFonts,
        getCharData: getCharData,
        getFontByName: getFontByName,
        measureText: measureText,
        checkLoadedFonts: checkLoadedFonts,
        setIsLoaded: setIsLoaded,
      };

      Font.prototype = fontPrototype;

      return Font;
    }());

    /* global initialDefaultFrame, BezierFactory, degToRads, bez, createTypedArray */
    /* exported PropertyFactory */

    var PropertyFactory = (function () {
      var initFrame = initialDefaultFrame;
      var mathAbs = Math.abs;

      function interpolateValue(frameNum, caching) {
        var offsetTime = this.offsetTime;
        var newValue;
        if (this.propType === 'multidimensional') {
          newValue = createTypedArray('float32', this.pv.length);
        }
        var iterationIndex = caching.lastIndex;
        var i = iterationIndex;
        var len = this.keyframes.length - 1;
        var flag = true;
        var keyData;
        var nextKeyData;
        var keyframeMetadata;

        while (flag) {
          keyData = this.keyframes[i];
          nextKeyData = this.keyframes[i + 1];
          if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
            if (keyData.h) {
              keyData = nextKeyData;
            }
            iterationIndex = 0;
            break;
          }
          if ((nextKeyData.t - offsetTime) > frameNum) {
            iterationIndex = i;
            break;
          }
          if (i < len - 1) {
            i += 1;
          } else {
            iterationIndex = 0;
            flag = false;
          }
        }
        keyframeMetadata = this.keyframesMetadata[i] || {};

        var k;
        var kLen;
        var perc;
        var jLen;
        var j;
        var fnc;
        var nextKeyTime = nextKeyData.t - offsetTime;
        var keyTime = keyData.t - offsetTime;
        var endValue;
        if (keyData.to) {
          if (!keyframeMetadata.bezierData) {
            keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
          }
          var bezierData = keyframeMetadata.bezierData;
          if (frameNum >= nextKeyTime || frameNum < keyTime) {
            var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
            kLen = bezierData.points[ind].point.length;
            for (k = 0; k < kLen; k += 1) {
              newValue[k] = bezierData.points[ind].point[k];
            }
            // caching._lastKeyframeIndex = -1;
          } else {
            if (keyframeMetadata.__fnct) {
              fnc = keyframeMetadata.__fnct;
            } else {
              fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
              keyframeMetadata.__fnct = fnc;
            }
            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
            var distanceInLine = bezierData.segmentLength * perc;

            var segmentPerc;
            var addedLength = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastAddedLength : 0;
            j = (caching.lastFrame < frameNum && caching._lastKeyframeIndex === i) ? caching._lastPoint : 0;
            flag = true;
            jLen = bezierData.points.length;
            while (flag) {
              addedLength += bezierData.points[j].partialLength;
              if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k];
                }
                break;
              } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {
                segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;
                kLen = bezierData.points[j].point.length;
                for (k = 0; k < kLen; k += 1) {
                  newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;
                }
                break;
              }
              if (j < jLen - 1) {
                j += 1;
              } else {
                flag = false;
              }
            }
            caching._lastPoint = j;
            caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;
            caching._lastKeyframeIndex = i;
          }
        } else {
          var outX;
          var outY;
          var inX;
          var inY;
          var keyValue;
          len = keyData.s.length;
          endValue = nextKeyData.s || keyData.e;
          if (this.sh && keyData.h !== 1) {
            if (frameNum >= nextKeyTime) {
              newValue[0] = endValue[0];
              newValue[1] = endValue[1];
              newValue[2] = endValue[2];
            } else if (frameNum <= keyTime) {
              newValue[0] = keyData.s[0];
              newValue[1] = keyData.s[1];
              newValue[2] = keyData.s[2];
            } else {
              var quatStart = createQuaternion(keyData.s);
              var quatEnd = createQuaternion(endValue);
              var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
              quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
            }
          } else {
            for (i = 0; i < len; i += 1) {
              if (keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  perc = 1;
                } else if (frameNum < keyTime) {
                  perc = 0;
                } else {
                  if (keyData.o.x.constructor === Array) {
                    if (!keyframeMetadata.__fnct) {
                      keyframeMetadata.__fnct = [];
                    }
                    if (!keyframeMetadata.__fnct[i]) {
                      outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];
                      outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];
                      inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];
                      inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];
                      fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                      keyframeMetadata.__fnct[i] = fnc;
                    } else {
                      fnc = keyframeMetadata.__fnct[i];
                    }
                  } else if (!keyframeMetadata.__fnct) {
                    outX = keyData.o.x;
                    outY = keyData.o.y;
                    inX = keyData.i.x;
                    inY = keyData.i.y;
                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                    keyData.keyframeMetadata = fnc;
                  } else {
                    fnc = keyframeMetadata.__fnct;
                  }
                  perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                }
              }

              endValue = nextKeyData.s || keyData.e;
              keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;

              if (this.propType === 'multidimensional') {
                newValue[i] = keyValue;
              } else {
                newValue = keyValue;
              }
            }
          }
        }
        caching.lastIndex = iterationIndex;
        return newValue;
      }

      // based on @Toji's https://github.com/toji/gl-matrix/
      function slerp(a, b, t) {
        var out = [];
        var ax = a[0];
        var ay = a[1];
        var az = a[2];
        var aw = a[3];
        var bx = b[0];
        var by = b[1];
        var bz = b[2];
        var bw = b[3];

        var omega;
        var cosom;
        var sinom;
        var scale0;
        var scale1;

        cosom = ax * bx + ay * by + az * bz + aw * bw;
        if (cosom < 0.0) {
          cosom = -cosom;
          bx = -bx;
          by = -by;
          bz = -bz;
          bw = -bw;
        }
        if ((1.0 - cosom) > 0.000001) {
          omega = Math.acos(cosom);
          sinom = Math.sin(omega);
          scale0 = Math.sin((1.0 - t) * omega) / sinom;
          scale1 = Math.sin(t * omega) / sinom;
        } else {
          scale0 = 1.0 - t;
          scale1 = t;
        }
        out[0] = scale0 * ax + scale1 * bx;
        out[1] = scale0 * ay + scale1 * by;
        out[2] = scale0 * az + scale1 * bz;
        out[3] = scale0 * aw + scale1 * bw;

        return out;
      }

      function quaternionToEuler(out, quat) {
        var qx = quat[0];
        var qy = quat[1];
        var qz = quat[2];
        var qw = quat[3];
        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
        out[0] = heading / degToRads;
        out[1] = attitude / degToRads;
        out[2] = bank / degToRads;
      }

      function createQuaternion(values) {
        var heading = values[0] * degToRads;
        var attitude = values[1] * degToRads;
        var bank = values[2] * degToRads;
        var c1 = Math.cos(heading / 2);
        var c2 = Math.cos(attitude / 2);
        var c3 = Math.cos(bank / 2);
        var s1 = Math.sin(heading / 2);
        var s2 = Math.sin(attitude / 2);
        var s3 = Math.sin(bank / 2);
        var w = c1 * c2 * c3 - s1 * s2 * s3;
        var x = s1 * s2 * c3 + c1 * c2 * s3;
        var y = s1 * c2 * c3 + c1 * s2 * s3;
        var z = c1 * s2 * c3 - s1 * c2 * s3;

        return [x, y, z, w];
      }

      function getValueAtCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        if (!(frameNum === this._caching.lastFrame || (this._caching.lastFrame !== initFrame && ((this._caching.lastFrame >= endTime && frameNum >= endTime) || (this._caching.lastFrame < initTime && frameNum < initTime))))) {
          if (this._caching.lastFrame >= frameNum) {
            this._caching._lastKeyframeIndex = -1;
            this._caching.lastIndex = 0;
          }

          var renderResult = this.interpolateValue(frameNum, this._caching);
          this.pv = renderResult;
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }

      function setVValue(val) {
        var multipliedValue;
        if (this.propType === 'unidimensional') {
          multipliedValue = val * this.mult;
          if (mathAbs(this.v - multipliedValue) > 0.00001) {
            this.v = multipliedValue;
            this._mdf = true;
          }
        } else {
          var i = 0;
          var len = this.v.length;
          while (i < len) {
            multipliedValue = val[i] * this.mult;
            if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {
              this.v[i] = multipliedValue;
              this._mdf = true;
            }
            i += 1;
          }
        }
      }

      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = this._isFirstFrame;
        var i;
        var len = this.effectsSequence.length;
        var finalValue = this.kf ? this.pv : this.data.k;
        for (i = 0; i < len; i += 1) {
          finalValue = this.effectsSequence[i](finalValue);
        }
        this.setVValue(finalValue);
        this._isFirstFrame = false;
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }

      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }

      function ValueProperty(elem, data, mult, container) {
        this.propType = 'unidimensional';
        this.mult = mult || 1;
        this.data = data;
        this.v = mult ? data.k * mult : data.k;
        this.pv = data.k;
        this._mdf = false;
        this.elem = elem;
        this.container = container;
        this.comp = elem.comp;
        this.k = false;
        this.kf = false;
        this.vel = 0;
        this.effectsSequence = [];
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }

      function MultiDimensionalProperty(elem, data, mult, container) {
        this.propType = 'multidimensional';
        this.mult = mult || 1;
        this.data = data;
        this._mdf = false;
        this.elem = elem;
        this.container = container;
        this.comp = elem.comp;
        this.k = false;
        this.kf = false;
        this.frameId = -1;
        var i;
        var len = data.k.length;
        this.v = createTypedArray('float32', len);
        this.pv = createTypedArray('float32', len);
        this.vel = createTypedArray('float32', len);
        for (i = 0; i < len; i += 1) {
          this.v[i] = data.k[i] * this.mult;
          this.pv[i] = data.k[i];
        }
        this._isFirstFrame = true;
        this.effectsSequence = [];
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.addEffect = addEffect;
      }

      function KeyframedValueProperty(elem, data, mult, container) {
        this.propType = 'unidimensional';
        this.keyframes = data.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem.data.st;
        this.frameId = -1;
        this._caching = {
          lastFrame: initFrame, lastIndex: 0, value: 0, _lastKeyframeIndex: -1,
        };
        this.k = true;
        this.kf = true;
        this.data = data;
        this.mult = mult || 1;
        this.elem = elem;
        this.container = container;
        this.comp = elem.comp;
        this.v = initFrame;
        this.pv = initFrame;
        this._isFirstFrame = true;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.addEffect = addEffect;
      }

      function KeyframedMultidimensionalProperty(elem, data, mult, container) {
        this.propType = 'multidimensional';
        var i;
        var len = data.k.length;
        var s;
        var e;
        var to;
        var ti;
        for (i = 0; i < len - 1; i += 1) {
          if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {
            s = data.k[i].s;
            e = data.k[i + 1].s;
            to = data.k[i].to;
            ti = data.k[i].ti;
            if ((s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1])) || (s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2]))) {
              data.k[i].to = null;
              data.k[i].ti = null;
            }
            if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
              if (s.length === 2 || (s[2] === e[2] && to[2] === 0 && ti[2] === 0)) {
                data.k[i].to = null;
                data.k[i].ti = null;
              }
            }
          }
        }
        this.effectsSequence = [getValueAtCurrentTime.bind(this)];
        this.data = data;
        this.keyframes = data.k;
        this.keyframesMetadata = [];
        this.offsetTime = elem.data.st;
        this.k = true;
        this.kf = true;
        this._isFirstFrame = true;
        this.mult = mult || 1;
        this.elem = elem;
        this.container = container;
        this.comp = elem.comp;
        this.getValue = processEffectsSequence;
        this.setVValue = setVValue;
        this.interpolateValue = interpolateValue;
        this.frameId = -1;
        var arrLen = data.k[0].s.length;
        this.v = createTypedArray('float32', arrLen);
        this.pv = createTypedArray('float32', arrLen);
        for (i = 0; i < arrLen; i += 1) {
          this.v[i] = initFrame;
          this.pv[i] = initFrame;
        }
        this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray('float32', arrLen) };
        this.addEffect = addEffect;
      }

      function getProp(elem, data, type, mult, container) {
        var p;
        if (!data.k.length) {
          p = new ValueProperty(elem, data, mult, container);
        } else if (typeof (data.k[0]) === 'number') {
          p = new MultiDimensionalProperty(elem, data, mult, container);
        } else {
          switch (type) {
            case 0:
              p = new KeyframedValueProperty(elem, data, mult, container);
              break;
            case 1:
              p = new KeyframedMultidimensionalProperty(elem, data, mult, container);
              break;
          }
        }
        if (p.effectsSequence.length) {
          container.addDynamicProperty(p);
        }
        return p;
      }

      var ob = {
        getProp: getProp,
      };
      return ob;
    }());

    /* global Matrix, degToRads, PropertyFactory, extendPrototype, DynamicPropertyContainer */
    /* exported TransformPropertyFactory */

    var TransformPropertyFactory = (function () {
      var defaultVector = [0, 0];

      function applyToMatrix(mat) {
        var _mdf = this._mdf;
        this.iterateDynamicProperties();
        this._mdf = this._mdf || _mdf;
        if (this.a) {
          mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
        }
        if (this.s) {
          mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
        }
        if (this.sk) {
          mat.skewFromAxis(-this.sk.v, this.sa.v);
        }
        if (this.r) {
          mat.rotate(-this.r.v);
        } else {
          mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
            .rotateY(this.or.v[1])
            .rotateX(this.or.v[0]);
        }
        if (this.data.p.s) {
          if (this.data.p.z) {
            mat.translate(this.px.v, this.py.v, -this.pz.v);
          } else {
            mat.translate(this.px.v, this.py.v, 0);
          }
        } else {
          mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
        }
      }
      function processKeys(forceRender) {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        }
        if (this._isDirty) {
          this.precalculateMatrix();
          this._isDirty = false;
        }

        this.iterateDynamicProperties();

        if (this._mdf || forceRender) {
          var frameRate;
          this.v.cloneFromProps(this.pre.props);
          if (this.appliedTransformations < 1) {
            this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          }
          if (this.appliedTransformations < 2) {
            this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          }
          if (this.sk && this.appliedTransformations < 3) {
            this.v.skewFromAxis(-this.sk.v, this.sa.v);
          }
          if (this.r && this.appliedTransformations < 4) {
            this.v.rotate(-this.r.v);
          } else if (!this.r && this.appliedTransformations < 4) {
            this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
              .rotateY(this.or.v[1])
              .rotateX(this.or.v[0]);
          }
          if (this.autoOriented) {
            var v1;
            var v2;
            frameRate = this.elem.globalData.frameRate;
            if (this.p && this.p.keyframes && this.p.getValueAtTime) {
              if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
              } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                v1 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t / frameRate), 0);
                v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
              } else {
                v1 = this.p.pv;
                v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
              }
            } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
              v1 = [];
              v2 = [];
              var px = this.px;
              var py = this.py;
              if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                v2[0] = px.getValueAtTime((px.keyframes[0].t) / frameRate, 0);
                v2[1] = py.getValueAtTime((py.keyframes[0].t) / frameRate, 0);
              } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                v1[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t / frameRate), 0);
                v1[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t / frameRate), 0);
                v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
              } else {
                v1 = [px.pv, py.pv];
                v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
              }
            } else {
              v2 = defaultVector;
              v1 = v2;
            }
            this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));
          }
          if (this.data.p && this.data.p.s) {
            if (this.data.p.z) {
              this.v.translate(this.px.v, this.py.v, -this.pz.v);
            } else {
              this.v.translate(this.px.v, this.py.v, 0);
            }
          } else {
            this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
        }
        this.frameId = this.elem.globalData.frameId;
      }

      function precalculateMatrix() {
        if (!this.a.k) {
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
          this.appliedTransformations = 1;
        } else {
          return;
        }
        if (!this.s.effectsSequence.length) {
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
          this.appliedTransformations = 2;
        } else {
          return;
        }
        if (this.sk) {
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
            this.pre.skewFromAxis(-this.sk.v, this.sa.v);
            this.appliedTransformations = 3;
          } else {
            return;
          }
        }
        if (this.r) {
          if (!this.r.effectsSequence.length) {
            this.pre.rotate(-this.r.v);
            this.appliedTransformations = 4;
          }
        } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
          this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2])
            .rotateY(this.or.v[1])
            .rotateX(this.or.v[0]);
          this.appliedTransformations = 4;
        }
      }

      function autoOrient() {
        //
        // var prevP = this.getValueAtTime();
      }

      function addDynamicProperty(prop) {
        this._addDynamicProperty(prop);
        this.elem.addDynamicProperty(prop);
        this._isDirty = true;
      }

      function TransformProperty(elem, data, container) {
        this.elem = elem;
        this.frameId = -1;
        this.propType = 'transform';
        this.data = data;
        this.v = new Matrix();
        // Precalculated matrix with non animated properties
        this.pre = new Matrix();
        this.appliedTransformations = 0;
        this.initDynamicPropertyContainer(container || elem);
        if (data.p && data.p.s) {
          this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
          this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
          if (data.p.z) {
            this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
          }
        } else {
          this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
        }
        if (data.rx) {
          this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
          this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
          this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
          if (data.or.k[0].ti) {
            var i;
            var len = data.or.k.length;
            for (i = 0; i < len; i += 1) {
              data.or.k[i].to = null;
              data.or.k[i].ti = null;
            }
          }
          this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
          // sh Indicates it needs to be capped between -180 and 180
          this.or.sh = true;
        } else {
          this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
        }
        if (data.sk) {
          this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
          this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
        }
        this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
        this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
        // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
        if (data.o) {
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
        } else {
          this.o = { _mdf: false, v: 1 };
        }
        this._isDirty = true;
        if (!this.dynamicProperties.length) {
          this.getValue(true);
        }
      }

      TransformProperty.prototype = {
        applyToMatrix: applyToMatrix,
        getValue: processKeys,
        precalculateMatrix: precalculateMatrix,
        autoOrient: autoOrient,
      };

      extendPrototype([DynamicPropertyContainer], TransformProperty);
      TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
      TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;

      function getTransformProperty(elem, data, container) {
        return new TransformProperty(elem, data, container);
      }

      return {
        getTransformProperty: getTransformProperty,
      };
    }());

    /* global createSizedArray, createSizedArray, pointPool */

    function ShapePath() {
      this.c = false;
      this._length = 0;
      this._maxLength = 8;
      this.v = createSizedArray(this._maxLength);
      this.o = createSizedArray(this._maxLength);
      this.i = createSizedArray(this._maxLength);
    }

    ShapePath.prototype.setPathData = function (closed, len) {
      this.c = closed;
      this.setLength(len);
      var i = 0;
      while (i < len) {
        this.v[i] = pointPool.newElement();
        this.o[i] = pointPool.newElement();
        this.i[i] = pointPool.newElement();
        i += 1;
      }
    };

    ShapePath.prototype.setLength = function (len) {
      while (this._maxLength < len) {
        this.doubleArrayLength();
      }
      this._length = len;
    };

    ShapePath.prototype.doubleArrayLength = function () {
      this.v = this.v.concat(createSizedArray(this._maxLength));
      this.i = this.i.concat(createSizedArray(this._maxLength));
      this.o = this.o.concat(createSizedArray(this._maxLength));
      this._maxLength *= 2;
    };

    ShapePath.prototype.setXYAt = function (x, y, type, pos, replace) {
      var arr;
      this._length = Math.max(this._length, pos + 1);
      if (this._length >= this._maxLength) {
        this.doubleArrayLength();
      }
      switch (type) {
        case 'v':
          arr = this.v;
          break;
        case 'i':
          arr = this.i;
          break;
        case 'o':
          arr = this.o;
          break;
        default:
          arr = [];
          break;
      }
      if (!arr[pos] || (arr[pos] && !replace)) {
        arr[pos] = pointPool.newElement();
      }
      arr[pos][0] = x;
      arr[pos][1] = y;
    };

    ShapePath.prototype.setTripleAt = function (vX, vY, oX, oY, iX, iY, pos, replace) {
      this.setXYAt(vX, vY, 'v', pos, replace);
      this.setXYAt(oX, oY, 'o', pos, replace);
      this.setXYAt(iX, iY, 'i', pos, replace);
    };

    ShapePath.prototype.reverse = function () {
      var newPath = new ShapePath();
      newPath.setPathData(this.c, this._length);
      var vertices = this.v;
      var outPoints = this.o;
      var inPoints = this.i;
      var init = 0;
      if (this.c) {
        newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
        init = 1;
      }
      var cnt = this._length - 1;
      var len = this._length;

      var i;
      for (i = init; i < len; i += 1) {
        newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);
        cnt -= 1;
      }
      return newPath;
    };

    /* global extendPrototype, roundCorner, BezierFactory, shapePool, degToRads,
      shapeCollectionPool, PropertyFactory, bmMin, DynamicPropertyContainer */
    /* exported ShapePropertyFactory */

    var ShapePropertyFactory = (function () {
      var initFrame = -999999;

      function interpolateShape(frameNum, previousValue, caching) {
        var iterationIndex = caching.lastIndex;
        var keyPropS;
        var keyPropE;
        var isHold;
        var j;
        var k;
        var jLen;
        var kLen;
        var perc;
        var vertexValue;
        var kf = this.keyframes;
        if (frameNum < kf[0].t - this.offsetTime) {
          keyPropS = kf[0].s[0];
          isHold = true;
          iterationIndex = 0;
        } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
          keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
          /* if(kf[kf.length - 1].s){
                    keyPropS = kf[kf.length - 1].s[0];
                }else{
                    keyPropS = kf[kf.length - 2].e[0];
                } */
          isHold = true;
        } else {
          var i = iterationIndex;
          var len = kf.length - 1;
          var flag = true;
          var keyData;
          var nextKeyData;
          var keyframeMetadata;
          while (flag) {
            keyData = kf[i];
            nextKeyData = kf[i + 1];
            if ((nextKeyData.t - this.offsetTime) > frameNum) {
              break;
            }
            if (i < len - 1) {
              i += 1;
            } else {
              flag = false;
            }
          }
          keyframeMetadata = this.keyframesMetadata[i] || {};
          isHold = keyData.h === 1;
          iterationIndex = i;
          if (!isHold) {
            if (frameNum >= nextKeyData.t - this.offsetTime) {
              perc = 1;
            } else if (frameNum < keyData.t - this.offsetTime) {
              perc = 0;
            } else {
              var fnc;
              if (keyframeMetadata.__fnct) {
                fnc = keyframeMetadata.__fnct;
              } else {
                fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                keyframeMetadata.__fnct = fnc;
              }
              perc = fnc((frameNum - (keyData.t - this.offsetTime)) / ((nextKeyData.t - this.offsetTime) - (keyData.t - this.offsetTime)));
            }
            keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
          }
          keyPropS = keyData.s[0];
        }
        jLen = previousValue._length;
        kLen = keyPropS.i[0].length;
        caching.lastIndex = iterationIndex;

        for (j = 0; j < jLen; j += 1) {
          for (k = 0; k < kLen; k += 1) {
            vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;
            previousValue.i[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;
            previousValue.o[j][k] = vertexValue;
            vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;
            previousValue.v[j][k] = vertexValue;
          }
        }
      }

      function interpolateShapeCurrentTime() {
        var frameNum = this.comp.renderedFrame - this.offsetTime;
        var initTime = this.keyframes[0].t - this.offsetTime;
        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
        var lastFrame = this._caching.lastFrame;
        if (!(lastFrame !== initFrame && ((lastFrame < initTime && frameNum < initTime) || (lastFrame > endTime && frameNum > endTime)))) {
          /// /
          this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
          this.interpolateShape(frameNum, this.pv, this._caching);
          /// /
        }
        this._caching.lastFrame = frameNum;
        return this.pv;
      }

      function resetShape() {
        this.paths = this.localShapeCollection;
      }

      function shapesEqual(shape1, shape2) {
        if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
          return false;
        }
        var i;
        var len = shape1._length;
        for (i = 0; i < len; i += 1) {
          if (shape1.v[i][0] !== shape2.v[i][0]
                || shape1.v[i][1] !== shape2.v[i][1]
                || shape1.o[i][0] !== shape2.o[i][0]
                || shape1.o[i][1] !== shape2.o[i][1]
                || shape1.i[i][0] !== shape2.i[i][0]
                || shape1.i[i][1] !== shape2.i[i][1]) {
            return false;
          }
        }
        return true;
      }

      function setVValue(newPath) {
        if (!shapesEqual(this.v, newPath)) {
          this.v = shapePool.clone(newPath);
          this.localShapeCollection.releaseShapes();
          this.localShapeCollection.addShape(this.v);
          this._mdf = true;
          this.paths = this.localShapeCollection;
        }
      }

      function processEffectsSequence() {
        if (this.elem.globalData.frameId === this.frameId) {
          return;
        } if (!this.effectsSequence.length) {
          this._mdf = false;
          return;
        }
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = true;
        this._mdf = false;
        var finalValue;
        if (this.kf) {
          finalValue = this.pv;
        } else if (this.data.ks) {
          finalValue = this.data.ks.k;
        } else {
          finalValue = this.data.pt.k;
        }
        var i;
        var len = this.effectsSequence.length;
        for (i = 0; i < len; i += 1) {
          finalValue = this.effectsSequence[i](finalValue);
        }
        this.setVValue(finalValue);
        this.lock = false;
        this.frameId = this.elem.globalData.frameId;
      }

      function ShapeProperty(elem, data, type) {
        this.propType = 'shape';
        this.comp = elem.comp;
        this.container = elem;
        this.elem = elem;
        this.data = data;
        this.k = false;
        this.kf = false;
        this._mdf = false;
        var pathData = type === 3 ? data.pt.k : data.ks.k;
        this.v = shapePool.clone(pathData);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.reset = resetShape;
        this.effectsSequence = [];
      }

      function addEffect(effectFunction) {
        this.effectsSequence.push(effectFunction);
        this.container.addDynamicProperty(this);
      }

      ShapeProperty.prototype.interpolateShape = interpolateShape;
      ShapeProperty.prototype.getValue = processEffectsSequence;
      ShapeProperty.prototype.setVValue = setVValue;
      ShapeProperty.prototype.addEffect = addEffect;

      function KeyframedShapeProperty(elem, data, type) {
        this.propType = 'shape';
        this.comp = elem.comp;
        this.elem = elem;
        this.container = elem;
        this.offsetTime = elem.data.st;
        this.keyframes = type === 3 ? data.pt.k : data.ks.k;
        this.keyframesMetadata = [];
        this.k = true;
        this.kf = true;
        var len = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement();
        this.v.setPathData(this.keyframes[0].s[0].c, len);
        this.pv = shapePool.clone(this.v);
        this.localShapeCollection = shapeCollectionPool.newShapeCollection();
        this.paths = this.localShapeCollection;
        this.paths.addShape(this.v);
        this.lastFrame = initFrame;
        this.reset = resetShape;
        this._caching = { lastFrame: initFrame, lastIndex: 0 };
        this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
      }
      KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
      KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
      KeyframedShapeProperty.prototype.setVValue = setVValue;
      KeyframedShapeProperty.prototype.addEffect = addEffect;

      var EllShapeProperty = (function () {
        var cPoint = roundCorner;

        function EllShapePropertyFactory(elem, data) {
          /* this.v = {
                    v: createSizedArray(4),
                    i: createSizedArray(4),
                    o: createSizedArray(4),
                    c: true
                }; */
          this.v = shapePool.newElement();
          this.v.setPathData(true, 4);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.paths = this.localShapeCollection;
          this.localShapeCollection.addShape(this.v);
          this.d = data.d;
          this.elem = elem;
          this.comp = elem.comp;
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertEllToPath();
          }
        }

        EllShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function () {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();

            if (this._mdf) {
              this.convertEllToPath();
            }
          },
          convertEllToPath: function () {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var s0 = this.s.v[0] / 2;
            var s1 = this.s.v[1] / 2;
            var _cw = this.d !== 3;
            var _v = this.v;
            _v.v[0][0] = p0;
            _v.v[0][1] = p1 - s1;
            _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.v[1][1] = p1;
            _v.v[2][0] = p0;
            _v.v[2][1] = p1 + s1;
            _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.v[3][1] = p1;
            _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.i[0][1] = p1 - s1;
            _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.i[1][1] = p1 - s1 * cPoint;
            _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.i[2][1] = p1 + s1;
            _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.i[3][1] = p1 + s1 * cPoint;
            _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
            _v.o[0][1] = p1 - s1;
            _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
            _v.o[1][1] = p1 + s1 * cPoint;
            _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
            _v.o[2][1] = p1 + s1;
            _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
            _v.o[3][1] = p1 - s1 * cPoint;
          },
        };

        extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);

        return EllShapePropertyFactory;
      }());

      var StarShapeProperty = (function () {
        function StarShapePropertyFactory(elem, data) {
          this.v = shapePool.newElement();
          this.v.setPathData(true, 0);
          this.elem = elem;
          this.comp = elem.comp;
          this.data = data;
          this.frameId = -1;
          this.d = data.d;
          this.initDynamicPropertyContainer(elem);
          if (data.sy === 1) {
            this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
            this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
            this.convertToPath = this.convertStarToPath;
          } else {
            this.convertToPath = this.convertPolygonToPath;
          }
          this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
          this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
          this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertToPath();
          }
        }

        StarShapePropertyFactory.prototype = {
          reset: resetShape,
          getValue: function () {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertToPath();
            }
          },
          convertStarToPath: function () {
            var numPts = Math.floor(this.pt.v) * 2;
            var angle = (Math.PI * 2) / numPts;
            /* this.v.v.length = numPts;
                    this.v.i.length = numPts;
                    this.v.o.length = numPts; */
            var longFlag = true;
            var longRad = this.or.v;
            var shortRad = this.ir.v;
            var longRound = this.os.v;
            var shortRound = this.is.v;
            var longPerimSegment = (2 * Math.PI * longRad) / (numPts * 2);
            var shortPerimSegment = (2 * Math.PI * shortRad) / (numPts * 2);
            var i;
            var rad;
            var roundness;
            var perimSegment;
            var currentAng = -Math.PI / 2;
            currentAng += this.r.v;
            var dir = this.data.d === 3 ? -1 : 1;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              rad = longFlag ? longRad : shortRad;
              roundness = longFlag ? longRound : shortRound;
              perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);

              /* this.v.v[i] = [x,y];
                        this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
                        this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
                        this.v._length = numPts; */
              longFlag = !longFlag;
              currentAng += angle * dir;
            }
          },
          convertPolygonToPath: function () {
            var numPts = Math.floor(this.pt.v);
            var angle = (Math.PI * 2) / numPts;
            var rad = this.or.v;
            var roundness = this.os.v;
            var perimSegment = (2 * Math.PI * rad) / (numPts * 4);
            var i;
            var currentAng = -Math.PI * 0.5;
            var dir = this.data.d === 3 ? -1 : 1;
            currentAng += this.r.v;
            this.v._length = 0;
            for (i = 0; i < numPts; i += 1) {
              var x = rad * Math.cos(currentAng);
              var y = rad * Math.sin(currentAng);
              var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);
              var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);
              x += +this.p.v[0];
              y += +this.p.v[1];
              this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);
              currentAng += angle * dir;
            }
            this.paths.length = 0;
            this.paths[0] = this.v;
          },

        };
        extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);

        return StarShapePropertyFactory;
      }());

      var RectShapeProperty = (function () {
        function RectShapePropertyFactory(elem, data) {
          this.v = shapePool.newElement();
          this.v.c = true;
          this.localShapeCollection = shapeCollectionPool.newShapeCollection();
          this.localShapeCollection.addShape(this.v);
          this.paths = this.localShapeCollection;
          this.elem = elem;
          this.comp = elem.comp;
          this.frameId = -1;
          this.d = data.d;
          this.initDynamicPropertyContainer(elem);
          this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
          this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
          this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.k = false;
            this.convertRectToPath();
          }
        }

        RectShapePropertyFactory.prototype = {
          convertRectToPath: function () {
            var p0 = this.p.v[0];
            var p1 = this.p.v[1];
            var v0 = this.s.v[0] / 2;
            var v1 = this.s.v[1] / 2;
            var round = bmMin(v0, v1, this.r.v);
            var cPoint = round * (1 - roundCorner);
            this.v._length = 0;

            if (this.d === 2 || this.d === 1) {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
              this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
              if (round !== 0) {
                this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
              }
            } else {
              this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
              if (round !== 0) {
                this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
              } else {
                this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
              }
            }
          },
          getValue: function () {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            this.frameId = this.elem.globalData.frameId;
            this.iterateDynamicProperties();
            if (this._mdf) {
              this.convertRectToPath();
            }
          },
          reset: resetShape,
        };
        extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);

        return RectShapePropertyFactory;
      }());

      function getShapeProp(elem, data, type) {
        var prop;
        if (type === 3 || type === 4) {
          var dataProp = type === 3 ? data.pt : data.ks;
          var keys = dataProp.k;
          if (keys.length) {
            prop = new KeyframedShapeProperty(elem, data, type);
          } else {
            prop = new ShapeProperty(elem, data, type);
          }
        } else if (type === 5) {
          prop = new RectShapeProperty(elem, data);
        } else if (type === 6) {
          prop = new EllShapeProperty(elem, data);
        } else if (type === 7) {
          prop = new StarShapeProperty(elem, data);
        }
        if (prop.k) {
          elem.addDynamicProperty(prop);
        }
        return prop;
      }

      function getConstructorFunction() {
        return ShapeProperty;
      }

      function getKeyframedConstructorFunction() {
        return KeyframedShapeProperty;
      }

      var ob = {};
      ob.getShapeProp = getShapeProp;
      ob.getConstructorFunction = getConstructorFunction;
      ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
      return ob;
    }());

    /* global shapeCollectionPool, initialDefaultFrame, extendPrototype, DynamicPropertyContainer */
    /* exported ShapeModifiers */

    var ShapeModifiers = (function () {
      var ob = {};
      var modifiers = {};
      ob.registerModifier = registerModifier;
      ob.getModifier = getModifier;

      function registerModifier(nm, factory) {
        if (!modifiers[nm]) {
          modifiers[nm] = factory;
        }
      }

      function getModifier(nm, elem, data) {
        return new modifiers[nm](elem, data);
      }

      return ob;
    }());

    function ShapeModifier() {}
    ShapeModifier.prototype.initModifierProperties = function () {};
    ShapeModifier.prototype.addShapeToModifier = function () {};
    ShapeModifier.prototype.addShape = function (data) {
      if (!this.closed) {
        // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
        data.sh.container.addDynamicProperty(data.sh);
        var shapeData = { shape: data.sh, data: data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
        this.shapes.push(shapeData);
        this.addShapeToModifier(shapeData);
        if (this._isAnimated) {
          data.setAsAnimated();
        }
      }
    };
    ShapeModifier.prototype.init = function (elem, data) {
      this.shapes = [];
      this.elem = elem;
      this.initDynamicPropertyContainer(elem);
      this.initModifierProperties(elem, data);
      this.frameId = initialDefaultFrame;
      this.closed = false;
      this.k = false;
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };
    ShapeModifier.prototype.processKeys = function () {
      if (this.elem.globalData.frameId === this.frameId) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
    };

    extendPrototype([DynamicPropertyContainer], ShapeModifier);

    /* global extendPrototype, ShapeModifier, PropertyFactory, segmentsLengthPool, bez, shapePool, ShapeModifiers */

    function TrimModifier() {
    }
    extendPrototype([ShapeModifier], TrimModifier);
    TrimModifier.prototype.initModifierProperties = function (elem, data) {
      this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
      this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
      this.sValue = 0;
      this.eValue = 0;
      this.getValue = this.processKeys;
      this.m = data.m;
      this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    };

    TrimModifier.prototype.addShapeToModifier = function (shapeData) {
      shapeData.pathsData = [];
    };

    TrimModifier.prototype.calculateShapeEdges = function (s, e, shapeLength, addedLength, totalModifierLength) {
      var segments = [];
      if (e <= 1) {
        segments.push({
          s: s,
          e: e,
        });
      } else if (s >= 1) {
        segments.push({
          s: s - 1,
          e: e - 1,
        });
      } else {
        segments.push({
          s: s,
          e: 1,
        });
        segments.push({
          s: 0,
          e: e - 1,
        });
      }
      var shapeSegments = [];
      var i;
      var len = segments.length;
      var segmentOb;
      for (i = 0; i < len; i += 1) {
        segmentOb = segments[i];
        if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
          var shapeS;
          var shapeE;
          if (segmentOb.s * totalModifierLength <= addedLength) {
            shapeS = 0;
          } else {
            shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
          }
          if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
            shapeE = 1;
          } else {
            shapeE = ((segmentOb.e * totalModifierLength - addedLength) / shapeLength);
          }
          shapeSegments.push([shapeS, shapeE]);
        }
      }
      if (!shapeSegments.length) {
        shapeSegments.push([0, 0]);
      }
      return shapeSegments;
    };

    TrimModifier.prototype.releasePathsData = function (pathsData) {
      var i;
      var len = pathsData.length;
      for (i = 0; i < len; i += 1) {
        segmentsLengthPool.release(pathsData[i]);
      }
      pathsData.length = 0;
      return pathsData;
    };

    TrimModifier.prototype.processShapes = function (_isFirstFrame) {
      var s;
      var e;
      if (this._mdf || _isFirstFrame) {
        var o = (this.o.v % 360) / 360;
        if (o < 0) {
          o += 1;
        }
        if (this.s.v > 1) {
          s = 1 + o;
        } else if (this.s.v < 0) {
          s = 0 + o;
        } else {
          s = this.s.v + o;
        }
        if (this.e.v > 1) {
          e = 1 + o;
        } else if (this.e.v < 0) {
          e = 0 + o;
        } else {
          e = this.e.v + o;
        }

        if (s > e) {
          var _s = s;
          s = e;
          e = _s;
        }
        s = Math.round(s * 10000) * 0.0001;
        e = Math.round(e * 10000) * 0.0001;
        this.sValue = s;
        this.eValue = e;
      } else {
        s = this.sValue;
        e = this.eValue;
      }
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var pathsData;
      var pathData;
      var totalShapeLength;
      var totalModifierLength = 0;

      if (e === s) {
        for (i = 0; i < len; i += 1) {
          this.shapes[i].localShapeCollection.releaseShapes();
          this.shapes[i].shape._mdf = true;
          this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;
          if (this._mdf) {
            this.shapes[i].pathsData.length = 0;
          }
        }
      } else if (!((e === 1 && s === 0) || (e === 0 && s === 1))) {
        var segments = [];
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          // if shape hasn't changed and trim properties haven't changed, cached previous path can be used
          if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
            shapeData.shape.paths = shapeData.localShapeCollection;
          } else {
            shapePaths = shapeData.shape.paths;
            jLen = shapePaths._length;
            totalShapeLength = 0;
            if (!shapeData.shape._mdf && shapeData.pathsData.length) {
              totalShapeLength = shapeData.totalShapeLength;
            } else {
              pathsData = this.releasePathsData(shapeData.pathsData);
              for (j = 0; j < jLen; j += 1) {
                pathData = bez.getSegmentsLength(shapePaths.shapes[j]);
                pathsData.push(pathData);
                totalShapeLength += pathData.totalLength;
              }
              shapeData.totalShapeLength = totalShapeLength;
              shapeData.pathsData = pathsData;
            }

            totalModifierLength += totalShapeLength;
            shapeData.shape._mdf = true;
          }
        }
        var shapeS = s;
        var shapeE = e;
        var addedLength = 0;
        var edges;
        for (i = len - 1; i >= 0; i -= 1) {
          shapeData = this.shapes[i];
          if (shapeData.shape._mdf) {
            localShapeCollection = shapeData.localShapeCollection;
            localShapeCollection.releaseShapes();
            // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
            if (this.m === 2 && len > 1) {
              edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);
              addedLength += shapeData.totalShapeLength;
            } else {
              edges = [[shapeS, shapeE]];
            }
            jLen = edges.length;
            for (j = 0; j < jLen; j += 1) {
              shapeS = edges[j][0];
              shapeE = edges[j][1];
              segments.length = 0;
              if (shapeE <= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength * shapeE,
                });
              } else if (shapeS >= 1) {
                segments.push({
                  s: shapeData.totalShapeLength * (shapeS - 1),
                  e: shapeData.totalShapeLength * (shapeE - 1),
                });
              } else {
                segments.push({
                  s: shapeData.totalShapeLength * shapeS,
                  e: shapeData.totalShapeLength,
                });
                segments.push({
                  s: 0,
                  e: shapeData.totalShapeLength * (shapeE - 1),
                });
              }
              var newShapesData = this.addShapes(shapeData, segments[0]);
              if (segments[0].s !== segments[0].e) {
                if (segments.length > 1) {
                  var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                  if (lastShapeInCollection.c) {
                    var lastShape = newShapesData.pop();
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                  } else {
                    this.addPaths(newShapesData, localShapeCollection);
                    newShapesData = this.addShapes(shapeData, segments[1]);
                  }
                }
                this.addPaths(newShapesData, localShapeCollection);
              }
            }
            shapeData.shape.paths = localShapeCollection;
          }
        }
      } else if (this._mdf) {
        for (i = 0; i < len; i += 1) {
          // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
          // Don't remove this even if it's losing cached info.
          this.shapes[i].pathsData.length = 0;
          this.shapes[i].shape._mdf = true;
        }
      }
    };

    TrimModifier.prototype.addPaths = function (newPaths, localShapeCollection) {
      var i;
      var len = newPaths.length;
      for (i = 0; i < len; i += 1) {
        localShapeCollection.addShape(newPaths[i]);
      }
    };

    TrimModifier.prototype.addSegment = function (pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
      shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);
      shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);
      if (newShape) {
        shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);
      }
      shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);
    };

    TrimModifier.prototype.addSegmentFromArray = function (points, shapePath, pos, newShape) {
      shapePath.setXYAt(points[1], points[5], 'o', pos);
      shapePath.setXYAt(points[2], points[6], 'i', pos + 1);
      if (newShape) {
        shapePath.setXYAt(points[0], points[4], 'v', pos);
      }
      shapePath.setXYAt(points[3], points[7], 'v', pos + 1);
    };

    TrimModifier.prototype.addShapes = function (shapeData, shapeSegment, shapePath) {
      var pathsData = shapeData.pathsData;
      var shapePaths = shapeData.shape.paths.shapes;
      var i;
      var len = shapeData.shape.paths._length;
      var j;
      var jLen;
      var addedLength = 0;
      var currentLengthData;
      var segmentCount;
      var lengths;
      var segment;
      var shapes = [];
      var initPos;
      var newShape = true;
      if (!shapePath) {
        shapePath = shapePool.newElement();
        segmentCount = 0;
        initPos = 0;
      } else {
        segmentCount = shapePath._length;
        initPos = shapePath._length;
      }
      shapes.push(shapePath);
      for (i = 0; i < len; i += 1) {
        lengths = pathsData[i].lengths;
        shapePath.c = shapePaths[i].c;
        jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;
        for (j = 1; j < jLen; j += 1) {
          currentLengthData = lengths[j - 1];
          if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
            addedLength += currentLengthData.addedLength;
            shapePath.c = false;
          } else if (addedLength > shapeSegment.e) {
            shapePath.c = false;
            break;
          } else {
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
              // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
              newShape = false;
              shapePath.c = false;
            }
            addedLength += currentLengthData.addedLength;
            segmentCount += 1;
          }
        }
        if (shapePaths[i].c && lengths.length) {
          currentLengthData = lengths[j - 1];
          if (addedLength <= shapeSegment.e) {
            var segmentLength = lengths[j - 1].addedLength;
            if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
              this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);
              newShape = false;
            } else {
              segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);
              this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
              // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
              newShape = false;
              shapePath.c = false;
            }
          } else {
            shapePath.c = false;
          }
          addedLength += currentLengthData.addedLength;
          segmentCount += 1;
        }
        if (shapePath._length) {
          shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);
          shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);
        }
        if (addedLength > shapeSegment.e) {
          break;
        }
        if (i < len - 1) {
          shapePath = shapePool.newElement();
          newShape = true;
          shapes.push(shapePath);
          segmentCount = 0;
        }
      }
      return shapes;
    };

    ShapeModifiers.registerModifier('tm', TrimModifier);

    /* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, roundCorner, ShapeModifiers */

    function RoundCornersModifier() {}
    extendPrototype([ShapeModifier], RoundCornersModifier);
    RoundCornersModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
      this._isAnimated = !!this.rd.effectsSequence.length;
    };

    RoundCornersModifier.prototype.processPath = function (path, round) {
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var i;
      var len = path._length;
      var currentV;
      var currentI;
      var currentO;
      var closerV;
      var distance;
      var newPosPerc;
      var index = 0;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < len; i += 1) {
        currentV = path.v[i];
        currentO = path.o[i];
        currentI = path.i[i];
        if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
          if ((i === 0 || i === len - 1) && !path.c) {
            clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);
            /* clonedPath.v[index] = currentV;
                    clonedPath.o[index] = currentO;
                    clonedPath.i[index] = currentI; */
            index += 1;
          } else {
            if (i === 0) {
              closerV = path.v[len - 1];
            } else {
              closerV = path.v[i - 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
            iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = iX;
            iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
            vY = iY;
            oX = vX - (vX - currentV[0]) * roundCorner;
            oY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
            index += 1;

            if (i === len - 1) {
              closerV = path.v[0];
            } else {
              closerV = path.v[i + 1];
            }
            distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
            newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
            oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
            vX = oX;
            oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
            vY = oY;
            iX = vX - (vX - currentV[0]) * roundCorner;
            iY = vY - (vY - currentV[1]) * roundCorner;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);
            index += 1;
          }
        } else {
          clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);
          index += 1;
        }
      }
      return clonedPath;
    };

    RoundCornersModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var rd = this.rd.v;

      if (rd !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], rd));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };

    ShapeModifiers.registerModifier('rd', RoundCornersModifier);

    /* global extendPrototype, ShapeModifier, PropertyFactory, shapePool, ShapeModifiers */

    function PuckerAndBloatModifier() {}
    extendPrototype([ShapeModifier], PuckerAndBloatModifier);
    PuckerAndBloatModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
      this._isAnimated = !!this.amount.effectsSequence.length;
    };

    PuckerAndBloatModifier.prototype.processPath = function (path, amount) {
      var percent = amount / 100;
      var centerPoint = [0, 0];
      var pathLength = path._length;
      var i = 0;
      for (i = 0; i < pathLength; i += 1) {
        centerPoint[0] += path.v[i][0];
        centerPoint[1] += path.v[i][1];
      }
      centerPoint[0] /= pathLength;
      centerPoint[1] /= pathLength;
      var clonedPath = shapePool.newElement();
      clonedPath.c = path.c;
      var vX;
      var vY;
      var oX;
      var oY;
      var iX;
      var iY;
      for (i = 0; i < pathLength; i += 1) {
        vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;
        vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;
        oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;
        oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;
        iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;
        iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;
        clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);
      }
      return clonedPath;
    };

    PuckerAndBloatModifier.prototype.processShapes = function (_isFirstFrame) {
      var shapePaths;
      var i;
      var len = this.shapes.length;
      var j;
      var jLen;
      var amount = this.amount.v;

      if (amount !== 0) {
        var shapeData;
        var localShapeCollection;
        for (i = 0; i < len; i += 1) {
          shapeData = this.shapes[i];
          localShapeCollection = shapeData.localShapeCollection;
          if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
            localShapeCollection.releaseShapes();
            shapeData.shape._mdf = true;
            shapePaths = shapeData.shape.paths.shapes;
            jLen = shapeData.shape.paths._length;
            for (j = 0; j < jLen; j += 1) {
              localShapeCollection.addShape(this.processPath(shapePaths[j], amount));
            }
          }
          shapeData.shape.paths = shapeData.localShapeCollection;
        }
      }
      if (!this.dynamicProperties.length) {
        this._mdf = false;
      }
    };
    ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);

    /* global extendPrototype, ShapeModifier, TransformPropertyFactory, PropertyFactory, Matrix, ShapeModifiers */

    function RepeaterModifier() {}
    extendPrototype([ShapeModifier], RepeaterModifier);

    RepeaterModifier.prototype.initModifierProperties = function (elem, data) {
      this.getValue = this.processKeys;
      this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
      this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
      this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
      this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
      this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
      this.data = data;
      if (!this.dynamicProperties.length) {
        this.getValue(true);
      }
      this._isAnimated = !!this.dynamicProperties.length;
      this.pMatrix = new Matrix();
      this.rMatrix = new Matrix();
      this.sMatrix = new Matrix();
      this.tMatrix = new Matrix();
      this.matrix = new Matrix();
    };

    RepeaterModifier.prototype.applyTransforms = function (pMatrix, rMatrix, sMatrix, transform, perc, inv) {
      var dir = inv ? -1 : 1;
      var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
      var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
      pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
      rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
      rMatrix.rotate(-transform.r.v * dir * perc);
      rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
      sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
      sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
      sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
    };

    RepeaterModifier.prototype.init = function (elem, arr, pos, elemsData) {
      this.elem = elem;
      this.arr = arr;
      this.pos = pos;
      this.elemsData = elemsData;
      this._currentCopies = 0;
      this._elements = [];
      this._groups = [];
      this.frameId = -1;
      this.initDynamicPropertyContainer(elem);
      this.initModifierProperties(elem, arr[pos]);
      while (pos > 0) {
        pos -= 1;
        // this._elements.unshift(arr.splice(pos,1)[0]);
        this._elements.unshift(arr[pos]);
      }
      if (this.dynamicProperties.length) {
        this.k = true;
      } else {
        this.getValue(true);
      }
    };

    RepeaterModifier.prototype.resetElements = function (elements) {
      var i;
      var len = elements.length;
      for (i = 0; i < len; i += 1) {
        elements[i]._processed = false;
        if (elements[i].ty === 'gr') {
          this.resetElements(elements[i].it);
        }
      }
    };

    RepeaterModifier.prototype.cloneElements = function (elements) {
      var newElements = JSON.parse(JSON.stringify(elements));
      this.resetElements(newElements);
      return newElements;
    };

    RepeaterModifier.prototype.changeGroupRender = function (elements, renderFlag) {
      var i;
      var len = elements.length;
      for (i = 0; i < len; i += 1) {
        elements[i]._render = renderFlag;
        if (elements[i].ty === 'gr') {
          this.changeGroupRender(elements[i].it, renderFlag);
        }
      }
    };

    RepeaterModifier.prototype.processShapes = function (_isFirstFrame) {
      var items;
      var itemsTransform;
      var i;
      var dir;
      var cont;
      var hasReloaded = false;
      if (this._mdf || _isFirstFrame) {
        var copies = Math.ceil(this.c.v);
        if (this._groups.length < copies) {
          while (this._groups.length < copies) {
            var group = {
              it: this.cloneElements(this._elements),
              ty: 'gr',
            };
            group.it.push({
              a: { a: 0, ix: 1, k: [0, 0] }, nm: 'Transform', o: { a: 0, ix: 7, k: 100 }, p: { a: 0, ix: 2, k: [0, 0] }, r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] }, s: { a: 0, ix: 3, k: [100, 100] }, sa: { a: 0, ix: 5, k: 0 }, sk: { a: 0, ix: 4, k: 0 }, ty: 'tr',
            });

            this.arr.splice(0, 0, group);
            this._groups.splice(0, 0, group);
            this._currentCopies += 1;
          }
          this.elem.reloadShapes();
          hasReloaded = true;
        }
        cont = 0;
        var renderFlag;
        for (i = 0; i <= this._groups.length - 1; i += 1) {
          renderFlag = cont < copies;
          this._groups[i]._render = renderFlag;
          this.changeGroupRender(this._groups[i].it, renderFlag);
          if (!renderFlag) {
            var elems = this.elemsData[i].it;
            var transformData = elems[elems.length - 1];
            if (transformData.transform.op.v !== 0) {
              transformData.transform.op._mdf = true;
              transformData.transform.op.v = 0;
            } else {
              transformData.transform.op._mdf = false;
            }
          }
          cont += 1;
        }

        this._currentCopies = copies;
        /// /

        var offset = this.o.v;
        var offsetModulo = offset % 1;
        var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
        var pProps = this.pMatrix.props;
        var rProps = this.rMatrix.props;
        var sProps = this.sMatrix.props;
        this.pMatrix.reset();
        this.rMatrix.reset();
        this.sMatrix.reset();
        this.tMatrix.reset();
        this.matrix.reset();
        var iteration = 0;

        if (offset > 0) {
          while (iteration < roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            iteration += 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
            iteration += offsetModulo;
          }
        } else if (offset < 0) {
          while (iteration > roundOffset) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
            iteration -= 1;
          }
          if (offsetModulo) {
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
            iteration -= offsetModulo;
          }
        }
        i = this.data.m === 1 ? 0 : this._currentCopies - 1;
        dir = this.data.m === 1 ? 1 : -1;
        cont = this._currentCopies;
        var j;
        var jLen;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          jLen = itemsTransform.length;
          items[items.length - 1].transform.mProps._mdf = true;
          items[items.length - 1].transform.op._mdf = true;
          items[items.length - 1].transform.op.v = this._currentCopies === 1
            ? this.so.v
            : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));

          if (iteration !== 0) {
            if ((i !== 0 && dir === 1) || (i !== this._currentCopies - 1 && dir === -1)) {
              this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
            }
            this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
            this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
            this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);

            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
            this.matrix.reset();
          } else {
            this.matrix.reset();
            for (j = 0; j < jLen; j += 1) {
              itemsTransform[j] = this.matrix.props[j];
            }
          }
          iteration += 1;
          cont -= 1;
          i += dir;
        }
      } else {
        cont = this._currentCopies;
        i = 0;
        dir = 1;
        while (cont) {
          items = this.elemsData[i].it;
          itemsTransform = items[items.length - 1].transform.mProps.v.props;
          items[items.length - 1].transform.mProps._mdf = false;
          items[items.length - 1].transform.op._mdf = false;
          cont -= 1;
          i += dir;
        }
      }
      return hasReloaded;
    };

    RepeaterModifier.prototype.addShape = function () {};

    ShapeModifiers.registerModifier('rp', RepeaterModifier);

    /* global createSizedArray, shapePool */

    function ShapeCollection() {
      this._length = 0;
      this._maxLength = 4;
      this.shapes = createSizedArray(this._maxLength);
    }

    ShapeCollection.prototype.addShape = function (shapeData) {
      if (this._length === this._maxLength) {
        this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
        this._maxLength *= 2;
      }
      this.shapes[this._length] = shapeData;
      this._length += 1;
    };

    ShapeCollection.prototype.releaseShapes = function () {
      var i;
      for (i = 0; i < this._length; i += 1) {
        shapePool.release(this.shapes[i]);
      }
      this._length = 0;
    };

    /* global createSizedArray, createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */

    function DashProperty(elem, data, renderer, container) {
      this.elem = elem;
      this.frameId = -1;
      this.dataProps = createSizedArray(data.length);
      this.renderer = renderer;
      this.k = false;
      this.dashStr = '';
      this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);
      this.dashoffset = createTypedArray('float32', 1);
      this.initDynamicPropertyContainer(container);
      var i;
      var len = data.length || 0;
      var prop;
      for (i = 0; i < len; i += 1) {
        prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);
        this.k = prop.k || this.k;
        this.dataProps[i] = { n: data[i].n, p: prop };
      }
      if (!this.k) {
        this.getValue(true);
      }
      this._isAnimated = this.k;
    }

    DashProperty.prototype.getValue = function (forceRender) {
      if (this.elem.globalData.frameId === this.frameId && !forceRender) {
        return;
      }
      this.frameId = this.elem.globalData.frameId;
      this.iterateDynamicProperties();
      this._mdf = this._mdf || forceRender;
      if (this._mdf) {
        var i = 0;
        var len = this.dataProps.length;
        if (this.renderer === 'svg') {
          this.dashStr = '';
        }
        for (i = 0; i < len; i += 1) {
          if (this.dataProps[i].n !== 'o') {
            if (this.renderer === 'svg') {
              this.dashStr += ' ' + this.dataProps[i].p.v;
            } else {
              this.dashArray[i] = this.dataProps[i].p.v;
            }
          } else {
            this.dashoffset[0] = this.dataProps[i].p.v;
          }
        }
      }
    };
    extendPrototype([DynamicPropertyContainer], DashProperty);

    /* global createTypedArray, PropertyFactory, extendPrototype, DynamicPropertyContainer */
    function GradientProperty(elem, data, container) {
      this.data = data;
      this.c = createTypedArray('uint8c', data.p * 4);
      var cLength = data.k.k[0].s ? (data.k.k[0].s.length - data.p * 4) : data.k.k.length - data.p * 4;
      this.o = createTypedArray('float32', cLength);
      this._cmdf = false;
      this._omdf = false;
      this._collapsable = this.checkCollapsable();
      this._hasOpacity = cLength;
      this.initDynamicPropertyContainer(container);
      this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
      this.k = this.prop.k;
      this.getValue(true);
    }

    GradientProperty.prototype.comparePoints = function (values, points) {
      var i = 0;
      var len = this.o.length / 2;
      var diff;
      while (i < len) {
        diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);
        if (diff > 0.01) {
          return false;
        }
        i += 1;
      }
      return true;
    };

    GradientProperty.prototype.checkCollapsable = function () {
      if (this.o.length / 2 !== this.c.length / 4) {
        return false;
      }
      if (this.data.k.k[0].s) {
        var i = 0;
        var len = this.data.k.k.length;
        while (i < len) {
          if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {
            return false;
          }
          i += 1;
        }
      } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
        return false;
      }
      return true;
    };

    GradientProperty.prototype.getValue = function (forceRender) {
      this.prop.getValue();
      this._mdf = false;
      this._cmdf = false;
      this._omdf = false;
      if (this.prop._mdf || forceRender) {
        var i;
        var len = this.data.p * 4;
        var mult;
        var val;
        for (i = 0; i < len; i += 1) {
          mult = i % 4 === 0 ? 100 : 255;
          val = Math.round(this.prop.v[i] * mult);
          if (this.c[i] !== val) {
            this.c[i] = val;
            this._cmdf = !forceRender;
          }
        }
        if (this.o.length) {
          len = this.prop.v.length;
          for (i = this.data.p * 4; i < len; i += 1) {
            mult = i % 2 === 0 ? 100 : 1;
            val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];
            if (this.o[i - this.data.p * 4] !== val) {
              this.o[i - this.data.p * 4] = val;
              this._omdf = !forceRender;
            }
          }
        }
        this._mdf = !forceRender;
      }
    };

    extendPrototype([DynamicPropertyContainer], GradientProperty);

    /* exported buildShapeString */

    var buildShapeString = function (pathNodes, length, closed, mat) {
      if (length === 0) {
        return '';
      }
      var _o = pathNodes.o;
      var _i = pathNodes.i;
      var _v = pathNodes.v;
      var i;
      var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
      for (i = 1; i < length; i += 1) {
        shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);
      }
      if (closed && length) {
        shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);
        shapeString += 'z';
      }
      return shapeString;
    };

    /* global Howl */
    /* exported audioControllerFactory */

    var audioControllerFactory = (function () {
      function AudioController(audioFactory) {
        this.audios = [];
        this.audioFactory = audioFactory;
        this._volume = 1;
        this._isMuted = false;
      }

      AudioController.prototype = {
        addAudio: function (audio) {
          this.audios.push(audio);
        },
        pause: function () {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].pause();
          }
        },
        resume: function () {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].resume();
          }
        },
        setRate: function (rateValue) {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].setRate(rateValue);
          }
        },
        createAudio: function (assetPath) {
          if (this.audioFactory) {
            return this.audioFactory(assetPath);
          } if (Howl) {
            return new Howl({
              src: [assetPath],
            });
          }
          return {
            isPlaying: false,
            play: function () { this.isPlaying = true; },
            seek: function () { this.isPlaying = false; },
            playing: function () {},
            rate: function () {},
            setVolume: function () {},
          };
        },
        setAudioFactory: function (audioFactory) {
          this.audioFactory = audioFactory;
        },
        setVolume: function (value) {
          this._volume = value;
          this._updateVolume();
        },
        mute: function () {
          this._isMuted = true;
          this._updateVolume();
        },
        unmute: function () {
          this._isMuted = false;
          this._updateVolume();
        },
        getVolume: function () {
          return this._volume;
        },
        _updateVolume: function () {
          var i;
          var len = this.audios.length;
          for (i = 0; i < len; i += 1) {
            this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));
          }
        },
      };

      return function () {
        return new AudioController();
      };
    }());

    /* global createTag, createNS, isSafari, dataManager */
    /* exported ImagePreloader */

    var ImagePreloader = (function () {
      var proxyImage = (function () {
        var canvas = createTag('canvas');
        canvas.width = 1;
        canvas.height = 1;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = 'rgba(0,0,0,0)';
        ctx.fillRect(0, 0, 1, 1);
        return canvas;
      }());

      function imageLoaded() {
        this.loadedAssets += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }
      function footageLoaded() {
        this.loadedFootagesCount += 1;
        if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
          if (this.imagesLoadedCb) {
            this.imagesLoadedCb(null);
          }
        }
      }

      function getAssetsPath(assetData, assetsPath, originalPath) {
        var path = '';
        if (assetData.e) {
          path = assetData.p;
        } else if (assetsPath) {
          var imagePath = assetData.p;
          if (imagePath.indexOf('images/') !== -1) {
            imagePath = imagePath.split('/')[1];
          }
          path = assetsPath + imagePath;
        } else {
          path = originalPath;
          path += assetData.u ? assetData.u : '';
          path += assetData.p;
        }
        return path;
      }

      function testImageLoaded(img) {
        var _count = 0;
        var intervalId = setInterval(function () {
          var box = img.getBBox();
          if (box.width || _count > 500) {
            this._imageLoaded();
            clearInterval(intervalId);
          }
          _count += 1;
        }.bind(this), 50);
      }

      function createImageData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createNS('image');
        if (isSafari) {
          this.testImageLoaded(img);
        } else {
          img.addEventListener('load', this._imageLoaded, false);
        }
        img.addEventListener('error', function () {
          ob.img = proxyImage;
          this._imageLoaded();
        }.bind(this), false);
        img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);
        if (this._elementHelper.append) {
          this._elementHelper.append(img);
        } else {
          this._elementHelper.appendChild(img);
        }
        var ob = {
          img: img,
          assetData: assetData,
        };
        return ob;
      }

      function createImgData(assetData) {
        var path = getAssetsPath(assetData, this.assetsPath, this.path);
        var img = createTag('img');
        img.crossOrigin = 'anonymous';
        img.addEventListener('load', this._imageLoaded, false);
        img.addEventListener('error', function () {
          ob.img = proxyImage;
          this._imageLoaded();
        }.bind(this), false);
        img.src = path;
        var ob = {
          img: img,
          assetData: assetData,
        };
        return ob;
      }

      function createFootageData(data) {
        var ob = {
          assetData: data,
        };
        var path = getAssetsPath(data, this.assetsPath, this.path);
        dataManager.loadData(path, function (footageData) {
          ob.img = footageData;
          this._footageLoaded();
        }.bind(this), function () {
          ob.img = {};
          this._footageLoaded();
        }.bind(this));
        return ob;
      }

      function loadAssets(assets, cb) {
        this.imagesLoadedCb = cb;
        var i;
        var len = assets.length;
        for (i = 0; i < len; i += 1) {
          if (!assets[i].layers) {
            if (!assets[i].t || assets[i].t === 'seq') {
              this.totalImages += 1;
              this.images.push(this._createImageData(assets[i]));
            } else if (assets[i].t === 3) {
              this.totalFootages += 1;
              this.images.push(this.createFootageData(assets[i]));
            }
          }
        }
      }

      function setPath(path) {
        this.path = path || '';
      }

      function setAssetsPath(path) {
        this.assetsPath = path || '';
      }

      function getAsset(assetData) {
        var i = 0;
        var len = this.images.length;
        while (i < len) {
          if (this.images[i].assetData === assetData) {
            return this.images[i].img;
          }
          i += 1;
        }
        return null;
      }

      function destroy() {
        this.imagesLoadedCb = null;
        this.images.length = 0;
      }

      function loadedImages() {
        return this.totalImages === this.loadedAssets;
      }

      function loadedFootages() {
        return this.totalFootages === this.loadedFootagesCount;
      }

      function setCacheType(type, elementHelper) {
        if (type === 'svg') {
          this._elementHelper = elementHelper;
          this._createImageData = this.createImageData.bind(this);
        } else {
          this._createImageData = this.createImgData.bind(this);
        }
      }

      function ImagePreloaderFactory() {
        this._imageLoaded = imageLoaded.bind(this);
        this._footageLoaded = footageLoaded.bind(this);
        this.testImageLoaded = testImageLoaded.bind(this);
        this.createFootageData = createFootageData.bind(this);
        this.assetsPath = '';
        this.path = '';
        this.totalImages = 0;
        this.totalFootages = 0;
        this.loadedAssets = 0;
        this.loadedFootagesCount = 0;
        this.imagesLoadedCb = null;
        this.images = [];
      }

      ImagePreloaderFactory.prototype = {
        loadAssets: loadAssets,
        setAssetsPath: setAssetsPath,
        setPath: setPath,
        loadedImages: loadedImages,
        loadedFootages: loadedFootages,
        destroy: destroy,
        getAsset: getAsset,
        createImgData: createImgData,
        createImageData: createImageData,
        imageLoaded: imageLoaded,
        footageLoaded: footageLoaded,
        setCacheType: setCacheType,
      };

      return ImagePreloaderFactory;
    }());

    /* exported featureSupport */

    var featureSupport = (function () {
      var ob = {
        maskType: true,
      };
      if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
        ob.maskType = false;
      }
      return ob;
    }());

    /* global createNS */
    /* exported filtersFactory */

    var filtersFactory = (function () {
      var ob = {};
      ob.createFilter = createFilter;
      ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;

      function createFilter(filId, skipCoordinates) {
        var fil = createNS('filter');
        fil.setAttribute('id', filId);
        if (skipCoordinates !== true) {
          fil.setAttribute('filterUnits', 'objectBoundingBox');
          fil.setAttribute('x', '0%');
          fil.setAttribute('y', '0%');
          fil.setAttribute('width', '100%');
          fil.setAttribute('height', '100%');
        }
        return fil;
      }

      function createAlphaToLuminanceFilter() {
        var feColorMatrix = createNS('feColorMatrix');
        feColorMatrix.setAttribute('type', 'matrix');
        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
        feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');
        return feColorMatrix;
      }

      return ob;
    }());

    /* global createSizedArray, PropertyFactory, TextAnimatorDataProperty, bez, addHueToRGB,
      addSaturationToRGB, addBrightnessToRGB, LetterProps, Matrix, extendPrototype, DynamicPropertyContainer */

    function TextAnimatorProperty(textData, renderType, elem) {
      this._isFirstFrame = true;
      this._hasMaskedPath = false;
      this._frameId = -1;
      this._textData = textData;
      this._renderType = renderType;
      this._elem = elem;
      this._animatorsData = createSizedArray(this._textData.a.length);
      this._pathData = {};
      this._moreOptions = {
        alignment: {},
      };
      this.renderedLetters = [];
      this.lettersChangedFlag = false;
      this.initDynamicPropertyContainer(elem);
    }

    TextAnimatorProperty.prototype.searchProperties = function () {
      var i;
      var len = this._textData.a.length;
      var animatorProps;
      var getProp = PropertyFactory.getProp;
      for (i = 0; i < len; i += 1) {
        animatorProps = this._textData.a[i];
        this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
      }
      if (this._textData.p && 'm' in this._textData.p) {
        this._pathData = {
          a: getProp(this._elem, this._textData.p.a, 0, 0, this),
          f: getProp(this._elem, this._textData.p.f, 0, 0, this),
          l: getProp(this._elem, this._textData.p.l, 0, 0, this),
          r: getProp(this._elem, this._textData.p.r, 0, 0, this),
          p: getProp(this._elem, this._textData.p.p, 0, 0, this),
          m: this._elem.maskManager.getMaskProperty(this._textData.p.m),
        };
        this._hasMaskedPath = true;
      } else {
        this._hasMaskedPath = false;
      }
      this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
    };

    TextAnimatorProperty.prototype.getMeasures = function (documentData, lettersChangedFlag) {
      this.lettersChangedFlag = lettersChangedFlag;
      if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
        return;
      }
      this._isFirstFrame = false;
      var alignment = this._moreOptions.alignment.v;
      var animators = this._animatorsData;
      var textData = this._textData;
      var matrixHelper = this.mHelper;
      var renderType = this._renderType;
      var renderedLettersCount = this.renderedLetters.length;
      var xPos;
      var yPos;
      var i;
      var len;
      var letters = documentData.l;
      var pathInfo;
      var currentLength;
      var currentPoint;
      var segmentLength;
      var flag;
      var pointInd;
      var segmentInd;
      var prevPoint;
      var points;
      var segments;
      var partialLength;
      var totalLength;
      var perc;
      var tanAngle;
      var mask;
      if (this._hasMaskedPath) {
        mask = this._pathData.m;
        if (!this._pathData.n || this._pathData._mdf) {
          var paths = mask.v;
          if (this._pathData.r.v) {
            paths = paths.reverse();
          }
          // TODO: release bezier data cached from previous pathInfo: this._pathData.pi
          pathInfo = {
            tLength: 0,
            segments: [],
          };
          len = paths._length - 1;
          var bezierData;
          totalLength = 0;
          for (i = 0; i < len; i += 1) {
            bezierData = bez.buildBezierData(paths.v[i],
              paths.v[i + 1],
              [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
              [paths.i[i + 1][0] - paths.v[i + 1][0], paths.i[i + 1][1] - paths.v[i + 1][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          i = len;
          if (mask.v.c) {
            bezierData = bez.buildBezierData(paths.v[i],
              paths.v[0],
              [paths.o[i][0] - paths.v[i][0], paths.o[i][1] - paths.v[i][1]],
              [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]);
            pathInfo.tLength += bezierData.segmentLength;
            pathInfo.segments.push(bezierData);
            totalLength += bezierData.segmentLength;
          }
          this._pathData.pi = pathInfo;
        }
        pathInfo = this._pathData.pi;

        currentLength = this._pathData.f.v;
        segmentInd = 0;
        pointInd = 1;
        segmentLength = 0;
        flag = true;
        segments = pathInfo.segments;
        if (currentLength < 0 && mask.v.c) {
          if (pathInfo.tLength < Math.abs(currentLength)) {
            currentLength = -Math.abs(currentLength) % pathInfo.tLength;
          }
          segmentInd = segments.length - 1;
          points = segments[segmentInd].points;
          pointInd = points.length - 1;
          while (currentLength < 0) {
            currentLength += points[pointInd].partialLength;
            pointInd -= 1;
            if (pointInd < 0) {
              segmentInd -= 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
            }
          }
        }
        points = segments[segmentInd].points;
        prevPoint = points[pointInd - 1];
        currentPoint = points[pointInd];
        partialLength = currentPoint.partialLength;
      }

      len = letters.length;
      xPos = 0;
      yPos = 0;
      var yOff = documentData.finalSize * 1.2 * 0.714;
      var firstLine = true;
      var animatorProps;
      var animatorSelector;
      var j;
      var jLen;
      var letterValue;

      jLen = animators.length;

      var mult;
      var ind = -1;
      var offf;
      var xPathPos;
      var yPathPos;
      var initPathPos = currentLength;
      var initSegmentInd = segmentInd;
      var initPointInd = pointInd;
      var currentLine = -1;
      var elemOpacity;
      var sc;
      var sw;
      var fc;
      var k;
      var letterSw;
      var letterSc;
      var letterFc;
      var letterM = '';
      var letterP = this.defaultPropsArray;
      var letterO;

      //
      if (documentData.j === 2 || documentData.j === 1) {
        var animatorJustifyOffset = 0;
        var animatorFirstCharOffset = 0;
        var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
        var lastIndex = 0;
        var isNewLine = true;

        for (i = 0; i < len; i += 1) {
          if (letters[i].n) {
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
            animatorJustifyOffset = 0;
            isNewLine = true;
          } else {
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.t.propType) {
                if (isNewLine && documentData.j === 2) {
                  animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                }
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                } else {
                  animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                }
              }
            }
            isNewLine = false;
          }
        }
        if (animatorJustifyOffset) {
          animatorJustifyOffset += animatorFirstCharOffset;
        }
        while (lastIndex < i) {
          letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
          lastIndex += 1;
        }
      }
      //

      for (i = 0; i < len; i += 1) {
        matrixHelper.reset();
        elemOpacity = 1;
        if (letters[i].n) {
          xPos = 0;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          currentLength = initPathPos;
          firstLine = false;
          if (this._hasMaskedPath) {
            segmentInd = initSegmentInd;
            pointInd = initPointInd;
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
            segmentLength = 0;
          }
          letterM = '';
          letterFc = '';
          letterSw = '';
          letterO = '';
          letterP = this.defaultPropsArray;
        } else {
          if (this._hasMaskedPath) {
            if (currentLine !== letters[i].line) {
              switch (documentData.j) {
                case 1:
                  currentLength += totalLength - documentData.lineWidths[letters[i].line];
                  break;
                case 2:
                  currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;
                  break;
              }
              currentLine = letters[i].line;
            }
            if (ind !== letters[i].ind) {
              if (letters[ind]) {
                currentLength += letters[ind].extra;
              }
              currentLength += letters[i].an / 2;
              ind = letters[i].ind;
            }
            currentLength += (alignment[0] * letters[i].an) * 0.005;
            var animatorOffset = 0;
            for (j = 0; j < jLen; j += 1) {
              animatorProps = animators[j].a;
              if (animatorProps.p.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.p.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.p.v[0] * mult;
                }
              }
              if (animatorProps.a.propType) {
                animatorSelector = animators[j].s;
                mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
                if (mult.length) {
                  animatorOffset += animatorProps.a.v[0] * mult[0];
                } else {
                  animatorOffset += animatorProps.a.v[0] * mult;
                }
              }
            }
            flag = true;
            // Force alignment only works with a single line for now
            if (this._pathData.a.v) {
              currentLength = letters[0].an * 0.5 + ((totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind) / (len - 1);
              currentLength += this._pathData.f.v;
            }
            while (flag) {
              if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, -(alignment[1] * yOff) * 0.01);
                flag = false;
              } else if (points) {
                segmentLength += currentPoint.partialLength;
                pointInd += 1;
                if (pointInd >= points.length) {
                  pointInd = 0;
                  segmentInd += 1;
                  if (!segments[segmentInd]) {
                    if (mask.v.c) {
                      pointInd = 0;
                      segmentInd = 0;
                      points = segments[segmentInd].points;
                    } else {
                      segmentLength -= currentPoint.partialLength;
                      points = null;
                    }
                  } else {
                    points = segments[segmentInd].points;
                  }
                }
                if (points) {
                  prevPoint = currentPoint;
                  currentPoint = points[pointInd];
                  partialLength = currentPoint.partialLength;
                }
              }
            }
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0);
          } else {
            offf = letters[i].an / 2 - letters[i].add;
            matrixHelper.translate(-offf, 0, 0);

            // Grouping alignment
            matrixHelper.translate((-alignment[0] * letters[i].an) * 0.005, (-alignment[1] * yOff) * 0.01, 0);
          }

          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.t.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
              if (xPos !== 0 || documentData.j !== 0) {
                if (this._hasMaskedPath) {
                  if (mult.length) {
                    currentLength += animatorProps.t.v * mult[0];
                  } else {
                    currentLength += animatorProps.t.v * mult;
                  }
                } else if (mult.length) {
                  xPos += animatorProps.t.v * mult[0];
                } else {
                  xPos += animatorProps.t.v * mult;
                }
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            sw = documentData.sw || 0;
          }
          if (documentData.strokeColorAnim) {
            if (documentData.sc) {
              sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
            } else {
              sc = [0, 0, 0];
            }
          }
          if (documentData.fillColorAnim && documentData.fc) {
            fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.a.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);

              if (mult.length) {
                matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
              } else {
                matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            if (animatorProps.s.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (mult.length) {
                matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult[0]), 1 + ((animatorProps.s.v[1] - 1) * mult[1]), 1);
              } else {
                matrixHelper.scale(1 + ((animatorProps.s.v[0] - 1) * mult), 1 + ((animatorProps.s.v[1] - 1) * mult), 1);
              }
            }
          }
          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;
            animatorSelector = animators[j].s;
            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
            if (animatorProps.sk.propType) {
              if (mult.length) {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
              } else {
                matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
              }
            }
            if (animatorProps.r.propType) {
              if (mult.length) {
                matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
              } else {
                matrixHelper.rotateZ(-animatorProps.r.v * mult);
              }
            }
            if (animatorProps.ry.propType) {
              if (mult.length) {
                matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
              } else {
                matrixHelper.rotateY(animatorProps.ry.v * mult);
              }
            }
            if (animatorProps.rx.propType) {
              if (mult.length) {
                matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
              } else {
                matrixHelper.rotateX(animatorProps.rx.v * mult);
              }
            }
            if (animatorProps.o.propType) {
              if (mult.length) {
                elemOpacity += ((animatorProps.o.v) * mult[0] - elemOpacity) * mult[0];
              } else {
                elemOpacity += ((animatorProps.o.v) * mult - elemOpacity) * mult;
              }
            }
            if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
              if (mult.length) {
                sw += animatorProps.sw.v * mult[0];
              } else {
                sw += animatorProps.sw.v * mult;
              }
            }
            if (documentData.strokeColorAnim && animatorProps.sc.propType) {
              for (k = 0; k < 3; k += 1) {
                if (mult.length) {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];
                } else {
                  sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;
                }
              }
            }
            if (documentData.fillColorAnim && documentData.fc) {
              if (animatorProps.fc.propType) {
                for (k = 0; k < 3; k += 1) {
                  if (mult.length) {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];
                  } else {
                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;
                  }
                }
              }
              if (animatorProps.fh.propType) {
                if (mult.length) {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                } else {
                  fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                }
              }
              if (animatorProps.fs.propType) {
                if (mult.length) {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                } else {
                  fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                }
              }
              if (animatorProps.fb.propType) {
                if (mult.length) {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                } else {
                  fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                }
              }
            }
          }

          for (j = 0; j < jLen; j += 1) {
            animatorProps = animators[j].a;

            if (animatorProps.p.propType) {
              animatorSelector = animators[j].s;
              mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);
              if (this._hasMaskedPath) {
                if (mult.length) {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                } else {
                  matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                }
              } else if (mult.length) {
                matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
              } else {
                matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
              }
            }
          }
          if (documentData.strokeWidthAnim) {
            letterSw = sw < 0 ? 0 : sw;
          }
          if (documentData.strokeColorAnim) {
            letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';
          }
          if (documentData.fillColorAnim && documentData.fc) {
            letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';
          }

          if (this._hasMaskedPath) {
            matrixHelper.translate(0, -documentData.ls);

            matrixHelper.translate(0, (alignment[1] * yOff) * 0.01 + yPos, 0);
            if (this._pathData.p.v) {
              tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
              var rot = (Math.atan(tanAngle) * 180) / Math.PI;
              if (currentPoint.point[0] < prevPoint.point[0]) {
                rot += 180;
              }
              matrixHelper.rotate((-rot * Math.PI) / 180);
            }
            matrixHelper.translate(xPathPos, yPathPos, 0);
            currentLength -= (alignment[0] * letters[i].an) * 0.005;
            if (letters[i + 1] && ind !== letters[i + 1].ind) {
              currentLength += letters[i].an / 2;
              currentLength += (documentData.tr * 0.001) * documentData.finalSize;
            }
          } else {
            matrixHelper.translate(xPos, yPos, 0);

            if (documentData.ps) {
              // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
              matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
            }
            switch (documentData.j) {
              case 1:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);
                break;
              case 2:
                matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);
                break;
            }
            matrixHelper.translate(0, -documentData.ls);
            matrixHelper.translate(offf, 0, 0);
            matrixHelper.translate((alignment[0] * letters[i].an) * 0.005, (alignment[1] * yOff) * 0.01, 0);
            xPos += letters[i].l + (documentData.tr * 0.001) * documentData.finalSize;
          }
          if (renderType === 'html') {
            letterM = matrixHelper.toCSS();
          } else if (renderType === 'svg') {
            letterM = matrixHelper.to2dCSS();
          } else {
            letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
          }
          letterO = elemOpacity;
        }

        if (renderedLettersCount <= i) {
          letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
          this.renderedLetters.push(letterValue);
          renderedLettersCount += 1;
          this.lettersChangedFlag = true;
        } else {
          letterValue = this.renderedLetters[i];
          this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
        }
      }
    };

    TextAnimatorProperty.prototype.getValue = function () {
      if (this._elem.globalData.frameId === this._frameId) {
        return;
      }
      this._frameId = this._elem.globalData.frameId;
      this.iterateDynamicProperties();
    };

    TextAnimatorProperty.prototype.mHelper = new Matrix();
    TextAnimatorProperty.prototype.defaultPropsArray = [];
    extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);

    /* global PropertyFactory, degToRads, TextSelectorProp */
    /* exported TextAnimatorDataProperty */

    function TextAnimatorDataProperty(elem, animatorProps, container) {
      var defaultData = { propType: false };
      var getProp = PropertyFactory.getProp;
      var textAnimatorAnimatables = animatorProps.a;
      this.a = {
        r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
        rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
        ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
        sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
        sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
        s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
        a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
        o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
        p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
        sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
        sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
        fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
        fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
        fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
        fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
        t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData,
      };

      this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
      this.s.t = animatorProps.s.t;
    }

    function LetterProps(o, sw, sc, fc, m, p) {
      this.o = o;
      this.sw = sw;
      this.sc = sc;
      this.fc = fc;
      this.m = m;
      this.p = p;
      this._mdf = {
        o: true,
        sw: !!sw,
        sc: !!sc,
        fc: !!fc,
        m: true,
        p: true,
      };
    }

    LetterProps.prototype.update = function (o, sw, sc, fc, m, p) {
      this._mdf.o = false;
      this._mdf.sw = false;
      this._mdf.sc = false;
      this._mdf.fc = false;
      this._mdf.m = false;
      this._mdf.p = false;
      var updated = false;

      if (this.o !== o) {
        this.o = o;
        this._mdf.o = true;
        updated = true;
      }
      if (this.sw !== sw) {
        this.sw = sw;
        this._mdf.sw = true;
        updated = true;
      }
      if (this.sc !== sc) {
        this.sc = sc;
        this._mdf.sc = true;
        updated = true;
      }
      if (this.fc !== fc) {
        this.fc = fc;
        this._mdf.fc = true;
        updated = true;
      }
      if (this.m !== m) {
        this.m = m;
        this._mdf.m = true;
        updated = true;
      }
      if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {
        this.p = p;
        this._mdf.p = true;
        updated = true;
      }
      return updated;
    };

    /* global FontManager, initialDefaultFrame, getFontProperties */
    /* exported TextProperty */

    function TextProperty(elem, data) {
      this._frameId = initialDefaultFrame;
      this.pv = '';
      this.v = '';
      this.kf = false;
      this._isFirstFrame = true;
      this._mdf = false;
      this.data = data;
      this.elem = elem;
      this.comp = this.elem.comp;
      this.keysIndex = 0;
      this.canResize = false;
      this.minimumFontSize = 1;
      this.effectsSequence = [];
      this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: '',
        fStyle: '',
        fWeight: '',
        fc: '',
        j: '',
        justifyOffset: '',
        l: [],
        lh: 0,
        lineWidths: [],
        ls: '',
        of: '',
        s: '',
        sc: '',
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: false,
        strokeColorAnim: false,
        strokeWidthAnim: false,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: false,

      };
      this.copyData(this.currentData, this.data.d.k[0].s);

      if (!this.searchProperty()) {
        this.completeTextData(this.currentData);
      }
    }

    TextProperty.prototype.defaultBoxWidth = [0, 0];

    TextProperty.prototype.copyData = function (obj, data) {
      for (var s in data) {
        if (Object.prototype.hasOwnProperty.call(data, s)) {
          obj[s] = data[s];
        }
      }
      return obj;
    };

    TextProperty.prototype.setCurrentData = function (data) {
      if (!data.__complete) {
        this.completeTextData(data);
      }
      this.currentData = data;
      this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
      this._mdf = true;
    };

    TextProperty.prototype.searchProperty = function () {
      return this.searchKeyframes();
    };

    TextProperty.prototype.searchKeyframes = function () {
      this.kf = this.data.d.k.length > 1;
      if (this.kf) {
        this.addEffect(this.getKeyframeValue.bind(this));
      }
      return this.kf;
    };

    TextProperty.prototype.addEffect = function (effectFunction) {
      this.effectsSequence.push(effectFunction);
      this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.getValue = function (_finalValue) {
      if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
        return;
      }
      this.currentData.t = this.data.d.k[this.keysIndex].s.t;
      var currentValue = this.currentData;
      var currentIndex = this.keysIndex;
      if (this.lock) {
        this.setCurrentData(this.currentData);
        return;
      }
      this.lock = true;
      this._mdf = false;
      var i; var
        len = this.effectsSequence.length;
      var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
      for (i = 0; i < len; i += 1) {
        // Checking if index changed to prevent creating a new object every time the expression updates.
        if (currentIndex !== this.keysIndex) {
          finalValue = this.effectsSequence[i](finalValue, finalValue.t);
        } else {
          finalValue = this.effectsSequence[i](this.currentData, finalValue.t);
        }
      }
      if (currentValue !== finalValue) {
        this.setCurrentData(finalValue);
      }
      this.v = this.currentData;
      this.pv = this.v;
      this.lock = false;
      this.frameId = this.elem.globalData.frameId;
    };

    TextProperty.prototype.getKeyframeValue = function () {
      var textKeys = this.data.d.k;
      var frameNum = this.elem.comp.renderedFrame;
      var i = 0; var
        len = textKeys.length;
      while (i <= len - 1) {
        if (i === len - 1 || textKeys[i + 1].t > frameNum) {
          break;
        }
        i += 1;
      }
      if (this.keysIndex !== i) {
        this.keysIndex = i;
      }
      return this.data.d.k[this.keysIndex].s;
    };

    TextProperty.prototype.buildFinalText = function (text) {
      var charactersArray = [];
      var i = 0;
      var len = text.length;
      var charCode;
      var secondCharCode;
      var shouldCombine = false;
      while (i < len) {
        charCode = text.charCodeAt(i);
        if (FontManager.isCombinedCharacter(charCode)) {
          charactersArray[charactersArray.length - 1] += text.charAt(i);
        } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {
          secondCharCode = text.charCodeAt(i + 1);
          if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {
            if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
              charactersArray[charactersArray.length - 1] += text.substr(i, 2);
              shouldCombine = false;
            } else {
              charactersArray.push(text.substr(i, 2));
            }
            i += 1;
          } else {
            charactersArray.push(text.charAt(i));
          }
        } else if (charCode > 0xDBFF) {
          secondCharCode = text.charCodeAt(i + 1);
          if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
            shouldCombine = true;
            charactersArray[charactersArray.length - 1] += text.substr(i, 2);
            i += 1;
          } else {
            charactersArray.push(text.charAt(i));
          }
        } else if (FontManager.isZeroWidthJoiner(charCode)) {
          charactersArray[charactersArray.length - 1] += text.charAt(i);
          shouldCombine = true;
        } else {
          charactersArray.push(text.charAt(i));
        }
        i += 1;
      }
      return charactersArray;
    };

    TextProperty.prototype.completeTextData = function (documentData) {
      documentData.__complete = true;
      var fontManager = this.elem.globalData.fontManager;
      var data = this.data;
      var letters = [];
      var i; var
        len;
      var newLineFlag; var index = 0; var
        val;
      var anchorGrouping = data.m.g;
      var currentSize = 0; var currentPos = 0; var currentLine = 0; var
        lineWidths = [];
      var lineWidth = 0;
      var maxLineWidth = 0;
      var j; var
        jLen;
      var fontData = fontManager.getFontByName(documentData.f);
      var charData; var
        cLength = 0;

      var fontProps = getFontProperties(fontData);
      documentData.fWeight = fontProps.weight;
      documentData.fStyle = fontProps.style;
      documentData.finalSize = documentData.s;
      documentData.finalText = this.buildFinalText(documentData.t);
      len = documentData.finalText.length;
      documentData.finalLineHeight = documentData.lh;
      var trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
      var charCode;
      if (documentData.sz) {
        var flag = true;
        var boxWidth = documentData.sz[0];
        var boxHeight = documentData.sz[1];
        var currentHeight; var
          finalText;
        while (flag) {
          finalText = this.buildFinalText(documentData.t);
          currentHeight = 0;
          lineWidth = 0;
          len = finalText.length;
          trackingOffset = (documentData.tr / 1000) * documentData.finalSize;
          var lastSpaceIndex = -1;
          for (i = 0; i < len; i += 1) {
            charCode = finalText[i].charCodeAt(0);
            newLineFlag = false;
            if (finalText[i] === ' ') {
              lastSpaceIndex = i;
            } else if (charCode === 13 || charCode === 3) {
              lineWidth = 0;
              newLineFlag = true;
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);
              cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
            } else {
              // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
              cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);
            }
            if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {
              if (lastSpaceIndex === -1) {
                len += 1;
              } else {
                i = lastSpaceIndex;
              }
              currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
              finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\r');
              // finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
              lastSpaceIndex = -1;
              lineWidth = 0;
            } else {
              lineWidth += cLength;
              lineWidth += trackingOffset;
            }
          }
          currentHeight += (fontData.ascent * documentData.finalSize) / 100;
          if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
            documentData.finalSize -= 1;
            documentData.finalLineHeight = (documentData.finalSize * documentData.lh) / documentData.s;
          } else {
            documentData.finalText = finalText;
            len = documentData.finalText.length;
            flag = false;
          }
        }
      }
      lineWidth = -trackingOffset;
      cLength = 0;
      var uncollapsedSpaces = 0;
      var currentChar;
      for (i = 0; i < len; i += 1) {
        newLineFlag = false;
        currentChar = documentData.finalText[i];
        charCode = currentChar.charCodeAt(0);
        if (charCode === 13 || charCode === 3) {
          uncollapsedSpaces = 0;
          lineWidths.push(lineWidth);
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidth = -2 * trackingOffset;
          val = '';
          newLineFlag = true;
          currentLine += 1;
        } else {
          val = currentChar;
        }
        if (fontManager.chars) {
          charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
          cLength = newLineFlag ? 0 : (charData.w * documentData.finalSize) / 100;
        } else {
          // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
          // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
          cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
        }

        //
        if (currentChar === ' ') {
          uncollapsedSpaces += cLength + trackingOffset;
        } else {
          lineWidth += cLength + trackingOffset + uncollapsedSpaces;
          uncollapsedSpaces = 0;
        }
        letters.push({
          l: cLength, an: cLength, add: currentSize, n: newLineFlag, anIndexes: [], val: val, line: currentLine, animatorJustifyOffset: 0,
        });
        if (anchorGrouping == 2) { // eslint-disable-line eqeqeq
          currentSize += cLength;
          if (val === '' || val === ' ' || i === len - 1) {
            if (val === '' || val === ' ') {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            index += 1;
            currentSize = 0;
          }
        } else if (anchorGrouping == 3) { // eslint-disable-line eqeqeq
          currentSize += cLength;
          if (val === '' || i === len - 1) {
            if (val === '') {
              currentSize -= cLength;
            }
            while (currentPos <= i) {
              letters[currentPos].an = currentSize;
              letters[currentPos].ind = index;
              letters[currentPos].extra = cLength;
              currentPos += 1;
            }
            currentSize = 0;
            index += 1;
          }
        } else {
          letters[index].ind = index;
          letters[index].extra = 0;
          index += 1;
        }
      }
      documentData.l = letters;
      maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
      lineWidths.push(lineWidth);
      if (documentData.sz) {
        documentData.boxWidth = documentData.sz[0];
        documentData.justifyOffset = 0;
      } else {
        documentData.boxWidth = maxLineWidth;
        switch (documentData.j) {
          case 1:
            documentData.justifyOffset = -documentData.boxWidth;
            break;
          case 2:
            documentData.justifyOffset = -documentData.boxWidth / 2;
            break;
          default:
            documentData.justifyOffset = 0;
        }
      }
      documentData.lineWidths = lineWidths;

      var animators = data.a; var animatorData; var
        letterData;
      jLen = animators.length;
      var based; var ind; var
        indexes = [];
      for (j = 0; j < jLen; j += 1) {
        animatorData = animators[j];
        if (animatorData.a.sc) {
          documentData.strokeColorAnim = true;
        }
        if (animatorData.a.sw) {
          documentData.strokeWidthAnim = true;
        }
        if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
          documentData.fillColorAnim = true;
        }
        ind = 0;
        based = animatorData.s.b;
        for (i = 0; i < len; i += 1) {
          letterData = letters[i];
          letterData.anIndexes[j] = ind;
          if ((based == 1 && letterData.val !== '') || (based == 2 && letterData.val !== '' && letterData.val !== ' ') || (based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1)) || (based == 4 && (letterData.n || i == len - 1))) { // eslint-disable-line eqeqeq
            if (animatorData.s.rn === 1) {
              indexes.push(ind);
            }
            ind += 1;
          }
        }
        data.a[j].s.totalChars = ind;
        var currentInd = -1; var
          newInd;
        if (animatorData.s.rn === 1) {
          for (i = 0; i < len; i += 1) {
            letterData = letters[i];
            if (currentInd != letterData.anIndexes[j]) { // eslint-disable-line eqeqeq
              currentInd = letterData.anIndexes[j];
              newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
            }
            letterData.anIndexes[j] = newInd;
          }
        }
      }
      documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
      documentData.ls = documentData.ls || 0;
      documentData.ascent = (fontData.ascent * documentData.finalSize) / 100;
    };

    TextProperty.prototype.updateDocumentData = function (newData, index) {
      index = index === undefined ? this.keysIndex : index;
      var dData = this.copyData({}, this.data.d.k[index].s);
      dData = this.copyData(dData, newData);
      this.data.d.k[index].s = dData;
      this.recalculate(index);
      this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.recalculate = function (index) {
      var dData = this.data.d.k[index].s;
      dData.__complete = false;
      this.keysIndex = 0;
      this._isFirstFrame = true;
      this.getValue(dData);
    };

    TextProperty.prototype.canResizeFont = function (_canResize) {
      this.canResize = _canResize;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };

    TextProperty.prototype.setMinimumFontSize = function (_fontValue) {
      this.minimumFontSize = Math.floor(_fontValue) || 1;
      this.recalculate(this.keysIndex);
      this.elem.addDynamicProperty(this);
    };

    /* global extendPrototype, BezierFactory, PropertyFactory, DynamicPropertyContainer */
    /* exported TextSelectorProp */

    var TextSelectorProp = (function () {
      var max = Math.max;
      var min = Math.min;
      var floor = Math.floor;

      function TextSelectorPropFactory(elem, data) {
        this._currentTextLength = -1;
        this.k = false;
        this.data = data;
        this.elem = elem;
        this.comp = elem.comp;
        this.finalS = 0;
        this.finalE = 0;
        this.initDynamicPropertyContainer(elem);
        this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
        if ('e' in data) {
          this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
        } else {
          this.e = { v: 100 };
        }
        this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
        this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
        this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
        this.sm = PropertyFactory.getProp(elem, data.sm || { k: 100 }, 0, 0, this);
        this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
        if (!this.dynamicProperties.length) {
          this.getValue();
        }
      }

      TextSelectorPropFactory.prototype = {
        getMult: function (ind) {
          if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
            this.getValue();
          }
          // var easer = bez.getEasingCurve(this.ne.v/100,0,1-this.xe.v/100,1);
          var x1 = 0;
          var y1 = 0;
          var x2 = 1;
          var y2 = 1;
          if (this.ne.v > 0) {
            x1 = this.ne.v / 100.0;
          } else {
            y1 = -this.ne.v / 100.0;
          }
          if (this.xe.v > 0) {
            x2 = 1.0 - this.xe.v / 100.0;
          } else {
            y2 = 1.0 + this.xe.v / 100.0;
          }
          var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;

          var mult = 0;
          var s = this.finalS;
          var e = this.finalE;
          var type = this.data.sh;
          if (type === 2) {
            if (e === s) {
              mult = ind >= e ? 1 : 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }
            mult = easer(mult);
          } else if (type === 3) {
            if (e === s) {
              mult = ind >= e ? 0 : 1;
            } else {
              mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
            }

            mult = easer(mult);
          } else if (type === 4) {
            if (e === s) {
              mult = 0;
            } else {
              mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));
              if (mult < 0.5) {
                mult *= 2;
              } else {
                mult = 1 - 2 * (mult - 0.5);
              }
            }
            mult = easer(mult);
          } else if (type === 5) {
            if (e === s) {
              mult = 0;
            } else {
              var tot = e - s;
              /* ind += 0.5;
                        mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */
              ind = min(max(0, ind + 0.5 - s), e - s);
              var x = -tot / 2 + ind;
              var a = tot / 2;
              mult = Math.sqrt(1 - (x * x) / (a * a));
            }
            mult = easer(mult);
          } else if (type === 6) {
            if (e === s) {
              mult = 0;
            } else {
              ind = min(max(0, ind + 0.5 - s), e - s);
              mult = (1 + (Math.cos((Math.PI + Math.PI * 2 * (ind) / (e - s))))) / 2; // eslint-disable-line
            }
            mult = easer(mult);
          } else {
            if (ind >= floor(s)) {
              if (ind - s < 0) {
                mult = max(0, min(min(e, 1) - (s - ind), 1));
              } else {
                mult = max(0, min(e - ind, 1));
              }
            }
            mult = easer(mult);
          }
          // Smoothness implementation.
          // The smoothness represents a reduced range of the original [0; 1] range.
          // if smoothness is 25%, the new range will be [0.375; 0.625]
          // Steps are:
          // - find the lower value of the new range (threshold)
          // - if multiplier is smaller than that value, floor it to 0
          // - if it is larger,
          //     - subtract the threshold
          //     - divide it by the smoothness (this will return the range to [0; 1])
          // Note: If it doesn't work on some scenarios, consider applying it before the easer.
          if (this.sm.v !== 100) {
            var smoothness = this.sm.v * 0.01;
            if (smoothness === 0) {
              smoothness = 0.00000001;
            }
            var threshold = 0.5 - smoothness * 0.5;
            if (mult < threshold) {
              mult = 0;
            } else {
              mult = (mult - threshold) / smoothness;
              if (mult > 1) {
                mult = 1;
              }
            }
          }
          return mult * this.a.v;
        },
        getValue: function (newCharsFlag) {
          this.iterateDynamicProperties();
          this._mdf = newCharsFlag || this._mdf;
          this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
          if (newCharsFlag && this.data.r === 2) {
            this.e.v = this._currentTextLength;
          }
          var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
          var o = this.o.v / divisor;
          var s = this.s.v / divisor + o;
          var e = (this.e.v / divisor) + o;
          if (s > e) {
            var _s = s;
            s = e;
            e = _s;
          }
          this.finalS = s;
          this.finalE = e;
        },
      };
      extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);

      function getTextSelectorProp(elem, data, arr) {
        return new TextSelectorPropFactory(elem, data, arr);
      }

      return {
        getTextSelectorProp: getTextSelectorProp,
      };
    }());

    /* global createSizedArray, pooling */
    /* exported poolFactory */

    var poolFactory = (function () {
      return function (initialLength, _create, _release) {
        var _length = 0;
        var _maxLength = initialLength;
        var pool = createSizedArray(_maxLength);

        var ob = {
          newElement: newElement,
          release: release,
        };

        function newElement() {
          var element;
          if (_length) {
            _length -= 1;
            element = pool[_length];
          } else {
            element = _create();
          }
          return element;
        }

        function release(element) {
          if (_length === _maxLength) {
            pool = pooling.double(pool);
            _maxLength *= 2;
          }
          if (_release) {
            _release(element);
          }
          pool[_length] = element;
          _length += 1;
        }

        return ob;
      };
    }());

    /* global createSizedArray */
    /* exported pooling */

    var pooling = (function () {
      function double(arr) {
        return arr.concat(createSizedArray(arr.length));
      }

      return {
        double: double,
      };
    }());

    /* global createTypedArray, poolFactory */
    /* exported pointPool */

    var pointPool = (function () {
      function create() {
        return createTypedArray('float32', 2);
      }
      return poolFactory(8, create);
    }());

    /* global ShapePath, pointPool, poolFactory */
    /* exported shapePool */

    var shapePool = (function () {
      function create() {
        return new ShapePath();
      }

      function release(shapePath) {
        var len = shapePath._length;
        var i;
        for (i = 0; i < len; i += 1) {
          pointPool.release(shapePath.v[i]);
          pointPool.release(shapePath.i[i]);
          pointPool.release(shapePath.o[i]);
          shapePath.v[i] = null;
          shapePath.i[i] = null;
          shapePath.o[i] = null;
        }
        shapePath._length = 0;
        shapePath.c = false;
      }

      function clone(shape) {
        var cloned = factory.newElement();
        var i;
        var len = shape._length === undefined ? shape.v.length : shape._length;
        cloned.setLength(len);
        cloned.c = shape.c;

        for (i = 0; i < len; i += 1) {
          cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);
        }
        return cloned;
      }

      var factory = poolFactory(4, create, release);
      factory.clone = clone;

      return factory;
    }());

    /* global createSizedArray, ShapeCollection, shapePool, pooling */
    /* exported shapeCollectionPool */

    var shapeCollectionPool = (function () {
      var ob = {
        newShapeCollection: newShapeCollection,
        release: release,
      };

      var _length = 0;
      var _maxLength = 4;
      var pool = createSizedArray(_maxLength);

      function newShapeCollection() {
        var shapeCollection;
        if (_length) {
          _length -= 1;
          shapeCollection = pool[_length];
        } else {
          shapeCollection = new ShapeCollection();
        }
        return shapeCollection;
      }

      function release(shapeCollection) {
        var i;
        var len = shapeCollection._length;
        for (i = 0; i < len; i += 1) {
          shapePool.release(shapeCollection.shapes[i]);
        }
        shapeCollection._length = 0;

        if (_length === _maxLength) {
          pool = pooling.double(pool);
          _maxLength *= 2;
        }
        pool[_length] = shapeCollection;
        _length += 1;
      }

      return ob;
    }());

    /* global poolFactory, bezierLengthPool */
    /* exported segmentsLengthPool */

    var segmentsLengthPool = (function () {
      function create() {
        return {
          lengths: [],
          totalLength: 0,
        };
      }

      function release(element) {
        var i;
        var len = element.lengths.length;
        for (i = 0; i < len; i += 1) {
          bezierLengthPool.release(element.lengths[i]);
        }
        element.lengths.length = 0;
      }

      return poolFactory(8, create, release);
    }());

    /* global createTypedArray, defaultCurveSegments, poolFactory */
    /* exported bezierLengthPool */

    var bezierLengthPool = (function () {
      function create() {
        return {
          addedLength: 0,
          percents: createTypedArray('float32', defaultCurveSegments),
          lengths: createTypedArray('float32', defaultCurveSegments),
        };
      }
      return poolFactory(8, create);
    }());

    /* exported markerParser */

    var markerParser = (

      function () {
        function parsePayloadLines(payload) {
          var lines = payload.split('\r\n');
          var keys = {};
          var line;
          var keysCount = 0;
          for (var i = 0; i < lines.length; i += 1) {
            line = lines[i].split(':');
            if (line.length === 2) {
              keys[line[0]] = line[1].trim();
              keysCount += 1;
            }
          }
          if (keysCount === 0) {
            throw new Error();
          }
          return keys;
        }

        return function (_markers) {
          var markers = [];
          for (var i = 0; i < _markers.length; i += 1) {
            var _marker = _markers[i];
            var markerData = {
              time: _marker.tm,
              duration: _marker.dr,
            };
            try {
              markerData.payload = JSON.parse(_markers[i].cm);
            } catch (_) {
              try {
                markerData.payload = parsePayloadLines(_markers[i].cm);
              } catch (__) {
                markerData.payload = {
                  name: _markers[i],
                };
              }
            }
            markers.push(markerData);
          }
          return markers;
        };
      }());

    /* global AudioElement, FootageElement, FontManager */

    function BaseRenderer() {}
    BaseRenderer.prototype.checkLayers = function (num) {
      var i;
      var len = this.layers.length;
      var data;
      this.completeLayers = true;
      for (i = len - 1; i >= 0; i -= 1) {
        if (!this.elements[i]) {
          data = this.layers[i];
          if (data.ip - data.st <= (num - this.layers[i].st) && data.op - data.st > (num - this.layers[i].st)) {
            this.buildItem(i);
          }
        }
        this.completeLayers = this.elements[i] ? this.completeLayers : false;
      }
      this.checkPendingElements();
    };

    BaseRenderer.prototype.createItem = function (layer) {
      switch (layer.ty) {
        case 2:
          return this.createImage(layer);
        case 0:
          return this.createComp(layer);
        case 1:
          return this.createSolid(layer);
        case 3:
          return this.createNull(layer);
        case 4:
          return this.createShape(layer);
        case 5:
          return this.createText(layer);
        case 6:
          return this.createAudio(layer);
        case 13:
          return this.createCamera(layer);
        case 15:
          return this.createFootage(layer);
        default:
          return this.createNull(layer);
      }
    };

    BaseRenderer.prototype.createCamera = function () {
      throw new Error('You\'re using a 3d camera. Try the html renderer.');
    };

    BaseRenderer.prototype.createAudio = function (data) {
      return new AudioElement(data, this.globalData, this);
    };

    BaseRenderer.prototype.createFootage = function (data) {
      return new FootageElement(data, this.globalData, this);
    };

    BaseRenderer.prototype.buildAllItems = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        this.buildItem(i);
      }
      this.checkPendingElements();
    };

    BaseRenderer.prototype.includeLayers = function (newLayers) {
      this.completeLayers = false;
      var i;
      var len = newLayers.length;
      var j;
      var jLen = this.layers.length;
      for (i = 0; i < len; i += 1) {
        j = 0;
        while (j < jLen) {
          if (this.layers[j].id === newLayers[i].id) {
            this.layers[j] = newLayers[i];
            break;
          }
          j += 1;
        }
      }
    };

    BaseRenderer.prototype.setProjectInterface = function (pInterface) {
      this.globalData.projectInterface = pInterface;
    };

    BaseRenderer.prototype.initItems = function () {
      if (!this.globalData.progressiveLoad) {
        this.buildAllItems();
      }
    };
    BaseRenderer.prototype.buildElementParenting = function (element, parentName, hierarchy) {
      var elements = this.elements;
      var layers = this.layers;
      var i = 0;
      var len = layers.length;
      while (i < len) {
        if (layers[i].ind == parentName) { // eslint-disable-line eqeqeq
          if (!elements[i] || elements[i] === true) {
            this.buildItem(i);
            this.addPendingElement(element);
          } else {
            hierarchy.push(elements[i]);
            elements[i].setAsParent();
            if (layers[i].parent !== undefined) {
              this.buildElementParenting(element, layers[i].parent, hierarchy);
            } else {
              element.setHierarchy(hierarchy);
            }
          }
        }
        i += 1;
      }
    };

    BaseRenderer.prototype.addPendingElement = function (element) {
      this.pendingElements.push(element);
    };

    BaseRenderer.prototype.searchExtraCompositions = function (assets) {
      var i;
      var len = assets.length;
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp = this.createComp(assets[i]);
          comp.initExpressions();
          this.globalData.projectInterface.registerComposition(comp);
        }
      }
    };

    BaseRenderer.prototype.setupGlobalData = function (animData, fontsContainer) {
      this.globalData.fontManager = new FontManager();
      this.globalData.fontManager.addChars(animData.chars);
      this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
      this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
      this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
      this.globalData.imageLoader = this.animationItem.imagePreloader;
      this.globalData.audioController = this.animationItem.audioController;
      this.globalData.frameId = 0;
      this.globalData.frameRate = animData.fr;
      this.globalData.nm = animData.nm;
      this.globalData.compSize = {
        w: animData.w,
        h: animData.h,
      };
    };

    /* global createElementID, extendPrototype, BaseRenderer, NullElement, SVGShapeElement, SVGTextLottieElement,
    IImageElement, SVGCompElement, ISolidElement, createNS, locationHref, createSizedArray, expressionsPlugin */

    function SVGRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.svgElement = createNS('svg');
      var ariaLabel = '';
      if (config && config.title) {
        var titleElement = createNS('title');
        var titleId = createElementID();
        titleElement.setAttribute('id', titleId);
        titleElement.textContent = config.title;
        this.svgElement.appendChild(titleElement);
        ariaLabel += titleId;
      }
      if (config && config.description) {
        var descElement = createNS('desc');
        var descId = createElementID();
        descElement.setAttribute('id', descId);
        descElement.textContent = config.description;
        this.svgElement.appendChild(descElement);
        ariaLabel += ' ' + descId;
      }
      if (ariaLabel) {
        this.svgElement.setAttribute('aria-labelledby', ariaLabel);
      }
      var defs = createNS('defs');
      this.svgElement.appendChild(defs);
      var maskElement = createNS('g');
      this.svgElement.appendChild(maskElement);
      this.layerElement = maskElement;
      this.renderConfig = {
        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
        contentVisibility: (config && config.contentVisibility) || 'visible',
        progressiveLoad: (config && config.progressiveLoad) || false,
        hideOnTransparent: !((config && config.hideOnTransparent === false)),
        viewBoxOnly: (config && config.viewBoxOnly) || false,
        viewBoxSize: (config && config.viewBoxSize) || false,
        className: (config && config.className) || '',
        id: (config && config.id) || '',
        focusable: config && config.focusable,
        filterSize: {
          width: (config && config.filterSize && config.filterSize.width) || '100%',
          height: (config && config.filterSize && config.filterSize.height) || '100%',
          x: (config && config.filterSize && config.filterSize.x) || '0%',
          y: (config && config.filterSize && config.filterSize.y) || '0%',
        },
      };

      this.globalData = {
        _mdf: false,
        frameNum: -1,
        defs: defs,
        renderConfig: this.renderConfig,
      };
      this.elements = [];
      this.pendingElements = [];
      this.destroyed = false;
      this.rendererType = 'svg';
    }

    extendPrototype([BaseRenderer], SVGRenderer);

    SVGRenderer.prototype.createNull = function (data) {
      return new NullElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.createShape = function (data) {
      return new SVGShapeElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.createText = function (data) {
      return new SVGTextLottieElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.createImage = function (data) {
      return new IImageElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.createComp = function (data) {
      return new SVGCompElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.createSolid = function (data) {
      return new ISolidElement(data, this.globalData, this);
    };

    SVGRenderer.prototype.configAnimation = function (animData) {
      this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      if (this.renderConfig.viewBoxSize) {
        this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);
      } else {
        this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);
      }

      if (!this.renderConfig.viewBoxOnly) {
        this.svgElement.setAttribute('width', animData.w);
        this.svgElement.setAttribute('height', animData.h);
        this.svgElement.style.width = '100%';
        this.svgElement.style.height = '100%';
        this.svgElement.style.transform = 'translate3d(0,0,0)';
        this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
      }
      if (this.renderConfig.className) {
        this.svgElement.setAttribute('class', this.renderConfig.className);
      }
      if (this.renderConfig.id) {
        this.svgElement.setAttribute('id', this.renderConfig.id);
      }
      if (this.renderConfig.focusable !== undefined) {
        this.svgElement.setAttribute('focusable', this.renderConfig.focusable);
      }
      this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);
      // this.layerElement.style.transform = 'translate3d(0,0,0)';
      // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
      this.animationItem.wrapper.appendChild(this.svgElement);
      // Mask animation
      var defs = this.globalData.defs;

      this.setupGlobalData(animData, defs);
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.data = animData;

      var maskElement = createNS('clipPath');
      var rect = createNS('rect');
      rect.setAttribute('width', animData.w);
      rect.setAttribute('height', animData.h);
      rect.setAttribute('x', 0);
      rect.setAttribute('y', 0);
      var maskId = createElementID();
      maskElement.setAttribute('id', maskId);
      maskElement.appendChild(rect);
      this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + maskId + ')');

      defs.appendChild(maskElement);
      this.layers = animData.layers;
      this.elements = createSizedArray(animData.layers.length);
    };

    SVGRenderer.prototype.destroy = function () {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      this.layerElement = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };

    SVGRenderer.prototype.updateContainerSize = function () {
    };

    SVGRenderer.prototype.buildItem = function (pos) {
      var elements = this.elements;
      if (elements[pos] || this.layers[pos].ty === 99) {
        return;
      }
      elements[pos] = true;
      var element = this.createItem(this.layers[pos]);

      elements[pos] = element;
      if (expressionsPlugin) {
        if (this.layers[pos].ty === 0) {
          this.globalData.projectInterface.registerComposition(element);
        }
        element.initExpressions();
      }
      this.appendElementInPos(element, pos);
      if (this.layers[pos].tt) {
        if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
          this.buildItem(pos - 1);
          this.addPendingElement(element);
        } else {
          element.setMatte(elements[pos - 1].layerId);
        }
      }
    };

    SVGRenderer.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
        if (element.data.tt) {
          var i = 0;
          var len = this.elements.length;
          while (i < len) {
            if (this.elements[i] === element) {
              element.setMatte(this.elements[i - 1].layerId);
              break;
            }
            i += 1;
          }
        }
      }
    };

    SVGRenderer.prototype.renderFrame = function (num) {
      if (this.renderedFrame === num || this.destroyed) {
        return;
      }
      if (num === null) {
        num = this.renderedFrame;
      } else {
        this.renderedFrame = num;
      }
      // console.log('-------');
      // console.log('FRAME ',num);
      this.globalData.frameNum = num;
      this.globalData.frameId += 1;
      this.globalData.projectInterface.currentFrame = num;
      this.globalData._mdf = false;
      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        for (i = 0; i < len; i += 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
      }
    };

    SVGRenderer.prototype.appendElementInPos = function (element, pos) {
      var newElement = element.getBaseElement();
      if (!newElement) {
        return;
      }
      var i = 0;
      var nextElement;
      while (i < pos) {
        if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {
          nextElement = this.elements[i].getBaseElement();
        }
        i += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(newElement, nextElement);
      } else {
        this.layerElement.appendChild(newElement);
      }
    };

    SVGRenderer.prototype.hide = function () {
      this.layerElement.style.display = 'none';
    };

    SVGRenderer.prototype.show = function () {
      this.layerElement.style.display = 'block';
    };

    /* global CVContextData, Matrix, extendPrototype, BaseRenderer, CVShapeElement, CVTextElement,
    CVImageElement, CVCompElement, CVSolidElement, SVGRenderer, createTag, createSizedArray */

    function CanvasRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.renderConfig = {
        clearCanvas: (config && config.clearCanvas !== undefined) ? config.clearCanvas : true,
        context: (config && config.context) || null,
        progressiveLoad: (config && config.progressiveLoad) || false,
        preserveAspectRatio: (config && config.preserveAspectRatio) || 'xMidYMid meet',
        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
        contentVisibility: (config && config.contentVisibility) || 'visible',
        className: (config && config.className) || '',
        id: (config && config.id) || '',
      };
      this.renderConfig.dpr = (config && config.dpr) || 1;
      if (this.animationItem.wrapper) {
        this.renderConfig.dpr = (config && config.dpr) || window.devicePixelRatio || 1;
      }
      this.renderedFrame = -1;
      this.globalData = {
        frameNum: -1,
        _mdf: false,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1,
      };
      this.contextData = new CVContextData();
      this.elements = [];
      this.pendingElements = [];
      this.transformMat = new Matrix();
      this.completeLayers = false;
      this.rendererType = 'canvas';
    }
    extendPrototype([BaseRenderer], CanvasRenderer);

    CanvasRenderer.prototype.createShape = function (data) {
      return new CVShapeElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createText = function (data) {
      return new CVTextElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createImage = function (data) {
      return new CVImageElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createComp = function (data) {
      return new CVCompElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createSolid = function (data) {
      return new CVSolidElement(data, this.globalData, this);
    };

    CanvasRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

    CanvasRenderer.prototype.ctxTransform = function (props) {
      if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {
        return;
      }
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);
        return;
      }
      this.transformMat.cloneFromProps(props);
      var cProps = this.contextData.cTr.props;
      this.transformMat.transform(cProps[0], cProps[1], cProps[2], cProps[3], cProps[4], cProps[5], cProps[6], cProps[7], cProps[8], cProps[9], cProps[10], cProps[11], cProps[12], cProps[13], cProps[14], cProps[15]);
      // this.contextData.cTr.transform(props[0],props[1],props[2],props[3],props[4],props[5],props[6],props[7],props[8],props[9],props[10],props[11],props[12],props[13],props[14],props[15]);
      this.contextData.cTr.cloneFromProps(this.transformMat.props);
      var trProps = this.contextData.cTr.props;
      this.canvasContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);
    };

    CanvasRenderer.prototype.ctxOpacity = function (op) {
      /* if(op === 1){
            return;
        } */
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;
        this.globalData.currentGlobalAlpha = this.contextData.cO;
        return;
      }
      this.contextData.cO *= op < 0 ? 0 : op;
      if (this.globalData.currentGlobalAlpha !== this.contextData.cO) {
        this.canvasContext.globalAlpha = this.contextData.cO;
        this.globalData.currentGlobalAlpha = this.contextData.cO;
      }
    };

    CanvasRenderer.prototype.reset = function () {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    };

    CanvasRenderer.prototype.save = function (actionFlag) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.save();
        return;
      }
      if (actionFlag) {
        this.canvasContext.save();
      }
      var props = this.contextData.cTr.props;
      if (this.contextData._length <= this.contextData.cArrPos) {
        this.contextData.duplicate();
      }
      var i;
      var arr = this.contextData.saved[this.contextData.cArrPos];
      for (i = 0; i < 16; i += 1) {
        arr[i] = props[i];
      }
      this.contextData.savedOp[this.contextData.cArrPos] = this.contextData.cO;
      this.contextData.cArrPos += 1;
    };

    CanvasRenderer.prototype.restore = function (actionFlag) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      if (actionFlag) {
        this.canvasContext.restore();
        this.globalData.blendMode = 'source-over';
      }
      this.contextData.cArrPos -= 1;
      var popped = this.contextData.saved[this.contextData.cArrPos];
      var i;
      var arr = this.contextData.cTr.props;
      for (i = 0; i < 16; i += 1) {
        arr[i] = popped[i];
      }
      this.canvasContext.setTransform(popped[0], popped[1], popped[4], popped[5], popped[12], popped[13]);
      popped = this.contextData.savedOp[this.contextData.cArrPos];
      this.contextData.cO = popped;
      if (this.globalData.currentGlobalAlpha !== popped) {
        this.canvasContext.globalAlpha = popped;
        this.globalData.currentGlobalAlpha = popped;
      }
    };

    CanvasRenderer.prototype.configAnimation = function (animData) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag('canvas');
        var containerStyle = this.animationItem.container.style;
        containerStyle.width = '100%';
        containerStyle.height = '100%';
        var origin = '0px 0px 0px';
        containerStyle.transformOrigin = origin;
        containerStyle.mozTransformOrigin = origin;
        containerStyle.webkitTransformOrigin = origin;
        containerStyle['-webkit-transform'] = origin;
        containerStyle.contentVisibility = this.renderConfig.contentVisibility;
        this.animationItem.wrapper.appendChild(this.animationItem.container);
        this.canvasContext = this.animationItem.container.getContext('2d');
        if (this.renderConfig.className) {
          this.animationItem.container.setAttribute('class', this.renderConfig.className);
        }
        if (this.renderConfig.id) {
          this.animationItem.container.setAttribute('id', this.renderConfig.id);
        }
      } else {
        this.canvasContext = this.renderConfig.context;
      }
      this.data = animData;
      this.layers = animData.layers;
      this.transformCanvas = {
        w: animData.w,
        h: animData.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0,
      };
      this.setupGlobalData(animData, document.body);
      this.globalData.canvasContext = this.canvasContext;
      this.globalData.renderer = this;
      this.globalData.isDashed = false;
      this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
      this.globalData.transformCanvas = this.transformCanvas;
      this.elements = createSizedArray(animData.layers.length);

      this.updateContainerSize();
    };

    CanvasRenderer.prototype.updateContainerSize = function () {
      this.reset();
      var elementWidth;
      var elementHeight;
      if (this.animationItem.wrapper && this.animationItem.container) {
        elementWidth = this.animationItem.wrapper.offsetWidth;
        elementHeight = this.animationItem.wrapper.offsetHeight;
        this.animationItem.container.setAttribute('width', elementWidth * this.renderConfig.dpr);
        this.animationItem.container.setAttribute('height', elementHeight * this.renderConfig.dpr);
      } else {
        elementWidth = this.canvasContext.canvas.width * this.renderConfig.dpr;
        elementHeight = this.canvasContext.canvas.height * this.renderConfig.dpr;
      }
      var elementRel;
      var animationRel;
      if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {
        var par = this.renderConfig.preserveAspectRatio.split(' ');
        var fillType = par[1] || 'meet';
        var pos = par[0] || 'xMidYMid';
        var xPos = pos.substr(0, 4);
        var yPos = pos.substr(4);
        elementRel = elementWidth / elementHeight;
        animationRel = this.transformCanvas.w / this.transformCanvas.h;
        if ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice')) {
          this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
          this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        } else {
          this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
          this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        }

        if (xPos === 'xMid' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
          this.transformCanvas.tx = ((elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2) * this.renderConfig.dpr;
        } else if (xPos === 'xMax' && ((animationRel < elementRel && fillType === 'meet') || (animationRel > elementRel && fillType === 'slice'))) {
          this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.tx = 0;
        }
        if (yPos === 'YMid' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
          this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2) * this.renderConfig.dpr;
        } else if (yPos === 'YMax' && ((animationRel > elementRel && fillType === 'meet') || (animationRel < elementRel && fillType === 'slice'))) {
          this.transformCanvas.ty = ((elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w))) * this.renderConfig.dpr;
        } else {
          this.transformCanvas.ty = 0;
        }
      } else if (this.renderConfig.preserveAspectRatio === 'none') {
        this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);
        this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      } else {
        this.transformCanvas.sx = this.renderConfig.dpr;
        this.transformCanvas.sy = this.renderConfig.dpr;
        this.transformCanvas.tx = 0;
        this.transformCanvas.ty = 0;
      }
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1];
      /* var i, len = this.elements.length;
        for(i=0;i<len;i+=1){
            if(this.elements[i] && this.elements[i].data.ty === 0){
                this.elements[i].resize(this.globalData.transformCanvas);
            }
        } */
      this.ctxTransform(this.transformCanvas.props);
      this.canvasContext.beginPath();
      this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
      this.canvasContext.closePath();
      this.canvasContext.clip();

      this.renderFrame(this.renderedFrame, true);
    };

    CanvasRenderer.prototype.destroy = function () {
      if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
      this.elements.length = 0;
      this.globalData.canvasContext = null;
      this.animationItem.container = null;
      this.destroyed = true;
    };

    CanvasRenderer.prototype.renderFrame = function (num, forceRender) {
      if ((this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender) || this.destroyed || num === -1) {
        return;
      }
      this.renderedFrame = num;
      this.globalData.frameNum = num - this.animationItem._isFirstFrame;
      this.globalData.frameId += 1;
      this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;
      this.globalData.projectInterface.currentFrame = num;

      // console.log('--------');
      // console.log('NEW: ',num);
      var i;
      var len = this.layers.length;
      if (!this.completeLayers) {
        this.checkLayers(num);
      }

      for (i = 0; i < len; i += 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(num - this.layers[i].st);
        }
      }
      if (this.globalData._mdf) {
        if (this.renderConfig.clearCanvas === true) {
          this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);
        } else {
          this.save();
        }
        for (i = len - 1; i >= 0; i -= 1) {
          if (this.completeLayers || this.elements[i]) {
            this.elements[i].renderFrame();
          }
        }
        if (this.renderConfig.clearCanvas !== true) {
          this.restore();
        }
      }
    };

    CanvasRenderer.prototype.buildItem = function (pos) {
      var elements = this.elements;
      if (elements[pos] || this.layers[pos].ty === 99) {
        return;
      }
      var element = this.createItem(this.layers[pos], this, this.globalData);
      elements[pos] = element;
      element.initExpressions();
      /* if(this.layers[pos].ty === 0){
            element.resize(this.globalData.transformCanvas);
        } */
    };

    CanvasRenderer.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };

    CanvasRenderer.prototype.hide = function () {
      this.animationItem.container.style.display = 'none';
    };

    CanvasRenderer.prototype.show = function () {
      this.animationItem.container.style.display = 'block';
    };

    /* global extendPrototype, BaseRenderer, SVGRenderer, SVGShapeElement, HShapeElement, SVGTextLottieElement,
    HTextElement, HCameraElement, IImageElement, HImageElement, SVGCompElement, HCompElement, ISolidElement,
    HSolidElement, styleDiv, createTag, createNS */

    function HybridRenderer(animationItem, config) {
      this.animationItem = animationItem;
      this.layers = null;
      this.renderedFrame = -1;
      this.renderConfig = {
        className: (config && config.className) || '',
        imagePreserveAspectRatio: (config && config.imagePreserveAspectRatio) || 'xMidYMid slice',
        hideOnTransparent: !(config && config.hideOnTransparent === false),
        filterSize: {
          width: (config && config.filterSize && config.filterSize.width) || '400%',
          height: (config && config.filterSize && config.filterSize.height) || '400%',
          x: (config && config.filterSize && config.filterSize.x) || '-100%',
          y: (config && config.filterSize && config.filterSize.y) || '-100%',
        },
      };
      this.globalData = {
        _mdf: false,
        frameNum: -1,
        renderConfig: this.renderConfig,
      };
      this.pendingElements = [];
      this.elements = [];
      this.threeDElements = [];
      this.destroyed = false;
      this.camera = null;
      this.supports3d = true;
      this.rendererType = 'html';
    }

    extendPrototype([BaseRenderer], HybridRenderer);

    HybridRenderer.prototype.buildItem = SVGRenderer.prototype.buildItem;

    HybridRenderer.prototype.checkPendingElements = function () {
      while (this.pendingElements.length) {
        var element = this.pendingElements.pop();
        element.checkParenting();
      }
    };

    HybridRenderer.prototype.appendElementInPos = function (element, pos) {
      var newDOMElement = element.getBaseElement();
      if (!newDOMElement) {
        return;
      }
      var layer = this.layers[pos];
      if (!layer.ddd || !this.supports3d) {
        if (this.threeDElements) {
          this.addTo3dContainer(newDOMElement, pos);
        } else {
          var i = 0;
          var nextDOMElement;
          var nextLayer;
          var tmpDOMElement;
          while (i < pos) {
            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {
              nextLayer = this.elements[i];
              tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();
              nextDOMElement = tmpDOMElement || nextDOMElement;
            }
            i += 1;
          }
          if (nextDOMElement) {
            if (!layer.ddd || !this.supports3d) {
              this.layerElement.insertBefore(newDOMElement, nextDOMElement);
            }
          } else if (!layer.ddd || !this.supports3d) {
            this.layerElement.appendChild(newDOMElement);
          }
        }
      } else {
        this.addTo3dContainer(newDOMElement, pos);
      }
    };

    HybridRenderer.prototype.createShape = function (data) {
      if (!this.supports3d) {
        return new SVGShapeElement(data, this.globalData, this);
      }
      return new HShapeElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createText = function (data) {
      if (!this.supports3d) {
        return new SVGTextLottieElement(data, this.globalData, this);
      }
      return new HTextElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createCamera = function (data) {
      this.camera = new HCameraElement(data, this.globalData, this);
      return this.camera;
    };

    HybridRenderer.prototype.createImage = function (data) {
      if (!this.supports3d) {
        return new IImageElement(data, this.globalData, this);
      }
      return new HImageElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createComp = function (data) {
      if (!this.supports3d) {
        return new SVGCompElement(data, this.globalData, this);
      }
      return new HCompElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createSolid = function (data) {
      if (!this.supports3d) {
        return new ISolidElement(data, this.globalData, this);
      }
      return new HSolidElement(data, this.globalData, this);
    };

    HybridRenderer.prototype.createNull = SVGRenderer.prototype.createNull;

    HybridRenderer.prototype.getThreeDContainerByPos = function (pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {
          return this.threeDElements[i].perspectiveElem;
        }
        i += 1;
      }
      return null;
    };

    HybridRenderer.prototype.createThreeDContainer = function (pos, type) {
      var perspectiveElem = createTag('div');
      var style;
      var containerStyle;
      styleDiv(perspectiveElem);
      var container = createTag('div');
      styleDiv(container);
      if (type === '3d') {
        style = perspectiveElem.style;
        style.width = this.globalData.compSize.w + 'px';
        style.height = this.globalData.compSize.h + 'px';
        var center = '50% 50%';
        style.webkitTransformOrigin = center;
        style.mozTransformOrigin = center;
        style.transformOrigin = center;
        containerStyle = container.style;
        var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
        containerStyle.transform = matrix;
        containerStyle.webkitTransform = matrix;
      }

      perspectiveElem.appendChild(container);
      // this.resizerElem.appendChild(perspectiveElem);
      var threeDContainerData = {
        container: container,
        perspectiveElem: perspectiveElem,
        startPos: pos,
        endPos: pos,
        type: type,
      };
      this.threeDElements.push(threeDContainerData);
      return threeDContainerData;
    };

    HybridRenderer.prototype.build3dContainers = function () {
      var i;
      var len = this.layers.length;
      var lastThreeDContainerData;
      var currentContainer = '';
      for (i = 0; i < len; i += 1) {
        if (this.layers[i].ddd && this.layers[i].ty !== 3) {
          if (currentContainer !== '3d') {
            currentContainer = '3d';
            lastThreeDContainerData = this.createThreeDContainer(i, '3d');
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        } else {
          if (currentContainer !== '2d') {
            currentContainer = '2d';
            lastThreeDContainerData = this.createThreeDContainer(i, '2d');
          }
          lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);
        }
      }
      len = this.threeDElements.length;
      for (i = len - 1; i >= 0; i -= 1) {
        this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);
      }
    };

    HybridRenderer.prototype.addTo3dContainer = function (elem, pos) {
      var i = 0;
      var len = this.threeDElements.length;
      while (i < len) {
        if (pos <= this.threeDElements[i].endPos) {
          var j = this.threeDElements[i].startPos;
          var nextElement;
          while (j < pos) {
            if (this.elements[j] && this.elements[j].getBaseElement) {
              nextElement = this.elements[j].getBaseElement();
            }
            j += 1;
          }
          if (nextElement) {
            this.threeDElements[i].container.insertBefore(elem, nextElement);
          } else {
            this.threeDElements[i].container.appendChild(elem);
          }
          break;
        }
        i += 1;
      }
    };

    HybridRenderer.prototype.configAnimation = function (animData) {
      var resizerElem = createTag('div');
      var wrapper = this.animationItem.wrapper;
      var style = resizerElem.style;
      style.width = animData.w + 'px';
      style.height = animData.h + 'px';
      this.resizerElem = resizerElem;
      styleDiv(resizerElem);
      style.transformStyle = 'flat';
      style.mozTransformStyle = 'flat';
      style.webkitTransformStyle = 'flat';
      if (this.renderConfig.className) {
        resizerElem.setAttribute('class', this.renderConfig.className);
      }
      wrapper.appendChild(resizerElem);

      style.overflow = 'hidden';
      var svg = createNS('svg');
      svg.setAttribute('width', '1');
      svg.setAttribute('height', '1');
      styleDiv(svg);
      this.resizerElem.appendChild(svg);
      var defs = createNS('defs');
      svg.appendChild(defs);
      this.data = animData;
      // Mask animation
      this.setupGlobalData(animData, svg);
      this.globalData.defs = defs;
      this.layers = animData.layers;
      this.layerElement = this.resizerElem;
      this.build3dContainers();
      this.updateContainerSize();
    };

    HybridRenderer.prototype.destroy = function () {
      if (this.animationItem.wrapper) {
        this.animationItem.wrapper.innerText = '';
      }
      this.animationItem.container = null;
      this.globalData.defs = null;
      var i;
      var len = this.layers ? this.layers.length : 0;
      for (i = 0; i < len; i += 1) {
        this.elements[i].destroy();
      }
      this.elements.length = 0;
      this.destroyed = true;
      this.animationItem = null;
    };

    HybridRenderer.prototype.updateContainerSize = function () {
      var elementWidth = this.animationItem.wrapper.offsetWidth;
      var elementHeight = this.animationItem.wrapper.offsetHeight;
      var elementRel = elementWidth / elementHeight;
      var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;
      var sx;
      var sy;
      var tx;
      var ty;
      if (animationRel > elementRel) {
        sx = elementWidth / (this.globalData.compSize.w);
        sy = elementWidth / (this.globalData.compSize.w);
        tx = 0;
        ty = ((elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2);
      } else {
        sx = elementHeight / (this.globalData.compSize.h);
        sy = elementHeight / (this.globalData.compSize.h);
        tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;
        ty = 0;
      }
      var style = this.resizerElem.style;
      style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';
      style.transform = style.webkitTransform;
    };

    HybridRenderer.prototype.renderFrame = SVGRenderer.prototype.renderFrame;

    HybridRenderer.prototype.hide = function () {
      this.resizerElem.style.display = 'none';
    };

    HybridRenderer.prototype.show = function () {
      this.resizerElem.style.display = 'block';
    };

    HybridRenderer.prototype.initItems = function () {
      this.buildAllItems();
      if (this.camera) {
        this.camera.setup();
      } else {
        var cWidth = this.globalData.compSize.w;
        var cHeight = this.globalData.compSize.h;
        var i;
        var len = this.threeDElements.length;
        for (i = 0; i < len; i += 1) {
          var style = this.threeDElements[i].perspectiveElem.style;
          style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';
          style.perspective = style.webkitPerspective;
        }
      }
    };

    HybridRenderer.prototype.searchExtraCompositions = function (assets) {
      var i;
      var len = assets.length;
      var floatingContainer = createTag('div');
      for (i = 0; i < len; i += 1) {
        if (assets[i].xt) {
          var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);
          comp.initExpressions();
          this.globalData.projectInterface.registerComposition(comp);
        }
      }
    };

    /* global createSizedArray, createElementID, PropertyFactory, ShapePropertyFactory, createNS, locationHref */

    function MaskElement(data, element, globalData) {
      this.data = data;
      this.element = element;
      this.globalData = globalData;
      this.storedData = [];
      this.masksProperties = this.data.masksProperties || [];
      this.maskElement = null;
      var defs = this.globalData.defs;
      var i;
      var len = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(len);
      this.solidPath = '';

      var path;
      var properties = this.masksProperties;
      var count = 0;
      var currentMasks = [];
      var j;
      var jLen;
      var layerId = createElementID();
      var rect;
      var expansor;
      var feMorph;
      var x;
      var maskType = 'clipPath';
      var maskRef = 'clip-path';
      for (i = 0; i < len; i += 1) {
        if ((properties[i].mode !== 'a' && properties[i].mode !== 'n') || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {
          maskType = 'mask';
          maskRef = 'mask';
        }

        if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {
          rect = createNS('rect');
          rect.setAttribute('fill', '#ffffff');
          rect.setAttribute('width', this.element.comp.data.w || 0);
          rect.setAttribute('height', this.element.comp.data.h || 0);
          currentMasks.push(rect);
        } else {
          rect = null;
        }

        path = createNS('path');
        if (properties[i].mode === 'n') {
          // TODO move this to a factory or to a constructor
          this.viewData[i] = {
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            elem: path,
            lastPath: '',
          };
          defs.appendChild(path);
        } else {
          count += 1;

          path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');
          path.setAttribute('clip-rule', 'nonzero');
          var filterID;

          if (properties[i].x.k !== 0) {
            maskType = 'mask';
            maskRef = 'mask';
            x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);
            filterID = createElementID();
            expansor = createNS('filter');
            expansor.setAttribute('id', filterID);
            feMorph = createNS('feMorphology');
            feMorph.setAttribute('operator', 'erode');
            feMorph.setAttribute('in', 'SourceGraphic');
            feMorph.setAttribute('radius', '0');
            expansor.appendChild(feMorph);
            defs.appendChild(expansor);
            path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');
          } else {
            feMorph = null;
            x = null;
          }

          // TODO move this to a factory or to a constructor
          this.storedData[i] = {
            elem: path,
            x: x,
            expan: feMorph,
            lastPath: '',
            lastOperator: '',
            filterId: filterID,
            lastRadius: 0,
          };
          if (properties[i].mode === 'i') {
            jLen = currentMasks.length;
            var g = createNS('g');
            for (j = 0; j < jLen; j += 1) {
              g.appendChild(currentMasks[j]);
            }
            var mask = createNS('mask');
            mask.setAttribute('mask-type', 'alpha');
            mask.setAttribute('id', layerId + '_' + count);
            mask.appendChild(path);
            defs.appendChild(mask);
            g.setAttribute('mask', 'url(' + locationHref + '#' + layerId + '_' + count + ')');

            currentMasks.length = 0;
            currentMasks.push(g);
          } else {
            currentMasks.push(path);
          }
          if (properties[i].inv && !this.solidPath) {
            this.solidPath = this.createLayerSolidPath();
          }
          // TODO move this to a factory or to a constructor
          this.viewData[i] = {
            elem: path,
            lastPath: '',
            op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),
            invRect: rect,
          };
          if (!this.viewData[i].prop.k) {
            this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);
          }
        }
      }

      this.maskElement = createNS(maskType);

      len = currentMasks.length;
      for (i = 0; i < len; i += 1) {
        this.maskElement.appendChild(currentMasks[i]);
      }

      if (count > 0) {
        this.maskElement.setAttribute('id', layerId);
        this.element.maskedElement.setAttribute(maskRef, 'url(' + locationHref + '#' + layerId + ')');
        defs.appendChild(this.maskElement);
      }
      if (this.viewData.length) {
        this.element.addRenderableComponent(this);
      }
    }

    MaskElement.prototype.getMaskProperty = function (pos) {
      return this.viewData[pos].prop;
    };

    MaskElement.prototype.renderFrame = function (isFirstFrame) {
      var finalMat = this.element.finalTransform.mat;
      var i;
      var len = this.masksProperties.length;
      for (i = 0; i < len; i += 1) {
        if (this.viewData[i].prop._mdf || isFirstFrame) {
          this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);
        }
        if (this.viewData[i].op._mdf || isFirstFrame) {
          this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);
        }
        if (this.masksProperties[i].mode !== 'n') {
          if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
            this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());
          }
          if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {
            var feMorph = this.storedData[i].expan;
            if (this.storedData[i].x.v < 0) {
              if (this.storedData[i].lastOperator !== 'erode') {
                this.storedData[i].lastOperator = 'erode';
                this.storedData[i].elem.setAttribute('filter', 'url(' + locationHref + '#' + this.storedData[i].filterId + ')');
              }
              feMorph.setAttribute('radius', -this.storedData[i].x.v);
            } else {
              if (this.storedData[i].lastOperator !== 'dilate') {
                this.storedData[i].lastOperator = 'dilate';
                this.storedData[i].elem.setAttribute('filter', null);
              }
              this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);
            }
          }
        }
      }
    };

    MaskElement.prototype.getMaskelement = function () {
      return this.maskElement;
    };

    MaskElement.prototype.createLayerSolidPath = function () {
      var path = 'M0,0 ';
      path += ' h' + this.globalData.compSize.w;
      path += ' v' + this.globalData.compSize.h;
      path += ' h-' + this.globalData.compSize.w;
      path += ' v-' + this.globalData.compSize.h + ' ';
      return path;
    };

    MaskElement.prototype.drawPath = function (pathData, pathNodes, viewData) {
      var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
      var i;
      var len;
      len = pathNodes._length;
      for (i = 1; i < len; i += 1) {
        // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
        pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];
      }
      // pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
      if (pathNodes.c && len > 1) {
        pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];
      }
      // pathNodes.__renderedString = pathString;

      if (viewData.lastPath !== pathString) {
        var pathShapeValue = '';
        if (viewData.elem) {
          if (pathNodes.c) {
            pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
          }
          viewData.elem.setAttribute('d', pathShapeValue);
        }
        viewData.lastPath = pathString;
      }
    };

    MaskElement.prototype.destroy = function () {
      this.element = null;
      this.globalData = null;
      this.maskElement = null;
      this.data = null;
      this.masksProperties = null;
    };

    /**
     * @file
     * Handles AE's layer parenting property.
     *
     */

    function HierarchyElement() {}

    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function () {
        // element's parent list
        this.hierarchy = [];
        // if element is parent of another layer _isParent will be true
        this._isParent = false;
        this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function (hierarchy) {
        this.hierarchy = hierarchy;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function () {
        this._isParent = true;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function () {
        if (this.data.parent !== undefined) {
          this.comp.buildElementParenting(this, this.data.parent, []);
        }
      },
    };

    /**
     * @file
     * Handles element's layer frame update.
     * Checks layer in point and out point
     *
     */

    function FrameElement() {}

    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function () {
        // set to true when inpoint is rendered
        this._isFirstFrame = false;
        // list of animated properties
        this.dynamicProperties = [];
        // If layer has been modified in current tick this will be true
        this._mdf = false;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function (num, isVisible) {
        var i;
        var len = this.dynamicProperties.length;
        for (i = 0; i < len; i += 1) {
          if (isVisible || (this._isParent && this.dynamicProperties[i].propType === 'transform')) {
            this.dynamicProperties[i].getValue();
            if (this.dynamicProperties[i]._mdf) {
              this.globalData._mdf = true;
              this._mdf = true;
            }
          }
        }
      },
      addDynamicProperty: function (prop) {
        if (this.dynamicProperties.indexOf(prop) === -1) {
          this.dynamicProperties.push(prop);
        }
      },
    };

    /* global TransformPropertyFactory, Matrix */

    function TransformElement() {}

    TransformElement.prototype = {
      initTransform: function () {
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
          _matMdf: false,
          _opMdf: false,
          mat: new Matrix(),
        };
        if (this.data.ao) {
          this.finalTransform.mProp.autoOriented = true;
        }

        // TODO: check TYPE 11: Guided elements
        if (this.data.ty !== 11) ;
      },
      renderTransform: function () {
        this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
        this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;

        if (this.hierarchy) {
          var mat;
          var finalMat = this.finalTransform.mat;
          var i = 0;
          var len = this.hierarchy.length;
          // Checking if any of the transformation matrices in the hierarchy chain has changed.
          if (!this.finalTransform._matMdf) {
            while (i < len) {
              if (this.hierarchy[i].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = true;
                break;
              }
              i += 1;
            }
          }

          if (this.finalTransform._matMdf) {
            mat = this.finalTransform.mProp.v.props;
            finalMat.cloneFromProps(mat);
            for (i = 0; i < len; i += 1) {
              mat = this.hierarchy[i].finalTransform.mProp.v.props;
              finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
            }
          }
        }
      },
      globalToLocal: function (pt) {
        var transforms = [];
        transforms.push(this.finalTransform);
        var flag = true;
        var comp = this.comp;
        while (flag) {
          if (comp.finalTransform) {
            if (comp.data.hasMask) {
              transforms.splice(0, 0, comp.finalTransform);
            }
            comp = comp.comp;
          } else {
            flag = false;
          }
        }
        var i;
        var len = transforms.length;
        var ptNew;
        for (i = 0; i < len; i += 1) {
          ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);
          // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
          pt = [pt[0] - ptNew[0], pt[1] - ptNew[1], 0];
        }
        return pt;
      },
      mHelper: new Matrix(),
    };

    function RenderableElement() {

    }

    RenderableElement.prototype = {
      initRenderable: function () {
        // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
        this.isInRange = false;
        // layer's display state
        this.hidden = false;
        // If layer's transparency equals 0, it can be hidden
        this.isTransparent = false;
        // list of animated components
        this.renderableComponents = [];
      },
      addRenderableComponent: function (component) {
        if (this.renderableComponents.indexOf(component) === -1) {
          this.renderableComponents.push(component);
        }
      },
      removeRenderableComponent: function (component) {
        if (this.renderableComponents.indexOf(component) !== -1) {
          this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
        }
      },
      prepareRenderableFrame: function (num) {
        this.checkLayerLimits(num);
      },
      checkTransparency: function () {
        if (this.finalTransform.mProp.o.v <= 0) {
          if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
            this.isTransparent = true;
            this.hide();
          }
        } else if (this.isTransparent) {
          this.isTransparent = false;
          this.show();
        }
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function (num) {
        if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
          if (this.isInRange !== true) {
            this.globalData._mdf = true;
            this._mdf = true;
            this.isInRange = true;
            this.show();
          }
        } else if (this.isInRange !== false) {
          this.globalData._mdf = true;
          this.isInRange = false;
          this.hide();
        }
      },
      renderRenderable: function () {
        var i;
        var len = this.renderableComponents.length;
        for (i = 0; i < len; i += 1) {
          this.renderableComponents[i].renderFrame(this._isFirstFrame);
        }
        /* this.maskManager.renderFrame(this.finalTransform.mat);
            this.renderableEffectsManager.renderFrame(this._isFirstFrame); */
      },
      sourceRectAtTime: function () {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100,
        };
      },
      getLayerSize: function () {
        if (this.data.ty === 5) {
          return { w: this.data.textData.width, h: this.data.textData.height };
        }
        return { w: this.data.width, h: this.data.height };
      },
    };

    /* global extendPrototype, RenderableElement, createProxyFunction */

    function RenderableDOMElement() {}

    (function () {
      var _prototype = {
        initElement: function (data, globalData, comp) {
          this.initFrame();
          this.initBaseData(data, globalData, comp);
          this.initTransform(data, globalData, comp);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
        },
        hide: function () {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var elem = this.baseElement || this.layerElement;
            elem.style.display = 'none';
            this.hidden = true;
          }
        },
        show: function () {
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var elem = this.baseElement || this.layerElement;
              elem.style.display = 'block';
            }
            this.hidden = false;
            this._isFirstFrame = true;
          }
        },
        renderFrame: function () {
          // If it is exported as hidden (data.hd === true) no need to render
          // If it is not visible no need to render
          if (this.data.hd || this.hidden) {
            return;
          }
          this.renderTransform();
          this.renderRenderable();
          this.renderElement();
          this.renderInnerContent();
          if (this._isFirstFrame) {
            this._isFirstFrame = false;
          }
        },
        renderInnerContent: function () {},
        prepareFrame: function (num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          this.checkTransparency();
        },
        destroy: function () {
          this.innerElem = null;
          this.destroyBaseElement();
        },
      };
      extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
    }());

    /* exported ProcessedElement */

    function ProcessedElement(element, position) {
      this.elem = element;
      this.pos = position;
    }

    /* global createNS */

    function SVGStyleData(data, level) {
      this.data = data;
      this.type = data.ty;
      this.d = '';
      this.lvl = level;
      this._mdf = false;
      this.closed = data.hd === true;
      this.pElem = createNS('path');
      this.msElem = null;
    }

    SVGStyleData.prototype.reset = function () {
      this.d = '';
      this._mdf = false;
    };

    function SVGShapeData(transformers, level, shape) {
      this.caches = [];
      this.styles = [];
      this.transformers = transformers;
      this.lStr = '';
      this.sh = shape;
      this.lvl = level;
      // TODO find if there are some cases where _isAnimated can be false.
      // For now, since shapes add up with other shapes. They have to be calculated every time.
      // One way of finding out is checking if all styles associated to this shape depend only of this shape
      this._isAnimated = !!shape.k;
      // TODO: commenting this for now since all shapes are animated
      var i = 0;
      var len = transformers.length;
      while (i < len) {
        if (transformers[i].mProps.dynamicProperties.length) {
          this._isAnimated = true;
          break;
        }
        i += 1;
      }
    }

    SVGShapeData.prototype.setAsAnimated = function () {
      this._isAnimated = true;
    };

    /* exported SVGTransformData */

    function SVGTransformData(mProps, op, container) {
      this.transform = {
        mProps: mProps,
        op: op,
        container: container,
      };
      this.elements = [];
      this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }

    /* global DashProperty, PropertyFactory, extendPrototype, DynamicPropertyContainer */

    function SVGStrokeStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
      this.d = new DashProperty(elem, data.d || {}, 'svg', this);
      this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
      this.style = styleOb;
      this._isAnimated = !!this._isAnimated;
    }

    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);

    /* global PropertyFactory, extendPrototype, DynamicPropertyContainer */

    function SVGFillStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
      this.style = styleOb;
    }

    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);

    /* global PropertyFactory, degToRads, GradientProperty, createElementID, createNS, locationHref,
    extendPrototype, DynamicPropertyContainer, lineCapEnum, lineJoinEnum */

    function SVGGradientFillStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.initGradientData(elem, data, styleOb);
    }

    SVGGradientFillStyleData.prototype.initGradientData = function (elem, data, styleOb) {
      this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
      this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
      this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
      this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
      this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
      this.g = new GradientProperty(elem, data.g, this);
      this.style = styleOb;
      this.stops = [];
      this.setGradientData(styleOb.pElem, data);
      this.setGradientOpacity(data, styleOb);
      this._isAnimated = !!this._isAnimated;
    };

    SVGGradientFillStyleData.prototype.setGradientData = function (pathElement, data) {
      var gradientId = createElementID();
      var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
      gfill.setAttribute('id', gradientId);
      gfill.setAttribute('spreadMethod', 'pad');
      gfill.setAttribute('gradientUnits', 'userSpaceOnUse');
      var stops = [];
      var stop;
      var j;
      var jLen;
      jLen = data.g.p * 4;
      for (j = 0; j < jLen; j += 4) {
        stop = createNS('stop');
        gfill.appendChild(stop);
        stops.push(stop);
      }
      pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + gradientId + ')');
      this.gf = gfill;
      this.cst = stops;
    };

    SVGGradientFillStyleData.prototype.setGradientOpacity = function (data, styleOb) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var stop;
        var j;
        var jLen;
        var mask = createNS('mask');
        var maskElement = createNS('path');
        mask.appendChild(maskElement);
        var opacityId = createElementID();
        var maskId = createElementID();
        mask.setAttribute('id', maskId);
        var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');
        opFill.setAttribute('id', opacityId);
        opFill.setAttribute('spreadMethod', 'pad');
        opFill.setAttribute('gradientUnits', 'userSpaceOnUse');
        jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
        var stops = this.stops;
        for (j = data.g.p * 4; j < jLen; j += 2) {
          stop = createNS('stop');
          stop.setAttribute('stop-color', 'rgb(255,255,255)');
          opFill.appendChild(stop);
          stops.push(stop);
        }
        maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + locationHref + '#' + opacityId + ')');
        if (data.ty === 'gs') {
          maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
          maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
          if (data.lj === 1) {
            maskElement.setAttribute('stroke-miterlimit', data.ml);
          }
        }
        this.of = opFill;
        this.ms = mask;
        this.ost = stops;
        this.maskId = maskId;
        styleOb.msElem = maskElement;
      }
    };

    extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);

    /* global PropertyFactory, DashProperty, extendPrototype, SVGGradientFillStyleData, DynamicPropertyContainer */

    function SVGGradientStrokeStyleData(elem, data, styleOb) {
      this.initDynamicPropertyContainer(elem);
      this.getValue = this.iterateDynamicProperties;
      this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
      this.d = new DashProperty(elem, data.d || {}, 'svg', this);
      this.initGradientData(elem, data, styleOb);
      this._isAnimated = !!this._isAnimated;
    }

    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);

    /* global createNS */
    /* exported ShapeGroupData */

    function ShapeGroupData() {
      this.it = [];
      this.prevViewData = [];
      this.gr = createNS('g');
    }

    /* global Matrix, buildShapeString, bmFloor */
    /* exported SVGElementsRenderer */

    var SVGElementsRenderer = (function () {
      var _identityMatrix = new Matrix();
      var _matrixHelper = new Matrix();

      var ob = {
        createRenderFunction: createRenderFunction,
      };

      function createRenderFunction(data) {
        switch (data.ty) {
          case 'fl':
            return renderFill;
          case 'gf':
            return renderGradient;
          case 'gs':
            return renderGradientStroke;
          case 'st':
            return renderStroke;
          case 'sh':
          case 'el':
          case 'rc':
          case 'sr':
            return renderPath;
          case 'tr':
            return renderContentTransform;
          default:
            return null;
        }
      }

      function renderContentTransform(styleData, itemData, isFirstFrame) {
        if (isFirstFrame || itemData.transform.op._mdf) {
          itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);
        }
        if (isFirstFrame || itemData.transform.mProps._mdf) {
          itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());
        }
      }

      function renderPath(styleData, itemData, isFirstFrame) {
        var j;
        var jLen;
        var pathStringTransformed;
        var redraw;
        var pathNodes;
        var l;
        var lLen = itemData.styles.length;
        var lvl = itemData.lvl;
        var paths;
        var mat;
        var props;
        var iterations;
        var k;
        for (l = 0; l < lLen; l += 1) {
          redraw = itemData.sh._mdf || isFirstFrame;
          if (itemData.styles[l].lvl < lvl) {
            mat = _matrixHelper.reset();
            iterations = lvl - itemData.styles[l].lvl;
            k = itemData.transformers.length - 1;
            while (!redraw && iterations > 0) {
              redraw = itemData.transformers[k].mProps._mdf || redraw;
              iterations -= 1;
              k -= 1;
            }
            if (redraw) {
              iterations = lvl - itemData.styles[l].lvl;
              k = itemData.transformers.length - 1;
              while (iterations > 0) {
                props = itemData.transformers[k].mProps.v.props;
                mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                iterations -= 1;
                k -= 1;
              }
            }
          } else {
            mat = _identityMatrix;
          }
          paths = itemData.sh.paths;
          jLen = paths._length;
          if (redraw) {
            pathStringTransformed = '';
            for (j = 0; j < jLen; j += 1) {
              pathNodes = paths.shapes[j];
              if (pathNodes && pathNodes._length) {
                pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
              }
            }
            itemData.caches[l] = pathStringTransformed;
          } else {
            pathStringTransformed = itemData.caches[l];
          }
          itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;
          itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;
        }
      }

      function renderFill(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;

        if (itemData.c._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);
        }
      }

      function renderGradientStroke(styleData, itemData, isFirstFrame) {
        renderGradient(styleData, itemData, isFirstFrame);
        renderStroke(styleData, itemData, isFirstFrame);
      }

      function renderGradient(styleData, itemData, isFirstFrame) {
        var gfill = itemData.gf;
        var hasOpacity = itemData.g._hasOpacity;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;

        if (itemData.o._mdf || isFirstFrame) {
          var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';
          itemData.style.pElem.setAttribute(attr, itemData.o.v);
        }
        if (itemData.s._mdf || isFirstFrame) {
          var attr1 = styleData.t === 1 ? 'x1' : 'cx';
          var attr2 = attr1 === 'x1' ? 'y1' : 'cy';
          gfill.setAttribute(attr1, pt1[0]);
          gfill.setAttribute(attr2, pt1[1]);
          if (hasOpacity && !itemData.g._collapsable) {
            itemData.of.setAttribute(attr1, pt1[0]);
            itemData.of.setAttribute(attr2, pt1[1]);
          }
        }
        var stops;
        var i;
        var len;
        var stop;
        if (itemData.g._cmdf || isFirstFrame) {
          stops = itemData.cst;
          var cValues = itemData.g.c;
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            stop.setAttribute('offset', cValues[i * 4] + '%');
            stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');
          }
        }
        if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
          var oValues = itemData.g.o;
          if (itemData.g._collapsable) {
            stops = itemData.cst;
          } else {
            stops = itemData.ost;
          }
          len = stops.length;
          for (i = 0; i < len; i += 1) {
            stop = stops[i];
            if (!itemData.g._collapsable) {
              stop.setAttribute('offset', oValues[i * 2] + '%');
            }
            stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);
          }
        }
        if (styleData.t === 1) {
          if (itemData.e._mdf || isFirstFrame) {
            gfill.setAttribute('x2', pt2[0]);
            gfill.setAttribute('y2', pt2[1]);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('x2', pt2[0]);
              itemData.of.setAttribute('y2', pt2[1]);
            }
          }
        } else {
          var rad;
          if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
            rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            gfill.setAttribute('r', rad);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('r', rad);
            }
          }
          if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
            if (!rad) {
              rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
            }
            var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

            var percent = itemData.h.v;
            if (percent >= 1) {
              percent = 0.99;
            } else if (percent <= -1) {
              percent = -0.99;
            }
            var dist = rad * percent;
            var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
            var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
            gfill.setAttribute('fx', x);
            gfill.setAttribute('fy', y);
            if (hasOpacity && !itemData.g._collapsable) {
              itemData.of.setAttribute('fx', x);
              itemData.of.setAttribute('fy', y);
            }
          }
          // gfill.setAttribute('fy','200');
        }
      }

      function renderStroke(styleData, itemData, isFirstFrame) {
        var styleElem = itemData.style;
        var d = itemData.d;
        if (d && (d._mdf || isFirstFrame) && d.dashStr) {
          styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);
          styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);
        }
        if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
          styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');
        }
        if (itemData.o._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);
        }
        if (itemData.w._mdf || isFirstFrame) {
          styleElem.pElem.setAttribute('stroke-width', itemData.w.v);
          if (styleElem.msElem) {
            styleElem.msElem.setAttribute('stroke-width', itemData.w.v);
          }
        }
      }

      return ob;
    }());

    /* global Matrix */

    function ShapeTransformManager() {
      this.sequences = {};
      this.sequenceList = [];
      this.transform_key_count = 0;
    }

    ShapeTransformManager.prototype = {
      addTransformSequence: function (transforms) {
        var i;
        var len = transforms.length;
        var key = '_';
        for (i = 0; i < len; i += 1) {
          key += transforms[i].transform.key + '_';
        }
        var sequence = this.sequences[key];
        if (!sequence) {
          sequence = {
            transforms: [].concat(transforms),
            finalTransform: new Matrix(),
            _mdf: false,
          };
          this.sequences[key] = sequence;
          this.sequenceList.push(sequence);
        }
        return sequence;
      },
      processSequence: function (sequence, isFirstFrame) {
        var i = 0;
        var len = sequence.transforms.length;
        var _mdf = isFirstFrame;
        while (i < len && !isFirstFrame) {
          if (sequence.transforms[i].transform.mProps._mdf) {
            _mdf = true;
            break;
          }
          i += 1;
        }
        if (_mdf) {
          var props;
          sequence.finalTransform.reset();
          for (i = len - 1; i >= 0; i -= 1) {
            props = sequence.transforms[i].transform.mProps.v.props;
            sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
          }
        }
        sequence._mdf = _mdf;
      },
      processSequences: function (isFirstFrame) {
        var i;
        var len = this.sequenceList.length;
        for (i = 0; i < len; i += 1) {
          this.processSequence(this.sequenceList[i], isFirstFrame);
        }
      },
      getNewKey: function () {
        this.transform_key_count += 1;
        return '_' + this.transform_key_count;
      },
    };

    /* global ShapePropertyFactory, SVGShapeData */

    function CVShapeData(element, data, styles, transformsManager) {
      this.styledShapes = [];
      this.tr = [0, 0, 0, 0, 0, 0];
      var ty = 4;
      if (data.ty === 'rc') {
        ty = 5;
      } else if (data.ty === 'el') {
        ty = 6;
      } else if (data.ty === 'sr') {
        ty = 7;
      }
      this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);
      var i;
      var len = styles.length;
      var styledShape;
      for (i = 0; i < len; i += 1) {
        if (!styles[i].closed) {
          styledShape = {
            transforms: transformsManager.addTransformSequence(styles[i].transforms),
            trNodes: [],
          };
          this.styledShapes.push(styledShape);
          styles[i].elements.push(styledShape);
        }
      }
    }

    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;

    /* global LayerExpressionInterface, EffectsExpressionInterface, CompExpressionInterface, ShapeExpressionInterface,
    TextExpressionInterface, getBlendMode,createElementID, EffectsManager */

    function BaseElement() {
    }

    BaseElement.prototype = {
      checkMasks: function () {
        if (!this.data.hasMask) {
          return false;
        }
        var i = 0;
        var len = this.data.masksProperties.length;
        while (i < len) {
          if ((this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false)) {
            return true;
          }
          i += 1;
        }
        return false;
      },
      initExpressions: function () {
        this.layerInterface = LayerExpressionInterface(this);
        if (this.data.hasMask && this.maskManager) {
          this.layerInterface.registerMaskInterface(this.maskManager);
        }
        var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
        this.layerInterface.registerEffectsInterface(effectsInterface);

        if (this.data.ty === 0 || this.data.xt) {
          this.compInterface = CompExpressionInterface(this);
        } else if (this.data.ty === 4) {
          this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
          this.layerInterface.content = this.layerInterface.shapeInterface;
        } else if (this.data.ty === 5) {
          this.layerInterface.textInterface = TextExpressionInterface(this);
          this.layerInterface.text = this.layerInterface.textInterface;
        }
      },
      setBlendMode: function () {
        var blendModeValue = getBlendMode(this.data.bm);
        var elem = this.baseElement || this.layerElement;

        elem.style['mix-blend-mode'] = blendModeValue;
      },
      initBaseData: function (data, globalData, comp) {
        this.globalData = globalData;
        this.comp = comp;
        this.data = data;
        this.layerId = createElementID();

        // Stretch factor for old animations missing this property.
        if (!this.data.sr) {
          this.data.sr = 1;
        }
        // effects manager
        this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function () {
        return this.type;
      },
      sourceRectAtTime: function () {},
    };

    /* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement */

    function NullElement(data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initFrame();
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
    }

    NullElement.prototype.prepareFrame = function (num) {
      this.prepareProperties(num, true);
    };

    NullElement.prototype.renderFrame = function () {
    };

    NullElement.prototype.getBaseElement = function () {
      return null;
    };

    NullElement.prototype.destroy = function () {
    };

    NullElement.prototype.sourceRectAtTime = function () {
    };

    NullElement.prototype.hide = function () {
    };

    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);

    /* global filtersFactory, featureSupport, filtersFactory, createElementID, createNS, MaskElement, SVGEffects, locationHref */

    function SVGBaseElement() {
    }

    SVGBaseElement.prototype = {
      initRendererElement: function () {
        this.layerElement = createNS('g');
      },
      createContainerElements: function () {
        this.matteElement = createNS('g');
        this.transformedElement = this.layerElement;
        this.maskedElement = this.layerElement;
        this._sizeChanged = false;
        var layerElementParent = null;
        // If this layer acts as a mask for the following layer
        var filId;
        var fil;
        var gg;
        if (this.data.td) {
          if (this.data.td == 3 || this.data.td == 1) { // eslint-disable-line eqeqeq
            var masker = createNS('mask');
            masker.setAttribute('id', this.layerId);
            masker.setAttribute('mask-type', this.data.td == 3 ? 'luminance' : 'alpha'); // eslint-disable-line eqeqeq
            masker.appendChild(this.layerElement);
            layerElementParent = masker;
            this.globalData.defs.appendChild(masker);
            // This is only for IE and Edge when mask if of type alpha
            if (!featureSupport.maskType && this.data.td == 1) { // eslint-disable-line eqeqeq
              masker.setAttribute('mask-type', 'luminance');
              filId = createElementID();
              fil = filtersFactory.createFilter(filId);
              this.globalData.defs.appendChild(fil);
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS('g');
              gg.appendChild(this.layerElement);
              layerElementParent = gg;
              masker.appendChild(gg);
              gg.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
            }
          } else if (this.data.td == 2) { // eslint-disable-line eqeqeq
            var maskGroup = createNS('mask');
            maskGroup.setAttribute('id', this.layerId);
            maskGroup.setAttribute('mask-type', 'alpha');
            var maskGrouper = createNS('g');
            maskGroup.appendChild(maskGrouper);
            filId = createElementID();
            fil = filtersFactory.createFilter(filId);
            /// /

            // This solution doesn't work on Android when meta tag with viewport attribute is set
            /* var feColorMatrix = createNS('feColorMatrix');
                    feColorMatrix.setAttribute('type', 'matrix');
                    feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
                    feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 -1 1');
                    fil.appendChild(feColorMatrix); */
            /// /
            var feCTr = createNS('feComponentTransfer');
            feCTr.setAttribute('in', 'SourceGraphic');
            fil.appendChild(feCTr);
            var feFunc = createNS('feFuncA');
            feFunc.setAttribute('type', 'table');
            feFunc.setAttribute('tableValues', '1.0 0.0');
            feCTr.appendChild(feFunc);
            /// /
            this.globalData.defs.appendChild(fil);
            var alphaRect = createNS('rect');
            alphaRect.setAttribute('width', this.comp.data.w);
            alphaRect.setAttribute('height', this.comp.data.h);
            alphaRect.setAttribute('x', '0');
            alphaRect.setAttribute('y', '0');
            alphaRect.setAttribute('fill', '#ffffff');
            alphaRect.setAttribute('opacity', '0');
            maskGrouper.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
            maskGrouper.appendChild(alphaRect);
            maskGrouper.appendChild(this.layerElement);
            layerElementParent = maskGrouper;
            if (!featureSupport.maskType) {
              maskGroup.setAttribute('mask-type', 'luminance');
              fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
              gg = createNS('g');
              maskGrouper.appendChild(alphaRect);
              gg.appendChild(this.layerElement);
              layerElementParent = gg;
              maskGrouper.appendChild(gg);
            }
            this.globalData.defs.appendChild(maskGroup);
          }
        } else if (this.data.tt) {
          this.matteElement.appendChild(this.layerElement);
          layerElementParent = this.matteElement;
          this.baseElement = this.matteElement;
        } else {
          this.baseElement = this.layerElement;
        }
        if (this.data.ln) {
          this.layerElement.setAttribute('id', this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute('class', this.data.cl);
        }
        // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
        if (this.data.ty === 0 && !this.data.hd) {
          var cp = createNS('clipPath');
          var pt = createNS('path');
          pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');
          var clipId = createElementID();
          cp.setAttribute('id', clipId);
          cp.appendChild(pt);
          this.globalData.defs.appendChild(cp);

          if (this.checkMasks()) {
            var cpGroup = createNS('g');
            cpGroup.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
            cpGroup.appendChild(this.layerElement);
            this.transformedElement = cpGroup;
            if (layerElementParent) {
              layerElementParent.appendChild(this.transformedElement);
            } else {
              this.baseElement = this.transformedElement;
            }
          } else {
            this.layerElement.setAttribute('clip-path', 'url(' + locationHref + '#' + clipId + ')');
          }
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function () {
        if (this.finalTransform._matMdf) {
          this.transformedElement.setAttribute('transform', this.finalTransform.mat.to2dCSS());
        }
        if (this.finalTransform._opMdf) {
          this.transformedElement.setAttribute('opacity', this.finalTransform.mProp.o.v);
        }
      },
      destroyBaseElement: function () {
        this.layerElement = null;
        this.matteElement = null;
        this.maskManager.destroy();
      },
      getBaseElement: function () {
        if (this.data.hd) {
          return null;
        }
        return this.baseElement;
      },
      createRenderableComponents: function () {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
        this.renderableEffectsManager = new SVGEffects(this);
      },
      setMatte: function (id) {
        if (!this.matteElement) {
          return;
        }
        this.matteElement.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
      },
    };

    /* global ProcessedElement */

    function IShapeElement() {
    }

    IShapeElement.prototype = {
      addShapeToModifiers: function (data) {
        var i;
        var len = this.shapeModifiers.length;
        for (i = 0; i < len; i += 1) {
          this.shapeModifiers[i].addShape(data);
        }
      },
      isShapeInAnimatedModifiers: function (data) {
        var i = 0;
        var len = this.shapeModifiers.length;
        while (i < len) {
          if (this.shapeModifiers[i].isAnimatedWithShape(data)) {
            return true;
          }
        }
        return false;
      },
      renderModifiers: function () {
        if (!this.shapeModifiers.length) {
          return;
        }
        var i;
        var len = this.shapes.length;
        for (i = 0; i < len; i += 1) {
          this.shapes[i].sh.reset();
        }

        len = this.shapeModifiers.length;
        var shouldBreakProcess;
        for (i = len - 1; i >= 0; i -= 1) {
          shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);
          // workaround to fix cases where a repeater resets the shape so the following processes get called twice
          // TODO: find a better solution for this
          if (shouldBreakProcess) {
            break;
          }
        }
      },

      searchProcessedElement: function (elem) {
        var elements = this.processedElements;
        var i = 0;
        var len = elements.length;
        while (i < len) {
          if (elements[i].elem === elem) {
            return elements[i].pos;
          }
          i += 1;
        }
        return 0;
      },
      addProcessedElement: function (elem, pos) {
        var elements = this.processedElements;
        var i = elements.length;
        while (i) {
          i -= 1;
          if (elements[i].elem === elem) {
            elements[i].pos = pos;
            return;
          }
        }
        elements.push(new ProcessedElement(elem, pos));
      },
      prepareFrame: function (num) {
        this.prepareRenderableFrame(num);
        this.prepareProperties(num, this.isInRange);
      },
    };

    /* global TextProperty, TextAnimatorProperty, buildShapeString, LetterProps */

    function ITextElement() {
    }

    ITextElement.prototype.initElement = function (data, globalData, comp) {
      this.lettersChangedFlag = true;
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
      this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
      this.initTransform(data, globalData, comp);
      this.initHierarchy();
      this.initRenderable();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      this.createContent();
      this.hide();
      this.textAnimator.searchProperties(this.dynamicProperties);
    };

    ITextElement.prototype.prepareFrame = function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
        this.buildNewText();
        this.textProperty._isFirstFrame = false;
        this.textProperty._mdf = false;
      }
    };

    ITextElement.prototype.createPathShape = function (matrixHelper, shapes) {
      var j;
      var jLen = shapes.length;
      var pathNodes;
      var shapeStr = '';
      for (j = 0; j < jLen; j += 1) {
        pathNodes = shapes[j].ks.k;
        shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
      }
      return shapeStr;
    };

    ITextElement.prototype.updateDocumentData = function (newData, index) {
      this.textProperty.updateDocumentData(newData, index);
    };

    ITextElement.prototype.canResizeFont = function (_canResize) {
      this.textProperty.canResizeFont(_canResize);
    };

    ITextElement.prototype.setMinimumFontSize = function (_fontSize) {
      this.textProperty.setMinimumFontSize(_fontSize);
    };

    ITextElement.prototype.applyTextPropertiesToMatrix = function (documentData, matrixHelper, lineNumber, xPos, yPos) {
      if (documentData.ps) {
        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
      }
      matrixHelper.translate(0, -documentData.ls, 0);
      switch (documentData.j) {
        case 1:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
          break;
        case 2:
          matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
          break;
      }
      matrixHelper.translate(xPos, yPos, 0);
    };

    ITextElement.prototype.buildColor = function (colorData) {
      return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';
    };

    ITextElement.prototype.emptyProp = new LetterProps();

    ITextElement.prototype.destroy = function () {

    };

    /* global extendPrototype, BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement */

    function ICompElement() {}

    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);

    ICompElement.prototype.initElement = function (data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initTransform(data, globalData, comp);
      this.initRenderable();
      this.initHierarchy();
      this.initRendererElement();
      this.createContainerElements();
      this.createRenderableComponents();
      if (this.data.xt || !globalData.progressiveLoad) {
        this.buildAllItems();
      }
      this.hide();
    };

    /* ICompElement.prototype.hide = function(){
        if(!this.hidden){
            this.hideElement();
            var i,len = this.elements.length;
            for( i = 0; i < len; i+=1 ){
                if(this.elements[i]){
                    this.elements[i].hide();
                }
            }
        }
    }; */

    ICompElement.prototype.prepareFrame = function (num) {
      this._mdf = false;
      this.prepareRenderableFrame(num);
      this.prepareProperties(num, this.isInRange);
      if (!this.isInRange && !this.data.xt) {
        return;
      }

      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        if (timeRemapped === this.data.op) {
          timeRemapped = this.data.op - 1;
        }
        this.renderedFrame = timeRemapped;
      } else {
        this.renderedFrame = num / this.data.sr;
      }
      var i;
      var len = this.elements.length;
      if (!this.completeLayers) {
        this.checkLayers(this.renderedFrame);
      }
      // This iteration needs to be backwards because of how expressions connect between each other
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);
          if (this.elements[i]._mdf) {
            this._mdf = true;
          }
        }
      }
    };

    ICompElement.prototype.renderInnerContent = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };

    ICompElement.prototype.setElements = function (elems) {
      this.elements = elems;
    };

    ICompElement.prototype.getElements = function () {
      return this.elements;
    };

    ICompElement.prototype.destroyElements = function () {
      var i;
      var len = this.layers.length;
      for (i = 0; i < len; i += 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
    };

    ICompElement.prototype.destroy = function () {
      this.destroyElements();
      this.destroyBaseElement();
    };

    /* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, createNS */

    function IImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      this.initElement(data, globalData, comp);
      this.sourceRect = {
        top: 0, left: 0, width: this.assetData.w, height: this.assetData.h,
      };
    }

    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);

    IImageElement.prototype.createContent = function () {
      var assetPath = this.globalData.getAssetsPath(this.assetData);

      this.innerElem = createNS('image');
      this.innerElem.setAttribute('width', this.assetData.w + 'px');
      this.innerElem.setAttribute('height', this.assetData.h + 'px');
      this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
      this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);

      this.layerElement.appendChild(this.innerElem);
    };

    IImageElement.prototype.sourceRectAtTime = function () {
      return this.sourceRect;
    };

    /* global extendPrototype, IImageElement, createNS */

    function ISolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([IImageElement], ISolidElement);

    ISolidElement.prototype.createContent = function () {
      var rect = createNS('rect');
      /// /rect.style.width = this.data.sw;
      /// /rect.style.height = this.data.sh;
      /// /rect.style.fill = this.data.sc;
      rect.setAttribute('width', this.data.sw);
      rect.setAttribute('height', this.data.sh);
      rect.setAttribute('fill', this.data.sc);
      this.layerElement.appendChild(rect);
    };

    /* global PropertyFactory, extendPrototype, RenderableElement, BaseElement, FrameElement */

    function AudioElement(data, globalData, comp) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData.getAssetData(data.refId);
      this.initBaseData(data, globalData, comp);
      this._isPlaying = false;
      this._canPlay = false;
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(assetPath);
      this._currentTime = 0;
      this.globalData.audioController.addAudio(this);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
    }

    AudioElement.prototype.prepareFrame = function (num) {
      this.prepareRenderableFrame(num, true);
      this.prepareProperties(num, true);
      if (!this.tm._placeholder) {
        var timeRemapped = this.tm.v;
        this._currentTime = timeRemapped;
      } else {
        this._currentTime = num / this.data.sr;
      }
    };

    extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);

    AudioElement.prototype.renderFrame = function () {
      if (this.isInRange && this._canPlay) {
        if (!this._isPlaying) {
          this.audio.play();
          this.audio.seek(this._currentTime / this.globalData.frameRate);
          this._isPlaying = true;
        } else if (!this.audio.playing()
          || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1
        ) {
          this.audio.seek(this._currentTime / this.globalData.frameRate);
        }
      }
    };

    AudioElement.prototype.show = function () {
      // this.audio.play()
    };

    AudioElement.prototype.hide = function () {
      this.audio.pause();
      this._isPlaying = false;
    };

    AudioElement.prototype.pause = function () {
      this.audio.pause();
      this._isPlaying = false;
      this._canPlay = false;
    };

    AudioElement.prototype.resume = function () {
      this._canPlay = true;
    };

    AudioElement.prototype.setRate = function (rateValue) {
      this.audio.rate(rateValue);
    };

    AudioElement.prototype.volume = function (volumeValue) {
      this.audio.volume(volumeValue);
    };

    AudioElement.prototype.getBaseElement = function () {
      return null;
    };

    AudioElement.prototype.destroy = function () {
    };

    AudioElement.prototype.sourceRectAtTime = function () {
    };

    AudioElement.prototype.initExpressions = function () {
    };

    /* global extendPrototype, RenderableElement, BaseElement, FrameElement, FootageInterface */

    function FootageElement(data, globalData, comp) {
      this.initFrame();
      this.initRenderable();
      this.assetData = globalData.getAssetData(data.refId);
      this.footageData = globalData.imageLoader.getAsset(this.assetData);
      this.initBaseData(data, globalData, comp);
    }

    FootageElement.prototype.prepareFrame = function () {
    };

    extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement);

    FootageElement.prototype.getBaseElement = function () {
      return null;
    };

    FootageElement.prototype.renderFrame = function () {
    };

    FootageElement.prototype.destroy = function () {
    };

    FootageElement.prototype.initExpressions = function () {
      this.layerInterface = FootageInterface(this);
    };

    FootageElement.prototype.getFootageData = function () {
      return this.footageData;
    };

    /* global createSizedArray, PropertyFactory, extendPrototype, SVGRenderer, ICompElement, SVGBaseElement */

    function SVGCompElement(data, globalData, comp) {
      this.layers = data.layers;
      this.supports3d = true;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      // this.layerElement = createNS('g');
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
    }

    extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);

    /* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement,
    RenderableDOMElement, ITextElement, createSizedArray, createNS */

    function SVGTextLottieElement(data, globalData, comp) {
      this.textSpans = [];
      this.renderType = 'svg';
      this.initElement(data, globalData, comp);
    }

    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);

    SVGTextLottieElement.prototype.createContent = function () {
      if (this.data.singleShape && !this.globalData.fontManager.chars) {
        this.textContainer = createNS('text');
      }
    };

    SVGTextLottieElement.prototype.buildTextContents = function (textArray) {
      var i = 0;
      var len = textArray.length;
      var textContents = [];
      var currentTextContent = '';
      while (i < len) {
        if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {
          textContents.push(currentTextContent);
          currentTextContent = '';
        } else {
          currentTextContent += textArray[i];
        }
        i += 1;
      }
      textContents.push(currentTextContent);
      return textContents;
    };

    SVGTextLottieElement.prototype.buildNewText = function () {
      var i;
      var len;

      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
      if (documentData.fc) {
        this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));
      } else {
        this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');
      }
      if (documentData.sc) {
        this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));
        this.layerElement.setAttribute('stroke-width', documentData.sw);
      }
      this.layerElement.setAttribute('font-size', documentData.finalSize);
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (fontData.fClass) {
        this.layerElement.setAttribute('class', fontData.fClass);
      } else {
        this.layerElement.setAttribute('font-family', fontData.fFamily);
        var fWeight = documentData.fWeight;
        var fStyle = documentData.fStyle;
        this.layerElement.setAttribute('font-style', fStyle);
        this.layerElement.setAttribute('font-weight', fWeight);
      }
      this.layerElement.setAttribute('aria-label', documentData.t);

      var letters = documentData.l || [];
      var usesGlyphs = !!this.globalData.fontManager.chars;
      len = letters.length;

      var tSpan;
      var matrixHelper = this.mHelper;
      var shapes;
      var shapeStr = '';
      var singleShape = this.data.singleShape;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
      if (singleShape && !usesGlyphs && !documentData.sz) {
        var tElement = this.textContainer;
        var justify = 'start';
        switch (documentData.j) {
          case 1:
            justify = 'end';
            break;
          case 2:
            justify = 'middle';
            break;
          default:
            justify = 'start';
            break;
        }
        tElement.setAttribute('text-anchor', justify);
        tElement.setAttribute('letter-spacing', trackingOffset);
        var textContent = this.buildTextContents(documentData.finalText);
        len = textContent.length;
        yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
        for (i = 0; i < len; i += 1) {
          tSpan = this.textSpans[i] || createNS('tspan');
          tSpan.textContent = textContent[i];
          tSpan.setAttribute('x', 0);
          tSpan.setAttribute('y', yPos);
          tSpan.style.display = 'inherit';
          tElement.appendChild(tSpan);
          this.textSpans[i] = tSpan;
          yPos += documentData.finalLineHeight;
        }

        this.layerElement.appendChild(tElement);
      } else {
        var cachedSpansLength = this.textSpans.length;
        var shapeData;
        var charData;
        for (i = 0; i < len; i += 1) {
          if (!usesGlyphs || !singleShape || i === 0) {
            tSpan = cachedSpansLength > i ? this.textSpans[i] : createNS(usesGlyphs ? 'path' : 'text');
            if (cachedSpansLength <= i) {
              tSpan.setAttribute('stroke-linecap', 'butt');
              tSpan.setAttribute('stroke-linejoin', 'round');
              tSpan.setAttribute('stroke-miterlimit', '4');
              this.textSpans[i] = tSpan;
              this.layerElement.appendChild(tSpan);
            }
            tSpan.style.display = 'inherit';
          }

          matrixHelper.reset();
          matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
          if (singleShape) {
            if (letters[i].n) {
              xPos = -trackingOffset;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              firstLine = false;
            }
            this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
            xPos += letters[i].l || 0;
            // xPos += letters[i].val === ' ' ? 0 : trackingOffset;
            xPos += trackingOffset;
          }
          if (usesGlyphs) {
            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
            shapeData = (charData && charData.data) || {};
            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
            if (!singleShape) {
              tSpan.setAttribute('d', this.createPathShape(matrixHelper, shapes));
            } else {
              shapeStr += this.createPathShape(matrixHelper, shapes);
            }
          } else {
            if (singleShape) {
              tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');
            }
            tSpan.textContent = letters[i].val;
            tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
          }
          //
        }
        if (singleShape && tSpan) {
          tSpan.setAttribute('d', shapeStr);
        }
      }
      while (i < this.textSpans.length) {
        this.textSpans[i].style.display = 'none';
        i += 1;
      }

      this._sizeChanged = true;
    };

    SVGTextLottieElement.prototype.sourceRectAtTime = function () {
      this.prepareFrame(this.comp.renderedFrame - this.data.st);
      this.renderInnerContent();
      if (this._sizeChanged) {
        this._sizeChanged = false;
        var textBox = this.layerElement.getBBox();
        this.bbox = {
          top: textBox.y,
          left: textBox.x,
          width: textBox.width,
          height: textBox.height,
        };
      }
      return this.bbox;
    };

    SVGTextLottieElement.prototype.renderInnerContent = function () {
      if (!this.data.singleShape) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
        if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
          this._sizeChanged = true;
          var i;
          var len;
          var renderedLetters = this.textAnimator.renderedLetters;

          var letters = this.textProperty.currentData.l;

          len = letters.length;
          var renderedLetter;
          var textSpan;
          for (i = 0; i < len; i += 1) {
            if (!letters[i].n) {
              renderedLetter = renderedLetters[i];
              textSpan = this.textSpans[i];
              if (renderedLetter._mdf.m) {
                textSpan.setAttribute('transform', renderedLetter.m);
              }
              if (renderedLetter._mdf.o) {
                textSpan.setAttribute('opacity', renderedLetter.o);
              }
              if (renderedLetter._mdf.sw) {
                textSpan.setAttribute('stroke-width', renderedLetter.sw);
              }
              if (renderedLetter._mdf.sc) {
                textSpan.setAttribute('stroke', renderedLetter.sc);
              }
              if (renderedLetter._mdf.fc) {
                textSpan.setAttribute('fill', renderedLetter.fc);
              }
            }
          }
        }
      }
    };

    /* global extendPrototype, BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement,
    FrameElement, RenderableDOMElement, Matrix, SVGStyleData, SVGStrokeStyleData, SVGFillStyleData,
    SVGGradientFillStyleData, SVGGradientStrokeStyleData, locationHref, getBlendMode, ShapeGroupData,
    TransformPropertyFactory, SVGTransformData, ShapePropertyFactory, SVGShapeData, SVGElementsRenderer, ShapeModifiers,
    lineCapEnum, lineJoinEnum */

    function SVGShapeElement(data, globalData, comp) {
      // List of drawable elements
      this.shapes = [];
      // Full shape data
      this.shapesData = data.shapes;
      // List of styles that will be applied to shapes
      this.stylesList = [];
      // List of modifiers that will be applied to shapes
      this.shapeModifiers = [];
      // List of items in shape tree
      this.itemsData = [];
      // List of items in previous shape tree
      this.processedElements = [];
      // List of animated components
      this.animatedContents = [];
      this.initElement(data, globalData, comp);
      // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
      // List of elements that have been created
      this.prevViewData = [];
      // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
    }

    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);

    SVGShapeElement.prototype.initSecondaryElement = function () {
    };

    SVGShapeElement.prototype.identityMatrix = new Matrix();

    SVGShapeElement.prototype.buildExpressionInterface = function () {};

    SVGShapeElement.prototype.createContent = function () {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
    };

    /*
    This method searches for multiple shapes that affect a single element and one of them is animated
    */
    SVGShapeElement.prototype.filterUniqueShapes = function () {
      var i;
      var len = this.shapes.length;
      var shape;
      var j;
      var jLen = this.stylesList.length;
      var style;
      var tempShapes = [];
      var areAnimated = false;
      for (j = 0; j < jLen; j += 1) {
        style = this.stylesList[j];
        areAnimated = false;
        tempShapes.length = 0;
        for (i = 0; i < len; i += 1) {
          shape = this.shapes[i];
          if (shape.styles.indexOf(style) !== -1) {
            tempShapes.push(shape);
            areAnimated = shape._isAnimated || areAnimated;
          }
        }
        if (tempShapes.length > 1 && areAnimated) {
          this.setShapesAsAnimated(tempShapes);
        }
      }
    };

    SVGShapeElement.prototype.setShapesAsAnimated = function (shapes) {
      var i;
      var len = shapes.length;
      for (i = 0; i < len; i += 1) {
        shapes[i].setAsAnimated();
      }
    };

    SVGShapeElement.prototype.createStyleElement = function (data, level) {
      // TODO: prevent drawing of hidden styles
      var elementData;
      var styleOb = new SVGStyleData(data, level);

      var pathElement = styleOb.pElem;
      if (data.ty === 'st') {
        elementData = new SVGStrokeStyleData(this, data, styleOb);
      } else if (data.ty === 'fl') {
        elementData = new SVGFillStyleData(this, data, styleOb);
      } else if (data.ty === 'gf' || data.ty === 'gs') {
        var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        elementData = new GradientConstructor(this, data, styleOb);
        this.globalData.defs.appendChild(elementData.gf);
        if (elementData.maskId) {
          this.globalData.defs.appendChild(elementData.ms);
          this.globalData.defs.appendChild(elementData.of);
          pathElement.setAttribute('mask', 'url(' + locationHref + '#' + elementData.maskId + ')');
        }
      }

      if (data.ty === 'st' || data.ty === 'gs') {
        pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);
        pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);
        pathElement.setAttribute('fill-opacity', '0');
        if (data.lj === 1) {
          pathElement.setAttribute('stroke-miterlimit', data.ml);
        }
      }

      if (data.r === 2) {
        pathElement.setAttribute('fill-rule', 'evenodd');
      }

      if (data.ln) {
        pathElement.setAttribute('id', data.ln);
      }
      if (data.cl) {
        pathElement.setAttribute('class', data.cl);
      }
      if (data.bm) {
        pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);
      }
      this.stylesList.push(styleOb);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };

    SVGShapeElement.prototype.createGroupElement = function (data) {
      var elementData = new ShapeGroupData();
      if (data.ln) {
        elementData.gr.setAttribute('id', data.ln);
      }
      if (data.cl) {
        elementData.gr.setAttribute('class', data.cl);
      }
      if (data.bm) {
        elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);
      }
      return elementData;
    };

    SVGShapeElement.prototype.createTransformElement = function (data, container) {
      var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
      var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };

    SVGShapeElement.prototype.createShapeElement = function (data, ownTransformers, level) {
      var ty = 4;
      if (data.ty === 'rc') {
        ty = 5;
      } else if (data.ty === 'el') {
        ty = 6;
      } else if (data.ty === 'sr') {
        ty = 7;
      }
      var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
      var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      this.addToAnimatedContents(data, elementData);
      return elementData;
    };

    SVGShapeElement.prototype.addToAnimatedContents = function (data, element) {
      var i = 0;
      var len = this.animatedContents.length;
      while (i < len) {
        if (this.animatedContents[i].element === element) {
          return;
        }
        i += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(data),
        element: element,
        data: data,
      });
    };

    SVGShapeElement.prototype.setElementStyles = function (elementData) {
      var arr = elementData.styles;
      var j;
      var jLen = this.stylesList.length;
      for (j = 0; j < jLen; j += 1) {
        if (!this.stylesList[j].closed) {
          arr.push(this.stylesList[j]);
        }
      }
    };

    SVGShapeElement.prototype.reloadShapes = function () {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
      this.filterUniqueShapes();
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
    };

    SVGShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, container, level, transformers, render) {
      var ownTransformers = [].concat(transformers);
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var currentTransform;
      var modifier;
      var processedPos;
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._render = render;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], level);
          } else {
            itemsData[i].style.closed = false;
          }
          if (arr[i]._render) {
            if (itemsData[i].style.pElem.parentNode !== container) {
              container.appendChild(itemsData[i].style.pElem);
            }
          }
          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === 'gr') {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);
          if (arr[i]._render) {
            if (itemsData[i].gr.parentNode !== container) {
              container.appendChild(itemsData[i].gr);
            }
          }
        } else if (arr[i].ty === 'tr') {
          if (!processedPos) {
            itemsData[i] = this.createTransformElement(arr[i], container);
          }
          currentTransform = itemsData[i].transform;
          ownTransformers.push(currentTransform);
        } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);
          }
          this.setElementStyles(itemsData[i]);
        } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === 'rp') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            render = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      len = ownStyles.length;
      for (i = 0; i < len; i += 1) {
        ownStyles[i].closed = true;
      }
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };

    SVGShapeElement.prototype.renderInnerContent = function () {
      this.renderModifiers();
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        this.stylesList[i].reset();
      }
      this.renderShape();

      for (i = 0; i < len; i += 1) {
        if (this.stylesList[i]._mdf || this._isFirstFrame) {
          if (this.stylesList[i].msElem) {
            this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);
            // Adding M0 0 fixes same mask bug on all browsers
            this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;
          }
          this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');
        }
      }
    };

    SVGShapeElement.prototype.renderShape = function () {
      var i;
      var len = this.animatedContents.length;
      var animatedContent;
      for (i = 0; i < len; i += 1) {
        animatedContent = this.animatedContents[i];
        if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
          animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
        }
      }
    };

    SVGShapeElement.prototype.destroy = function () {
      this.destroyBaseElement();
      this.shapesData = null;
      this.itemsData = null;
    };

    /* global createNS */

    function SVGTintFilter(filter, filterManager) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
      feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
      feColorMatrix.setAttribute('result', 'f1');
      filter.appendChild(feColorMatrix);
      feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
      feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
      feColorMatrix.setAttribute('result', 'f2');
      filter.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
      if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
        var feMerge = createNS('feMerge');
        filter.appendChild(feMerge);
        var feMergeNode;
        feMergeNode = createNS('feMergeNode');
        feMergeNode.setAttribute('in', 'SourceGraphic');
        feMerge.appendChild(feMergeNode);
        feMergeNode = createNS('feMergeNode');
        feMergeNode.setAttribute('in', 'f2');
        feMerge.appendChild(feMergeNode);
      }
    }

    SVGTintFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var colorBlack = this.filterManager.effectElements[0].p.v;
        var colorWhite = this.filterManager.effectElements[1].p.v;
        var opacity = this.filterManager.effectElements[2].p.v / 100;
        this.matrixFilter.setAttribute('values', (colorWhite[0] - colorBlack[0]) + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 ' + opacity + ' 0');
      }
    };

    /* global createNS */

    function SVGFillFilter(filter, filterManager) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');
      feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');
      filter.appendChild(feColorMatrix);
      this.matrixFilter = feColorMatrix;
    }
    SVGFillFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color = this.filterManager.effectElements[2].p.v;
        var opacity = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');
      }
    };

    /* global createNS */

    function SVGGaussianBlurEffect(filter, filterManager) {
      // Outset the filter region by 100% on all sides to accommodate blur expansion.
      filter.setAttribute('x', '-100%');
      filter.setAttribute('y', '-100%');
      filter.setAttribute('width', '300%');
      filter.setAttribute('height', '300%');

      this.filterManager = filterManager;
      var feGaussianBlur = createNS('feGaussianBlur');
      filter.appendChild(feGaussianBlur);
      this.feGaussianBlur = feGaussianBlur;
    }

    SVGGaussianBlurEffect.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        // Empirical value, matching AE's blur appearance.
        var kBlurrinessToSigma = 0.3;
        var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;

        // Dimensions mapping:
        //
        //   1 -> horizontal & vertical
        //   2 -> horizontal only
        //   3 -> vertical only
        //
        var dimensions = this.filterManager.effectElements[1].p.v;
        var sigmaX = (dimensions == 3) ? 0 : sigma; // eslint-disable-line eqeqeq
        var sigmaY = (dimensions == 2) ? 0 : sigma; // eslint-disable-line eqeqeq

        this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);

        // Repeat edges mapping:
        //
        //   0 -> off -> duplicate
        //   1 -> on  -> wrap
        var edgeMode = (this.filterManager.effectElements[2].p.v == 1) ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq
        this.feGaussianBlur.setAttribute('edgeMode', edgeMode);
      }
    };

    /* global createNS, createElementID, locationHref, bmFloor */

    function SVGStrokeEffect(elem, filterManager) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.elem = elem;
      this.paths = [];
    }

    SVGStrokeEffect.prototype.initialize = function () {
      var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
      var path;
      var groupPath;
      var i;
      var len;
      if (this.filterManager.effectElements[1].p.v === 1) {
        len = this.elem.maskManager.masksProperties.length;
        i = 0;
      } else {
        i = this.filterManager.effectElements[0].p.v - 1;
        len = i + 1;
      }
      groupPath = createNS('g');
      groupPath.setAttribute('fill', 'none');
      groupPath.setAttribute('stroke-linecap', 'round');
      groupPath.setAttribute('stroke-dashoffset', 1);
      for (i; i < len; i += 1) {
        path = createNS('path');
        groupPath.appendChild(path);
        this.paths.push({ p: path, m: i });
      }
      if (this.filterManager.effectElements[10].p.v === 3) {
        var mask = createNS('mask');
        var id = createElementID();
        mask.setAttribute('id', id);
        mask.setAttribute('mask-type', 'alpha');
        mask.appendChild(groupPath);
        this.elem.globalData.defs.appendChild(mask);
        var g = createNS('g');
        g.setAttribute('mask', 'url(' + locationHref + '#' + id + ')');
        while (elemChildren[0]) {
          g.appendChild(elemChildren[0]);
        }
        this.elem.layerElement.appendChild(g);
        this.masker = mask;
        groupPath.setAttribute('stroke', '#fff');
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2) {
          elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          while (elemChildren.length) {
            this.elem.layerElement.removeChild(elemChildren[0]);
          }
        }
        this.elem.layerElement.appendChild(groupPath);
        this.elem.layerElement.removeAttribute('mask');
        groupPath.setAttribute('stroke', '#fff');
      }
      this.initialized = true;
      this.pathMasker = groupPath;
    };

    SVGStrokeEffect.prototype.renderFrame = function (forceRender) {
      if (!this.initialized) {
        this.initialize();
      }
      var i;
      var len = this.paths.length;
      var mask;
      var path;
      for (i = 0; i < len; i += 1) {
        if (this.paths[i].m !== -1) {
          mask = this.elem.maskManager.viewData[this.paths[i].m];
          path = this.paths[i].p;
          if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
            path.setAttribute('d', mask.lastPath);
          }
          if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
            var dasharrayValue;
            if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
              var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
              var l = path.getTotalLength();
              dasharrayValue = '0 0 0 ' + l * s + ' ';
              var lineLength = l * (e - s);
              var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
              var units = Math.floor(lineLength / segment);
              var j;
              for (j = 0; j < units; j += 1) {
                dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';
              }
              dasharrayValue += '0 ' + l * 10 + ' 0 0';
            } else {
              dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
            }
            path.setAttribute('stroke-dasharray', dasharrayValue);
          }
        }
      }
      if (forceRender || this.filterManager.effectElements[4].p._mdf) {
        this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);
      }

      if (forceRender || this.filterManager.effectElements[6].p._mdf) {
        this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);
      }
      if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (forceRender || this.filterManager.effectElements[3].p._mdf) {
          var color = this.filterManager.effectElements[3].p.v;
          this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');
        }
      }
    };

    /* global createNS */

    function SVGTritoneFilter(filter, filterManager) {
      this.filterManager = filterManager;
      var feColorMatrix = createNS('feColorMatrix');
      feColorMatrix.setAttribute('type', 'matrix');
      feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');
      feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');
      feColorMatrix.setAttribute('result', 'f1');
      filter.appendChild(feColorMatrix);
      var feComponentTransfer = createNS('feComponentTransfer');
      feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
      filter.appendChild(feComponentTransfer);
      this.matrixFilter = feComponentTransfer;
      var feFuncR = createNS('feFuncR');
      feFuncR.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncR);
      this.feFuncR = feFuncR;
      var feFuncG = createNS('feFuncG');
      feFuncG.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncG);
      this.feFuncG = feFuncG;
      var feFuncB = createNS('feFuncB');
      feFuncB.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFuncB);
      this.feFuncB = feFuncB;
    }

    SVGTritoneFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var color1 = this.filterManager.effectElements[0].p.v;
        var color2 = this.filterManager.effectElements[1].p.v;
        var color3 = this.filterManager.effectElements[2].p.v;
        var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];
        var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];
        var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];
        this.feFuncR.setAttribute('tableValues', tableR);
        this.feFuncG.setAttribute('tableValues', tableG);
        this.feFuncB.setAttribute('tableValues', tableB);
        // var opacity = this.filterManager.effectElements[2].p.v/100;
        // this.matrixFilter.setAttribute('values',(colorWhite[0]- colorBlack[0])+' 0 0 0 '+ colorBlack[0] +' '+ (colorWhite[1]- colorBlack[1]) +' 0 0 0 '+ colorBlack[1] +' '+ (colorWhite[2]- colorBlack[2]) +' 0 0 0 '+ colorBlack[2] +' 0 0 0 ' + opacity + ' 0');
      }
    };

    /* global createNS */

    function SVGProLevelsFilter(filter, filterManager) {
      this.filterManager = filterManager;
      var effectElements = this.filterManager.effectElements;
      var feComponentTransfer = createNS('feComponentTransfer');

      if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
        this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);
      }
      if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
        this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);
      }
      if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
        this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);
      }
      if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
        this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);
      }

      if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
        filter.appendChild(feComponentTransfer);
        feComponentTransfer = createNS('feComponentTransfer');
      }

      if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');
        filter.appendChild(feComponentTransfer);
        this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);
        this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);
        this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);
      }
    }

    SVGProLevelsFilter.prototype.createFeFunc = function (type, feComponentTransfer) {
      var feFunc = createNS(type);
      feFunc.setAttribute('type', 'table');
      feComponentTransfer.appendChild(feFunc);
      return feFunc;
    };

    SVGProLevelsFilter.prototype.getTableValue = function (inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
      var cnt = 0;
      var segments = 256;
      var perc;
      var min = Math.min(inputBlack, inputWhite);
      var max = Math.max(inputBlack, inputWhite);
      var table = Array.call(null, { length: segments });
      var colorValue;
      var pos = 0;
      var outputDelta = outputWhite - outputBlack;
      var inputDelta = inputWhite - inputBlack;
      while (cnt <= 256) {
        perc = cnt / 256;
        if (perc <= min) {
          colorValue = inputDelta < 0 ? outputWhite : outputBlack;
        } else if (perc >= max) {
          colorValue = inputDelta < 0 ? outputBlack : outputWhite;
        } else {
          colorValue = (outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma));
        }
        table[pos] = colorValue;
        pos += 1;
        cnt += 256 / (segments - 1);
      }
      return table.join(' ');
    };

    SVGProLevelsFilter.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        var val;
        var effectElements = this.filterManager.effectElements;
        if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
          val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
          this.feFuncRComposed.setAttribute('tableValues', val);
          this.feFuncGComposed.setAttribute('tableValues', val);
          this.feFuncBComposed.setAttribute('tableValues', val);
        }

        if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
          val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
          this.feFuncR.setAttribute('tableValues', val);
        }

        if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
          val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
          this.feFuncG.setAttribute('tableValues', val);
        }

        if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
          val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
          this.feFuncB.setAttribute('tableValues', val);
        }

        if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
          val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
          this.feFuncA.setAttribute('tableValues', val);
        }
      }
    };

    /* global createNS, rgbToHex, degToRads */

    function SVGDropShadowEffect(filter, filterManager) {
      var filterSize = filterManager.container.globalData.renderConfig.filterSize;
      filter.setAttribute('x', filterSize.x);
      filter.setAttribute('y', filterSize.y);
      filter.setAttribute('width', filterSize.width);
      filter.setAttribute('height', filterSize.height);
      this.filterManager = filterManager;

      var feGaussianBlur = createNS('feGaussianBlur');
      feGaussianBlur.setAttribute('in', 'SourceAlpha');
      feGaussianBlur.setAttribute('result', 'drop_shadow_1');
      feGaussianBlur.setAttribute('stdDeviation', '0');
      this.feGaussianBlur = feGaussianBlur;
      filter.appendChild(feGaussianBlur);

      var feOffset = createNS('feOffset');
      feOffset.setAttribute('dx', '25');
      feOffset.setAttribute('dy', '0');
      feOffset.setAttribute('in', 'drop_shadow_1');
      feOffset.setAttribute('result', 'drop_shadow_2');
      this.feOffset = feOffset;
      filter.appendChild(feOffset);
      var feFlood = createNS('feFlood');
      feFlood.setAttribute('flood-color', '#00ff00');
      feFlood.setAttribute('flood-opacity', '1');
      feFlood.setAttribute('result', 'drop_shadow_3');
      this.feFlood = feFlood;
      filter.appendChild(feFlood);

      var feComposite = createNS('feComposite');
      feComposite.setAttribute('in', 'drop_shadow_3');
      feComposite.setAttribute('in2', 'drop_shadow_2');
      feComposite.setAttribute('operator', 'in');
      feComposite.setAttribute('result', 'drop_shadow_4');
      filter.appendChild(feComposite);

      var feMerge = createNS('feMerge');
      filter.appendChild(feMerge);
      var feMergeNode;
      feMergeNode = createNS('feMergeNode');
      feMerge.appendChild(feMergeNode);
      feMergeNode = createNS('feMergeNode');
      feMergeNode.setAttribute('in', 'SourceGraphic');
      this.feMergeNode = feMergeNode;
      this.feMerge = feMerge;
      this.originalNodeAdded = false;
      feMerge.appendChild(feMergeNode);
    }

    SVGDropShadowEffect.prototype.renderFrame = function (forceRender) {
      if (forceRender || this.filterManager._mdf) {
        if (forceRender || this.filterManager.effectElements[4].p._mdf) {
          this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);
        }
        if (forceRender || this.filterManager.effectElements[0].p._mdf) {
          var col = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
        }
        if (forceRender || this.filterManager.effectElements[1].p._mdf) {
          this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);
        }
        if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var distance = this.filterManager.effectElements[3].p.v;
          var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
          var x = distance * Math.cos(angle);
          var y = distance * Math.sin(angle);
          this.feOffset.setAttribute('dx', x);
          this.feOffset.setAttribute('dy', y);
        }
        /* if(forceRender || this.filterManager.effectElements[5].p._mdf){
                if(this.filterManager.effectElements[5].p.v === 1 && this.originalNodeAdded) {
                    this.feMerge.removeChild(this.feMergeNode);
                    this.originalNodeAdded = false;
                } else if(this.filterManager.effectElements[5].p.v === 0 && !this.originalNodeAdded) {
                    this.feMerge.appendChild(this.feMergeNode);
                    this.originalNodeAdded = true;
                }
            } */
      }
    };

    /* global createElementID, createNS */

    var _svgMatteSymbols = [];

    function SVGMatte3Effect(filterElem, filterManager, elem) {
      this.initialized = false;
      this.filterManager = filterManager;
      this.filterElem = filterElem;
      this.elem = elem;
      elem.matteElement = createNS('g');
      elem.matteElement.appendChild(elem.layerElement);
      elem.matteElement.appendChild(elem.transformedElement);
      elem.baseElement = elem.matteElement;
    }

    SVGMatte3Effect.prototype.findSymbol = function (mask) {
      var i = 0;
      var len = _svgMatteSymbols.length;
      while (i < len) {
        if (_svgMatteSymbols[i] === mask) {
          return _svgMatteSymbols[i];
        }
        i += 1;
      }
      return null;
    };

    SVGMatte3Effect.prototype.replaceInParent = function (mask, symbolId) {
      var parentNode = mask.layerElement.parentNode;
      if (!parentNode) {
        return;
      }
      var children = parentNode.children;
      var i = 0;
      var len = children.length;
      while (i < len) {
        if (children[i] === mask.layerElement) {
          break;
        }
        i += 1;
      }
      var nextChild;
      if (i <= len - 2) {
        nextChild = children[i + 1];
      }
      var useElem = createNS('use');
      useElem.setAttribute('href', '#' + symbolId);
      if (nextChild) {
        parentNode.insertBefore(useElem, nextChild);
      } else {
        parentNode.appendChild(useElem);
      }
    };

    SVGMatte3Effect.prototype.setElementAsMask = function (elem, mask) {
      if (!this.findSymbol(mask)) {
        var symbolId = createElementID();
        var masker = createNS('mask');
        masker.setAttribute('id', mask.layerId);
        masker.setAttribute('mask-type', 'alpha');
        _svgMatteSymbols.push(mask);
        var defs = elem.globalData.defs;
        defs.appendChild(masker);
        var symbol = createNS('symbol');
        symbol.setAttribute('id', symbolId);
        this.replaceInParent(mask, symbolId);
        symbol.appendChild(mask.layerElement);
        defs.appendChild(symbol);
        var useElem = createNS('use');
        useElem.setAttribute('href', '#' + symbolId);
        masker.appendChild(useElem);
        mask.data.hd = false;
        mask.show();
      }
      elem.setMatte(mask.layerId);
    };

    SVGMatte3Effect.prototype.initialize = function () {
      var ind = this.filterManager.effectElements[0].p.v;
      var elements = this.elem.comp.elements;
      var i = 0;
      var len = elements.length;
      while (i < len) {
        if (elements[i] && elements[i].data.ind === ind) {
          this.setElementAsMask(this.elem, elements[i]);
        }
        i += 1;
      }
      this.initialized = true;
    };

    SVGMatte3Effect.prototype.renderFrame = function () {
      if (!this.initialized) {
        this.initialize();
      }
    };

    /* global createElementID, filtersFactory, SVGTintFilter, SVGFillFilter, SVGStrokeEffect, SVGTritoneFilter,
    SVGProLevelsFilter, SVGDropShadowEffect, SVGMatte3Effect, SVGGaussianBlurEffect, locationHref */

    function SVGEffects(elem) {
      var i;
      var len = elem.data.ef ? elem.data.ef.length : 0;
      var filId = createElementID();
      var fil = filtersFactory.createFilter(filId, true);
      var count = 0;
      this.filters = [];
      var filterManager;
      for (i = 0; i < len; i += 1) {
        filterManager = null;
        if (elem.data.ef[i].ty === 20) {
          count += 1;
          filterManager = new SVGTintFilter(fil, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 21) {
          count += 1;
          filterManager = new SVGFillFilter(fil, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 22) {
          filterManager = new SVGStrokeEffect(elem, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 23) {
          count += 1;
          filterManager = new SVGTritoneFilter(fil, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 24) {
          count += 1;
          filterManager = new SVGProLevelsFilter(fil, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 25) {
          count += 1;
          filterManager = new SVGDropShadowEffect(fil, elem.effectsManager.effectElements[i]);
        } else if (elem.data.ef[i].ty === 28) {
          // count += 1;
          filterManager = new SVGMatte3Effect(fil, elem.effectsManager.effectElements[i], elem);
        } else if (elem.data.ef[i].ty === 29) {
          count += 1;
          filterManager = new SVGGaussianBlurEffect(fil, elem.effectsManager.effectElements[i]);
        }
        if (filterManager) {
          this.filters.push(filterManager);
        }
      }
      if (count) {
        elem.globalData.defs.appendChild(fil);
        elem.layerElement.setAttribute('filter', 'url(' + locationHref + '#' + filId + ')');
      }
      if (this.filters.length) {
        elem.addRenderableComponent(this);
      }
    }

    SVGEffects.prototype.renderFrame = function (_isFirstFrame) {
      var i;
      var len = this.filters.length;
      for (i = 0; i < len; i += 1) {
        this.filters[i].renderFrame(_isFirstFrame);
      }
    };

    /* global Matrix, createTypedArray */

    function CVContextData() {
      this.saved = [];
      this.cArrPos = 0;
      this.cTr = new Matrix();
      this.cO = 1;
      var i;
      var len = 15;
      this.savedOp = createTypedArray('float32', len);
      for (i = 0; i < len; i += 1) {
        this.saved[i] = createTypedArray('float32', 16);
      }
      this._length = len;
    }

    CVContextData.prototype.duplicate = function () {
      var newLength = this._length * 2;
      var currentSavedOp = this.savedOp;
      this.savedOp = createTypedArray('float32', newLength);
      this.savedOp.set(currentSavedOp);
      var i = 0;
      for (i = this._length; i < newLength; i += 1) {
        this.saved[i] = createTypedArray('float32', 16);
      }
      this._length = newLength;
    };

    CVContextData.prototype.reset = function () {
      this.cArrPos = 0;
      this.cTr.reset();
      this.cO = 1;
    };

    /* global CVEffects, getBlendMode, CVMaskElement, Matrix */

    function CVBaseElement() {
    }

    CVBaseElement.prototype = {
      createElements: function () {},
      initRendererElement: function () {},
      createContainerElements: function () {
        this.canvasContext = this.globalData.canvasContext;
        this.renderableEffectsManager = new CVEffects(this);
      },
      createContent: function () {},
      setBlendMode: function () {
        var globalData = this.globalData;
        if (globalData.blendMode !== this.data.bm) {
          globalData.blendMode = this.data.bm;
          var blendModeValue = getBlendMode(this.data.bm);
          globalData.canvasContext.globalCompositeOperation = blendModeValue;
        }
      },
      createRenderableComponents: function () {
        this.maskManager = new CVMaskElement(this.data, this);
      },
      hideElement: function () {
        if (!this.hidden && (!this.isInRange || this.isTransparent)) {
          this.hidden = true;
        }
      },
      showElement: function () {
        if (this.isInRange && !this.isTransparent) {
          this.hidden = false;
          this._isFirstFrame = true;
          this.maskManager._isFirstFrame = true;
        }
      },
      renderFrame: function () {
        if (this.hidden || this.data.hd) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.setBlendMode();
        var forceRealStack = this.data.ty === 0;
        this.globalData.renderer.save(forceRealStack);
        this.globalData.renderer.ctxTransform(this.finalTransform.mat.props);
        this.globalData.renderer.ctxOpacity(this.finalTransform.mProp.o.v);
        this.renderInnerContent();
        this.globalData.renderer.restore(forceRealStack);
        if (this.maskManager.hasMasks) {
          this.globalData.renderer.restore(true);
        }
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function () {
        this.canvasContext = null;
        this.data = null;
        this.globalData = null;
        this.maskManager.destroy();
      },
      mHelper: new Matrix(),
    };
    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;
    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;

    /* global extendPrototype, BaseElement, TransformElement, CVBaseElement,HierarchyElement, FrameElement,
    RenderableElement, SVGShapeElement, IImageElement, createTag */

    function CVImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      this.img = globalData.imageLoader.getAsset(this.assetData);
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement);

    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

    CVImageElement.prototype.createContent = function () {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var canvas = createTag('canvas');
        canvas.width = this.assetData.w;
        canvas.height = this.assetData.h;
        var ctx = canvas.getContext('2d');

        var imgW = this.img.width;
        var imgH = this.img.height;
        var imgRel = imgW / imgH;
        var canvasRel = this.assetData.w / this.assetData.h;
        var widthCrop;
        var heightCrop;
        var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        if ((imgRel > canvasRel && par === 'xMidYMid slice') || (imgRel < canvasRel && par !== 'xMidYMid slice')) {
          heightCrop = imgH;
          widthCrop = heightCrop * canvasRel;
        } else {
          widthCrop = imgW;
          heightCrop = widthCrop / canvasRel;
        }
        ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);
        this.img = canvas;
      }
    };

    CVImageElement.prototype.renderInnerContent = function () {
      this.canvasContext.drawImage(this.img, 0, 0);
    };

    CVImageElement.prototype.destroy = function () {
      this.img = null;
    };

    /* global createSizedArray, PropertyFactory, extendPrototype, CanvasRenderer, ICompElement, CVBaseElement */

    function CVCompElement(data, globalData, comp) {
      this.completeLayers = false;
      this.layers = data.layers;
      this.pendingElements = [];
      this.elements = createSizedArray(this.layers.length);
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
    }

    extendPrototype([CanvasRenderer, ICompElement, CVBaseElement], CVCompElement);

    CVCompElement.prototype.renderInnerContent = function () {
      var ctx = this.canvasContext;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(this.data.w, 0);
      ctx.lineTo(this.data.w, this.data.h);
      ctx.lineTo(0, this.data.h);
      ctx.lineTo(0, 0);
      ctx.clip();
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.completeLayers || this.elements[i]) {
          this.elements[i].renderFrame();
        }
      }
    };

    CVCompElement.prototype.destroy = function () {
      var i;
      var len = this.layers.length;
      for (i = len - 1; i >= 0; i -= 1) {
        if (this.elements[i]) {
          this.elements[i].destroy();
        }
      }
      this.layers = null;
      this.elements = null;
    };

    /* global createSizedArray, ShapePropertyFactory, MaskElement */

    function CVMaskElement(data, element) {
      this.data = data;
      this.element = element;
      this.masksProperties = this.data.masksProperties || [];
      this.viewData = createSizedArray(this.masksProperties.length);
      var i;
      var len = this.masksProperties.length;
      var hasMasks = false;
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== 'n') {
          hasMasks = true;
        }
        this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);
      }
      this.hasMasks = hasMasks;
      if (hasMasks) {
        this.element.addRenderableComponent(this);
      }
    }

    CVMaskElement.prototype.renderFrame = function () {
      if (!this.hasMasks) {
        return;
      }
      var transform = this.element.finalTransform.mat;
      var ctx = this.element.canvasContext;
      var i;
      var len = this.masksProperties.length;
      var pt;
      var pts;
      var data;
      ctx.beginPath();
      for (i = 0; i < len; i += 1) {
        if (this.masksProperties[i].mode !== 'n') {
          if (this.masksProperties[i].inv) {
            ctx.moveTo(0, 0);
            ctx.lineTo(this.element.globalData.compSize.w, 0);
            ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);
            ctx.lineTo(0, this.element.globalData.compSize.h);
            ctx.lineTo(0, 0);
          }
          data = this.viewData[i].v;
          pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);
          ctx.moveTo(pt[0], pt[1]);
          var j;
          var jLen = data._length;
          for (j = 1; j < jLen; j += 1) {
            pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);
            ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
          }
          pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);
          ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);
        }
      }
      this.element.globalData.renderer.save(true);
      ctx.clip();
    };

    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;

    CVMaskElement.prototype.destroy = function () {
      this.element = null;
    };

    /* global ShapeTransformManager, extendPrototype, BaseElement, TransformElement, CVBaseElement, IShapeElement,
    HierarchyElement, FrameElement, RenderableElement, RenderableDOMElement, PropertyFactory, degToRads, GradientProperty,
    DashProperty, TransformPropertyFactory, CVShapeData, ShapeModifiers, bmFloor, lineCapEnum, lineJoinEnum */

    function CVShapeElement(data, globalData, comp) {
      this.shapes = [];
      this.shapesData = data.shapes;
      this.stylesList = [];
      this.itemsData = [];
      this.prevViewData = [];
      this.shapeModifiers = [];
      this.processedElements = [];
      this.transformsManager = new ShapeTransformManager();
      this.initElement(data, globalData, comp);
    }

    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement);

    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;

    CVShapeElement.prototype.transformHelper = { opacity: 1, _opMdf: false };

    CVShapeElement.prototype.dashResetter = [];

    CVShapeElement.prototype.createContent = function () {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
    };

    CVShapeElement.prototype.createStyleElement = function (data, transforms) {
      var styleElem = {
        data: data,
        type: data.ty,
        preTransforms: this.transformsManager.addTransformSequence(transforms),
        transforms: [],
        elements: [],
        closed: data.hd === true,
      };
      var elementData = {};
      if (data.ty === 'fl' || data.ty === 'st') {
        elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);
        if (!elementData.c.k) {
          styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';
        }
      } else if (data.ty === 'gf' || data.ty === 'gs') {
        elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);
        elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);
        elementData.h = PropertyFactory.getProp(this, data.h || { k: 0 }, 0, 0.01, this);
        elementData.a = PropertyFactory.getProp(this, data.a || { k: 0 }, 0, degToRads, this);
        elementData.g = new GradientProperty(this, data.g, this);
      }
      elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);
      if (data.ty === 'st' || data.ty === 'gs') {
        styleElem.lc = lineCapEnum[data.lc || 2];
        styleElem.lj = lineJoinEnum[data.lj || 2];
        if (data.lj == 1) { // eslint-disable-line eqeqeq
          styleElem.ml = data.ml;
        }
        elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);
        if (!elementData.w.k) {
          styleElem.wi = elementData.w.v;
        }
        if (data.d) {
          var d = new DashProperty(this, data.d, 'canvas', this);
          elementData.d = d;
          if (!elementData.d.k) {
            styleElem.da = elementData.d.dashArray;
            styleElem.do = elementData.d.dashoffset[0];
          }
        }
      } else {
        styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';
      }
      this.stylesList.push(styleElem);
      elementData.style = styleElem;
      return elementData;
    };

    CVShapeElement.prototype.createGroupElement = function () {
      var elementData = {
        it: [],
        prevViewData: [],
      };
      return elementData;
    };

    CVShapeElement.prototype.createTransformElement = function (data) {
      var elementData = {
        transform: {
          opacity: 1,
          _opMdf: false,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, data, this),
        },
      };
      return elementData;
    };

    CVShapeElement.prototype.createShapeElement = function (data) {
      var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);

      this.shapes.push(elementData);
      this.addShapeToModifiers(elementData);
      return elementData;
    };

    CVShapeElement.prototype.reloadShapes = function () {
      this._isFirstFrame = true;
      var i;
      var len = this.itemsData.length;
      for (i = 0; i < len; i += 1) {
        this.prevViewData[i] = this.itemsData[i];
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);
      len = this.dynamicProperties.length;
      for (i = 0; i < len; i += 1) {
        this.dynamicProperties[i].getValue();
      }
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
    };

    CVShapeElement.prototype.addTransformToStyleList = function (transform) {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.push(transform);
        }
      }
    };

    CVShapeElement.prototype.removeTransformFromStyleList = function () {
      var i;
      var len = this.stylesList.length;
      for (i = 0; i < len; i += 1) {
        if (!this.stylesList[i].closed) {
          this.stylesList[i].transforms.pop();
        }
      }
    };

    CVShapeElement.prototype.closeStyles = function (styles) {
      var i;
      var len = styles.length;
      for (i = 0; i < len; i += 1) {
        styles[i].closed = true;
      }
    };

    CVShapeElement.prototype.searchShapes = function (arr, itemsData, prevViewData, shouldRender, transforms) {
      var i;
      var len = arr.length - 1;
      var j;
      var jLen;
      var ownStyles = [];
      var ownModifiers = [];
      var processedPos;
      var modifier;
      var currentTransform;
      var ownTransforms = [].concat(transforms);
      for (i = len; i >= 0; i -= 1) {
        processedPos = this.searchProcessedElement(arr[i]);
        if (!processedPos) {
          arr[i]._shouldRender = shouldRender;
        } else {
          itemsData[i] = prevViewData[processedPos - 1];
        }
        if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {
          if (!processedPos) {
            itemsData[i] = this.createStyleElement(arr[i], ownTransforms);
          } else {
            itemsData[i].style.closed = false;
          }

          ownStyles.push(itemsData[i].style);
        } else if (arr[i].ty === 'gr') {
          if (!processedPos) {
            itemsData[i] = this.createGroupElement(arr[i]);
          } else {
            jLen = itemsData[i].it.length;
            for (j = 0; j < jLen; j += 1) {
              itemsData[i].prevViewData[j] = itemsData[i].it[j];
            }
          }
          this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);
        } else if (arr[i].ty === 'tr') {
          if (!processedPos) {
            currentTransform = this.createTransformElement(arr[i]);
            itemsData[i] = currentTransform;
          }
          ownTransforms.push(itemsData[i]);
          this.addTransformToStyleList(itemsData[i]);
        } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {
          if (!processedPos) {
            itemsData[i] = this.createShapeElement(arr[i]);
          }
        } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            modifier.init(this, arr[i]);
            itemsData[i] = modifier;
            this.shapeModifiers.push(modifier);
          } else {
            modifier = itemsData[i];
            modifier.closed = false;
          }
          ownModifiers.push(modifier);
        } else if (arr[i].ty === 'rp') {
          if (!processedPos) {
            modifier = ShapeModifiers.getModifier(arr[i].ty);
            itemsData[i] = modifier;
            modifier.init(this, arr, i, itemsData);
            this.shapeModifiers.push(modifier);
            shouldRender = false;
          } else {
            modifier = itemsData[i];
            modifier.closed = true;
          }
          ownModifiers.push(modifier);
        }
        this.addProcessedElement(arr[i], i + 1);
      }
      this.removeTransformFromStyleList();
      this.closeStyles(ownStyles);
      len = ownModifiers.length;
      for (i = 0; i < len; i += 1) {
        ownModifiers[i].closed = true;
      }
    };

    CVShapeElement.prototype.renderInnerContent = function () {
      this.transformHelper.opacity = 1;
      this.transformHelper._opMdf = false;
      this.renderModifiers();
      this.transformsManager.processSequences(this._isFirstFrame);
      this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);
    };

    CVShapeElement.prototype.renderShapeTransform = function (parentTransform, groupTransform) {
      if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {
        groupTransform.opacity = parentTransform.opacity;
        groupTransform.opacity *= groupTransform.op.v;
        groupTransform._opMdf = true;
      }
    };

    CVShapeElement.prototype.drawLayer = function () {
      var i;
      var len = this.stylesList.length;
      var j;
      var jLen;
      var k;
      var kLen;
      var elems;
      var nodes;
      var renderer = this.globalData.renderer;
      var ctx = this.globalData.canvasContext;
      var type;
      var currentStyle;
      for (i = 0; i < len; i += 1) {
        currentStyle = this.stylesList[i];
        type = currentStyle.type;

        // Skipping style when
        // Stroke width equals 0
        // style should not be rendered (extra unused repeaters)
        // current opacity equals 0
        // global opacity equals 0
        if (!(((type === 'st' || type === 'gs') && currentStyle.wi === 0) || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          renderer.save();
          elems = currentStyle.elements;
          if (type === 'st' || type === 'gs') {
            ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
            ctx.lineWidth = currentStyle.wi;
            ctx.lineCap = currentStyle.lc;
            ctx.lineJoin = currentStyle.lj;
            ctx.miterLimit = currentStyle.ml || 0;
          } else {
            ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
          }
          renderer.ctxOpacity(currentStyle.coOp);
          if (type !== 'st' && type !== 'gs') {
            ctx.beginPath();
          }
          renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);
          jLen = elems.length;
          for (j = 0; j < jLen; j += 1) {
            if (type === 'st' || type === 'gs') {
              ctx.beginPath();
              if (currentStyle.da) {
                ctx.setLineDash(currentStyle.da);
                ctx.lineDashOffset = currentStyle.do;
              }
            }
            nodes = elems[j].trNodes;
            kLen = nodes.length;

            for (k = 0; k < kLen; k += 1) {
              if (nodes[k].t === 'm') {
                ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);
              } else if (nodes[k].t === 'c') {
                ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);
              } else {
                ctx.closePath();
              }
            }
            if (type === 'st' || type === 'gs') {
              ctx.stroke();
              if (currentStyle.da) {
                ctx.setLineDash(this.dashResetter);
              }
            }
          }
          if (type !== 'st' && type !== 'gs') {
            ctx.fill(currentStyle.r);
          }
          renderer.restore();
        }
      }
    };

    CVShapeElement.prototype.renderShape = function (parentTransform, items, data, isMain) {
      var i;
      var len = items.length - 1;
      var groupTransform;
      groupTransform = parentTransform;
      for (i = len; i >= 0; i -= 1) {
        if (items[i].ty === 'tr') {
          groupTransform = data[i].transform;
          this.renderShapeTransform(parentTransform, groupTransform);
        } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {
          this.renderPath(items[i], data[i]);
        } else if (items[i].ty === 'fl') {
          this.renderFill(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'st') {
          this.renderStroke(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {
          this.renderGradientFill(items[i], data[i], groupTransform);
        } else if (items[i].ty === 'gr') {
          this.renderShape(groupTransform, items[i].it, data[i].it);
        } else if (items[i].ty === 'tm') ;
      }
      if (isMain) {
        this.drawLayer();
      }
    };

    CVShapeElement.prototype.renderStyledShape = function (styledShape, shape) {
      if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {
        var shapeNodes = styledShape.trNodes;
        var paths = shape.paths;
        var i;
        var len;
        var j;
        var jLen = paths._length;
        shapeNodes.length = 0;
        var groupTransformMat = styledShape.transforms.finalTransform;
        for (j = 0; j < jLen; j += 1) {
          var pathNodes = paths.shapes[j];
          if (pathNodes && pathNodes.v) {
            len = pathNodes._length;
            for (i = 1; i < len; i += 1) {
              if (i === 1) {
                shapeNodes.push({
                  t: 'm',
                  p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
                });
              }
              shapeNodes.push({
                t: 'c',
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i]),
              });
            }
            if (len === 1) {
              shapeNodes.push({
                t: 'm',
                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0),
              });
            }
            if (pathNodes.c && len) {
              shapeNodes.push({
                t: 'c',
                pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0]),
              });
              shapeNodes.push({
                t: 'z',
              });
            }
          }
        }
        styledShape.trNodes = shapeNodes;
      }
    };

    CVShapeElement.prototype.renderPath = function (pathData, itemData) {
      if (pathData.hd !== true && pathData._shouldRender) {
        var i;
        var len = itemData.styledShapes.length;
        for (i = 0; i < len; i += 1) {
          this.renderStyledShape(itemData.styledShapes[i], itemData.sh);
        }
      }
    };

    CVShapeElement.prototype.renderFill = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;

      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = 'rgb('
            + bmFloor(itemData.c.v[0]) + ','
            + bmFloor(itemData.c.v[1]) + ','
            + bmFloor(itemData.c.v[2]) + ')';
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
    };

    CVShapeElement.prototype.renderGradientFill = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var grd;
      if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || (styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf))) {
        var ctx = this.globalData.canvasContext;
        var pt1 = itemData.s.v;
        var pt2 = itemData.e.v;
        if (styleData.t === 1) {
          grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);
        } else {
          var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
          var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);

          var percent = itemData.h.v;
          if (percent >= 1) {
            percent = 0.99;
          } else if (percent <= -1) {
            percent = -0.99;
          }
          var dist = rad * percent;
          var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];
          var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];
          grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);
        }

        var i;
        var len = styleData.g.p;
        var cValues = itemData.g.c;
        var opacity = 1;

        for (i = 0; i < len; i += 1) {
          if (itemData.g._hasOpacity && itemData.g._collapsable) {
            opacity = itemData.g.o[i * 2 + 1];
          }
          grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');
        }
        styleElem.grd = grd;
      }
      styleElem.coOp = itemData.o.v * groupTransform.opacity;
    };

    CVShapeElement.prototype.renderStroke = function (styleData, itemData, groupTransform) {
      var styleElem = itemData.style;
      var d = itemData.d;
      if (d && (d._mdf || this._isFirstFrame)) {
        styleElem.da = d.dashArray;
        styleElem.do = d.dashoffset[0];
      }
      if (itemData.c._mdf || this._isFirstFrame) {
        styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';
      }
      if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {
        styleElem.coOp = itemData.o.v * groupTransform.opacity;
      }
      if (itemData.w._mdf || this._isFirstFrame) {
        styleElem.wi = itemData.w.v;
      }
    };

    CVShapeElement.prototype.destroy = function () {
      this.shapesData = null;
      this.globalData = null;
      this.canvasContext = null;
      this.stylesList.length = 0;
      this.itemsData.length = 0;
    };

    /* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement,
    SVGShapeElement, IImageElement */

    function CVSolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement);

    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;
    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;

    CVSolidElement.prototype.renderInnerContent = function () {
      var ctx = this.canvasContext;
      ctx.fillStyle = this.data.sc;
      ctx.fillRect(0, 0, this.data.sw, this.data.sh);
      //
    };

    /* global extendPrototype, BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement,
    RenderableElement, ITextElement, createTag, createSizedArray */

    function CVTextElement(data, globalData, comp) {
      this.textSpans = [];
      this.yOffset = 0;
      this.fillColorAnim = false;
      this.strokeColorAnim = false;
      this.strokeWidthAnim = false;
      this.stroke = false;
      this.fill = false;
      this.justifyOffset = 0;
      this.currentRender = null;
      this.renderType = 'canvas';
      this.values = {
        fill: 'rgba(0,0,0,0)',
        stroke: 'rgba(0,0,0,0)',
        sWidth: 0,
        fValue: '',
      };
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement);

    CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');

    CVTextElement.prototype.buildNewText = function () {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);

      var hasFill = false;
      if (documentData.fc) {
        hasFill = true;
        this.values.fill = this.buildColor(documentData.fc);
      } else {
        this.values.fill = 'rgba(0,0,0,0)';
      }
      this.fill = hasFill;
      var hasStroke = false;
      if (documentData.sc) {
        hasStroke = true;
        this.values.stroke = this.buildColor(documentData.sc);
        this.values.sWidth = documentData.sw;
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      var i;
      var len;
      var letters = documentData.l;
      var matrixHelper = this.mHelper;
      this.stroke = hasStroke;
      this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;
      len = documentData.finalText.length;
      // this.tHelper.font = this.values.fValue;
      var charData;
      var shapeData;
      var k;
      var kLen;
      var shapes;
      var j;
      var jLen;
      var pathNodes;
      var commands;
      var pathArr;
      var singleShape = this.data.singleShape;
      var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;
      var xPos = 0;
      var yPos = 0;
      var firstLine = true;
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
        shapeData = (charData && charData.data) || {};
        matrixHelper.reset();
        if (singleShape && letters[i].n) {
          xPos = -trackingOffset;
          yPos += documentData.yOffset;
          yPos += firstLine ? 1 : 0;
          firstLine = false;
        }

        shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
        jLen = shapes.length;
        matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
        if (singleShape) {
          this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);
        }
        commands = createSizedArray(jLen);
        for (j = 0; j < jLen; j += 1) {
          kLen = shapes[j].ks.k.i.length;
          pathNodes = shapes[j].ks.k;
          pathArr = [];
          for (k = 1; k < kLen; k += 1) {
            if (k === 1) {
              pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
            }
            pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));
          }
          pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));
          commands[j] = pathArr;
        }
        if (singleShape) {
          xPos += letters[i].l;
          xPos += trackingOffset;
        }
        if (this.textSpans[cnt]) {
          this.textSpans[cnt].elem = commands;
        } else {
          this.textSpans[cnt] = { elem: commands };
        }
        cnt += 1;
      }
    };

    CVTextElement.prototype.renderInnerContent = function () {
      var ctx = this.canvasContext;
      ctx.font = this.values.fValue;
      ctx.lineCap = 'butt';
      ctx.lineJoin = 'miter';
      ctx.miterLimit = 4;

      if (!this.data.singleShape) {
        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      }

      var i;
      var len;
      var j;
      var jLen;
      var k;
      var kLen;
      var renderedLetters = this.textAnimator.renderedLetters;

      var letters = this.textProperty.currentData.l;

      len = letters.length;
      var renderedLetter;
      var lastFill = null;
      var lastStroke = null;
      var lastStrokeW = null;
      var commands;
      var pathArr;
      for (i = 0; i < len; i += 1) {
        if (!letters[i].n) {
          renderedLetter = renderedLetters[i];
          if (renderedLetter) {
            this.globalData.renderer.save();
            this.globalData.renderer.ctxTransform(renderedLetter.p);
            this.globalData.renderer.ctxOpacity(renderedLetter.o);
          }
          if (this.fill) {
            if (renderedLetter && renderedLetter.fc) {
              if (lastFill !== renderedLetter.fc) {
                lastFill = renderedLetter.fc;
                ctx.fillStyle = renderedLetter.fc;
              }
            } else if (lastFill !== this.values.fill) {
              lastFill = this.values.fill;
              ctx.fillStyle = this.values.fill;
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            this.globalData.canvasContext.fill();
            /// ctx.fillText(this.textSpans[i].val,0,0);
          }
          if (this.stroke) {
            if (renderedLetter && renderedLetter.sw) {
              if (lastStrokeW !== renderedLetter.sw) {
                lastStrokeW = renderedLetter.sw;
                ctx.lineWidth = renderedLetter.sw;
              }
            } else if (lastStrokeW !== this.values.sWidth) {
              lastStrokeW = this.values.sWidth;
              ctx.lineWidth = this.values.sWidth;
            }
            if (renderedLetter && renderedLetter.sc) {
              if (lastStroke !== renderedLetter.sc) {
                lastStroke = renderedLetter.sc;
                ctx.strokeStyle = renderedLetter.sc;
              }
            } else if (lastStroke !== this.values.stroke) {
              lastStroke = this.values.stroke;
              ctx.strokeStyle = this.values.stroke;
            }
            commands = this.textSpans[i].elem;
            jLen = commands.length;
            this.globalData.canvasContext.beginPath();
            for (j = 0; j < jLen; j += 1) {
              pathArr = commands[j];
              kLen = pathArr.length;
              this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);
              for (k = 2; k < kLen; k += 6) {
                this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);
              }
            }
            this.globalData.canvasContext.closePath();
            this.globalData.canvasContext.stroke();
            /// ctx.strokeText(letters[i].val,0,0);
          }
          if (renderedLetter) {
            this.globalData.renderer.restore();
          }
        }
      }
    };

    function CVEffects() {

    }
    CVEffects.prototype.renderFrame = function () {};

    /* global createTag, createNS, styleDiv, CVEffects, MaskElement, SVGBaseElement, HybridRenderer */

    function HBaseElement() {}
    HBaseElement.prototype = {
      checkBlendMode: function () {},
      initRendererElement: function () {
        this.baseElement = createTag(this.data.tg || 'div');
        if (this.data.hasMask) {
          this.svgElement = createNS('svg');
          this.layerElement = createNS('g');
          this.maskedElement = this.layerElement;
          this.svgElement.appendChild(this.layerElement);
          this.baseElement.appendChild(this.svgElement);
        } else {
          this.layerElement = this.baseElement;
        }
        styleDiv(this.baseElement);
      },
      createContainerElements: function () {
        this.renderableEffectsManager = new CVEffects(this);
        this.transformedElement = this.baseElement;
        this.maskedElement = this.layerElement;
        if (this.data.ln) {
          this.layerElement.setAttribute('id', this.data.ln);
        }
        if (this.data.cl) {
          this.layerElement.setAttribute('class', this.data.cl);
        }
        if (this.data.bm !== 0) {
          this.setBlendMode();
        }
      },
      renderElement: function () {
        var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var matrixValue = this.finalTransform.mat.toCSS();
          transformedElementStyle.transform = matrixValue;
          transformedElementStyle.webkitTransform = matrixValue;
        }
        if (this.finalTransform._opMdf) {
          transformedElementStyle.opacity = this.finalTransform.mProp.o.v;
        }
      },
      renderFrame: function () {
        // If it is exported as hidden (data.hd === true) no need to render
        // If it is not visible no need to render
        if (this.data.hd || this.hidden) {
          return;
        }
        this.renderTransform();
        this.renderRenderable();
        this.renderElement();
        this.renderInnerContent();
        if (this._isFirstFrame) {
          this._isFirstFrame = false;
        }
      },
      destroy: function () {
        this.layerElement = null;
        this.transformedElement = null;
        if (this.matteElement) {
          this.matteElement = null;
        }
        if (this.maskManager) {
          this.maskManager.destroy();
          this.maskManager = null;
        }
      },
      createRenderableComponents: function () {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function () {
      },
      setMatte: function () {},
    };
    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;
    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;
    HBaseElement.prototype.buildElementParenting = HybridRenderer.prototype.buildElementParenting;

    /* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
    RenderableDOMElement, createNS, createTag */

    function HSolidElement(data, globalData, comp) {
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement);

    HSolidElement.prototype.createContent = function () {
      var rect;
      if (this.data.hasMask) {
        rect = createNS('rect');
        rect.setAttribute('width', this.data.sw);
        rect.setAttribute('height', this.data.sh);
        rect.setAttribute('fill', this.data.sc);
        this.svgElement.setAttribute('width', this.data.sw);
        this.svgElement.setAttribute('height', this.data.sh);
      } else {
        rect = createTag('div');
        rect.style.width = this.data.sw + 'px';
        rect.style.height = this.data.sh + 'px';
        rect.style.backgroundColor = this.data.sc;
      }
      this.layerElement.appendChild(rect);
    };

    /* global createSizedArray, PropertyFactory, extendPrototype, HybridRenderer, ICompElement, HBaseElement */

    function HCompElement(data, globalData, comp) {
      this.layers = data.layers;
      this.supports3d = !data.hasMask;
      this.completeLayers = false;
      this.pendingElements = [];
      this.elements = this.layers ? createSizedArray(this.layers.length) : [];
      this.initElement(data, globalData, comp);
      this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
    }

    extendPrototype([HybridRenderer, ICompElement, HBaseElement], HCompElement);
    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;

    HCompElement.prototype.createContainerElements = function () {
      this._createBaseContainerElements();
      // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
      if (this.data.hasMask) {
        this.svgElement.setAttribute('width', this.data.w);
        this.svgElement.setAttribute('height', this.data.h);
        this.transformedElement = this.baseElement;
      } else {
        this.transformedElement = this.layerElement;
      }
    };

    HCompElement.prototype.addTo3dContainer = function (elem, pos) {
      var j = 0;
      var nextElement;
      while (j < pos) {
        if (this.elements[j] && this.elements[j].getBaseElement) {
          nextElement = this.elements[j].getBaseElement();
        }
        j += 1;
      }
      if (nextElement) {
        this.layerElement.insertBefore(elem, nextElement);
      } else {
        this.layerElement.appendChild(elem);
      }
    };

    /* global createNS, extendPrototype, BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement,
    HierarchyElement, FrameElement, RenderableElement, createNS, bmMin, bmSqrt, bmMin, bmMax, bmPow */

    function HShapeElement(data, globalData, comp) {
      // List of drawable elements
      this.shapes = [];
      // Full shape data
      this.shapesData = data.shapes;
      // List of styles that will be applied to shapes
      this.stylesList = [];
      // List of modifiers that will be applied to shapes
      this.shapeModifiers = [];
      // List of items in shape tree
      this.itemsData = [];
      // List of items in previous shape tree
      this.processedElements = [];
      // List of animated components
      this.animatedContents = [];
      this.shapesContainer = createNS('g');
      this.initElement(data, globalData, comp);
      // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
      // List of elements that have been created
      this.prevViewData = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0,
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement);
    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;

    HShapeElement.prototype.createContent = function () {
      var cont;
      this.baseElement.style.fontSize = 0;
      if (this.data.hasMask) {
        this.layerElement.appendChild(this.shapesContainer);
        cont = this.svgElement;
      } else {
        cont = createNS('svg');
        var size = this.comp.data ? this.comp.data : this.globalData.compSize;
        cont.setAttribute('width', size.w);
        cont.setAttribute('height', size.h);
        cont.appendChild(this.shapesContainer);
        this.layerElement.appendChild(cont);
      }

      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);
      this.filterUniqueShapes();
      this.shapeCont = cont;
    };

    HShapeElement.prototype.getTransformedPoint = function (transformers, point) {
      var i;
      var len = transformers.length;
      for (i = 0; i < len; i += 1) {
        point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);
      }
      return point;
    };

    HShapeElement.prototype.calculateShapeBoundingBox = function (item, boundingBox) {
      var shape = item.sh.v;
      var transformers = item.transformers;
      var i;
      var len = shape._length;
      var vPoint;
      var oPoint;
      var nextIPoint;
      var nextVPoint;
      if (len <= 1) {
        return;
      }
      for (i = 0; i < len - 1; i += 1) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
      if (shape.c) {
        vPoint = this.getTransformedPoint(transformers, shape.v[i]);
        oPoint = this.getTransformedPoint(transformers, shape.o[i]);
        nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);
        nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);
        this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);
      }
    };

    HShapeElement.prototype.checkBounds = function (vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {
      this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);
      var bounds = this.shapeBoundingBox;
      boundingBox.x = bmMin(bounds.left, boundingBox.x);
      boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);
      boundingBox.y = bmMin(bounds.top, boundingBox.y);
      boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);
    };

    HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
    };

    HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0,
    };

    HShapeElement.prototype.getBoundsOfCurve = function (p0, p1, p2, p3) {
      var bounds = [[p0[0], p3[0]], [p0[1], p3[1]]];

      for (var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i) { // eslint-disable-line no-plusplus
        b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        c = 3 * p1[i] - 3 * p0[i];

        b |= 0; // eslint-disable-line no-bitwise
        a |= 0; // eslint-disable-line no-bitwise
        c |= 0; // eslint-disable-line no-bitwise

        if (a === 0 && b === 0) ; else if (a === 0) {
          t = -c / b;

          if (t > 0 && t < 1) {
            bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));
          }
        } else {
          b2ac = b * b - 4 * c * a;

          if (b2ac >= 0) {
            t1 = (-b + bmSqrt(b2ac)) / (2 * a);
            if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));
            t2 = (-b - bmSqrt(b2ac)) / (2 * a);
            if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));
          }
        }
      }

      this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);
      this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);
      this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);
      this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);
    };

    HShapeElement.prototype.calculateF = function (t, p0, p1, p2, p3, i) {
      return bmPow(1 - t, 3) * p0[i]
            + 3 * bmPow(1 - t, 2) * t * p1[i]
            + 3 * (1 - t) * bmPow(t, 2) * p2[i]
            + bmPow(t, 3) * p3[i];
    };

    HShapeElement.prototype.calculateBoundingBox = function (itemsData, boundingBox) {
      var i;
      var len = itemsData.length;
      for (i = 0; i < len; i += 1) {
        if (itemsData[i] && itemsData[i].sh) {
          this.calculateShapeBoundingBox(itemsData[i], boundingBox);
        } else if (itemsData[i] && itemsData[i].it) {
          this.calculateBoundingBox(itemsData[i].it, boundingBox);
        }
      }
    };

    HShapeElement.prototype.currentBoxContains = function (box) {
      return this.currentBBox.x <= box.x
        && this.currentBBox.y <= box.y
        && this.currentBBox.width + this.currentBBox.x >= box.x + box.width
        && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;
    };

    HShapeElement.prototype.renderInnerContent = function () {
      this._renderShapeFrame();

      if (!this.hidden && (this._isFirstFrame || this._mdf)) {
        var tempBoundingBox = this.tempBoundingBox;
        var max = 999999;
        tempBoundingBox.x = max;
        tempBoundingBox.xMax = -max;
        tempBoundingBox.y = max;
        tempBoundingBox.yMax = -max;
        this.calculateBoundingBox(this.itemsData, tempBoundingBox);
        tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;
        tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;
        // var tempBoundingBox = this.shapeCont.getBBox();
        if (this.currentBoxContains(tempBoundingBox)) {
          return;
        }
        var changed = false;
        if (this.currentBBox.w !== tempBoundingBox.width) {
          this.currentBBox.w = tempBoundingBox.width;
          this.shapeCont.setAttribute('width', tempBoundingBox.width);
          changed = true;
        }
        if (this.currentBBox.h !== tempBoundingBox.height) {
          this.currentBBox.h = tempBoundingBox.height;
          this.shapeCont.setAttribute('height', tempBoundingBox.height);
          changed = true;
        }
        if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {
          this.currentBBox.w = tempBoundingBox.width;
          this.currentBBox.h = tempBoundingBox.height;
          this.currentBBox.x = tempBoundingBox.x;
          this.currentBBox.y = tempBoundingBox.y;

          this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
          var shapeStyle = this.shapeCont.style;
          var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
          shapeStyle.transform = shapeTransform;
          shapeStyle.webkitTransform = shapeTransform;
        }
      }
    };

    /* global extendPrototype, BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement,
    RenderableDOMElement, ITextElement, createSizedArray, createTag, styleDiv, createNS, lineJoinEnum, lineCapEnum */

    function HTextElement(data, globalData, comp) {
      this.textSpans = [];
      this.textPaths = [];
      this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0,
      };
      this.renderType = 'svg';
      this.isMasked = false;
      this.initElement(data, globalData, comp);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement);

    HTextElement.prototype.createContent = function () {
      this.isMasked = this.checkMasks();
      if (this.isMasked) {
        this.renderType = 'svg';
        this.compW = this.comp.data.w;
        this.compH = this.comp.data.h;
        this.svgElement.setAttribute('width', this.compW);
        this.svgElement.setAttribute('height', this.compH);
        var g = createNS('g');
        this.maskedElement.appendChild(g);
        this.innerElem = g;
      } else {
        this.renderType = 'html';
        this.innerElem = this.layerElement;
      }

      this.checkParenting();
    };

    HTextElement.prototype.buildNewText = function () {
      var documentData = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);
      var innerElemStyle = this.innerElem.style;
      var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';
      innerElemStyle.fill = textColor;
      innerElemStyle.color = textColor;
      if (documentData.sc) {
        innerElemStyle.stroke = this.buildColor(documentData.sc);
        innerElemStyle.strokeWidth = documentData.sw + 'px';
      }
      var fontData = this.globalData.fontManager.getFontByName(documentData.f);
      if (!this.globalData.fontManager.chars) {
        innerElemStyle.fontSize = documentData.finalSize + 'px';
        innerElemStyle.lineHeight = documentData.finalSize + 'px';
        if (fontData.fClass) {
          this.innerElem.className = fontData.fClass;
        } else {
          innerElemStyle.fontFamily = fontData.fFamily;
          var fWeight = documentData.fWeight;
          var fStyle = documentData.fStyle;
          innerElemStyle.fontStyle = fStyle;
          innerElemStyle.fontWeight = fWeight;
        }
      }
      var i;
      var len;

      var letters = documentData.l;
      len = letters.length;
      var tSpan;
      var tParent;
      var tCont;
      var matrixHelper = this.mHelper;
      var shapes;
      var shapeStr = '';
      var cnt = 0;
      for (i = 0; i < len; i += 1) {
        if (this.globalData.fontManager.chars) {
          if (!this.textPaths[cnt]) {
            tSpan = createNS('path');
            tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);
            tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);
            tSpan.setAttribute('stroke-miterlimit', '4');
          } else {
            tSpan = this.textPaths[cnt];
          }
          if (!this.isMasked) {
            if (this.textSpans[cnt]) {
              tParent = this.textSpans[cnt];
              tCont = tParent.children[0];
            } else {
              tParent = createTag('div');
              tParent.style.lineHeight = 0;
              tCont = createNS('svg');
              tCont.appendChild(tSpan);
              styleDiv(tParent);
            }
          }
        } else if (!this.isMasked) {
          if (this.textSpans[cnt]) {
            tParent = this.textSpans[cnt];
            tSpan = this.textPaths[cnt];
          } else {
            tParent = createTag('span');
            styleDiv(tParent);
            tSpan = createTag('span');
            styleDiv(tSpan);
            tParent.appendChild(tSpan);
          }
        } else {
          tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');
        }
        // tSpan.setAttribute('visibility', 'hidden');
        if (this.globalData.fontManager.chars) {
          var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
          var shapeData;
          if (charData) {
            shapeData = charData.data;
          } else {
            shapeData = null;
          }
          matrixHelper.reset();
          if (shapeData && shapeData.shapes) {
            shapes = shapeData.shapes[0].it;
            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
            shapeStr = this.createPathShape(matrixHelper, shapes);
            tSpan.setAttribute('d', shapeStr);
          }
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent);
            if (shapeData && shapeData.shapes) {
              // document.body.appendChild is needed to get exact measure of shape
              document.body.appendChild(tCont);
              var boundingBox = tCont.getBBox();
              tCont.setAttribute('width', boundingBox.width + 2);
              tCont.setAttribute('height', boundingBox.height + 2);
              tCont.setAttribute('viewBox', (boundingBox.x - 1) + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));
              var tContStyle = tCont.style;
              var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';
              tContStyle.transform = tContTranslation;
              tContStyle.webkitTransform = tContTranslation;

              letters[i].yOffset = boundingBox.y - 1;
            } else {
              tCont.setAttribute('width', 1);
              tCont.setAttribute('height', 1);
            }
            tParent.appendChild(tCont);
          } else {
            this.innerElem.appendChild(tSpan);
          }
        } else {
          tSpan.textContent = letters[i].val;
          tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');
          if (!this.isMasked) {
            this.innerElem.appendChild(tParent);
            //
            var tStyle = tSpan.style;
            var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';
            tStyle.transform = tSpanTranslation;
            tStyle.webkitTransform = tSpanTranslation;
          } else {
            this.innerElem.appendChild(tSpan);
          }
        }
        //
        if (!this.isMasked) {
          this.textSpans[cnt] = tParent;
        } else {
          this.textSpans[cnt] = tSpan;
        }
        this.textSpans[cnt].style.display = 'block';
        this.textPaths[cnt] = tSpan;
        cnt += 1;
      }
      while (cnt < this.textSpans.length) {
        this.textSpans[cnt].style.display = 'none';
        cnt += 1;
      }
    };

    HTextElement.prototype.renderInnerContent = function () {
      var svgStyle;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag) {
          return;
        } if (this.isMasked && this.finalTransform._matMdf) {
          // Todo Benchmark if using this is better than getBBox
          this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);
          svgStyle = this.svgElement.style;
          var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';
          svgStyle.transform = translation;
          svgStyle.webkitTransform = translation;
        }
      }

      this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {
        return;
      }
      var i;
      var len;
      var count = 0;
      var renderedLetters = this.textAnimator.renderedLetters;

      var letters = this.textProperty.currentData.l;

      len = letters.length;
      var renderedLetter;
      var textSpan;
      var textPath;
      for (i = 0; i < len; i += 1) {
        if (letters[i].n) {
          count += 1;
        } else {
          textSpan = this.textSpans[i];
          textPath = this.textPaths[i];
          renderedLetter = renderedLetters[count];
          count += 1;
          if (renderedLetter._mdf.m) {
            if (!this.isMasked) {
              textSpan.style.webkitTransform = renderedLetter.m;
              textSpan.style.transform = renderedLetter.m;
            } else {
              textSpan.setAttribute('transform', renderedLetter.m);
            }
          }
          /// /textSpan.setAttribute('opacity',renderedLetter.o);
          textSpan.style.opacity = renderedLetter.o;
          if (renderedLetter.sw && renderedLetter._mdf.sw) {
            textPath.setAttribute('stroke-width', renderedLetter.sw);
          }
          if (renderedLetter.sc && renderedLetter._mdf.sc) {
            textPath.setAttribute('stroke', renderedLetter.sc);
          }
          if (renderedLetter.fc && renderedLetter._mdf.fc) {
            textPath.setAttribute('fill', renderedLetter.fc);
            textPath.style.color = renderedLetter.fc;
          }
        }
      }

      if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
        var boundingBox = this.innerElem.getBBox();

        if (this.currentBBox.w !== boundingBox.width) {
          this.currentBBox.w = boundingBox.width;
          this.svgElement.setAttribute('width', boundingBox.width);
        }
        if (this.currentBBox.h !== boundingBox.height) {
          this.currentBBox.h = boundingBox.height;
          this.svgElement.setAttribute('height', boundingBox.height);
        }

        var margin = 1;
        if (this.currentBBox.w !== (boundingBox.width + margin * 2) || this.currentBBox.h !== (boundingBox.height + margin * 2) || this.currentBBox.x !== (boundingBox.x - margin) || this.currentBBox.y !== (boundingBox.y - margin)) {
          this.currentBBox.w = boundingBox.width + margin * 2;
          this.currentBBox.h = boundingBox.height + margin * 2;
          this.currentBBox.x = boundingBox.x - margin;
          this.currentBBox.y = boundingBox.y - margin;

          this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);
          svgStyle = this.svgElement.style;
          var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';
          svgStyle.transform = svgTransform;
          svgStyle.webkitTransform = svgTransform;
        }
      }
    };

    /* global extendPrototype, BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement,
    FrameElement, RenderableElement, createNS */

    function HImageElement(data, globalData, comp) {
      this.assetData = globalData.getAssetData(data.refId);
      this.initElement(data, globalData, comp);
    }

    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement);

    HImageElement.prototype.createContent = function () {
      var assetPath = this.globalData.getAssetsPath(this.assetData);
      var img = new Image();

      if (this.data.hasMask) {
        this.imageElem = createNS('image');
        this.imageElem.setAttribute('width', this.assetData.w + 'px');
        this.imageElem.setAttribute('height', this.assetData.h + 'px');
        this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);
        this.layerElement.appendChild(this.imageElem);
        this.baseElement.setAttribute('width', this.assetData.w);
        this.baseElement.setAttribute('height', this.assetData.h);
      } else {
        this.layerElement.appendChild(img);
      }
      img.crossOrigin = 'anonymous';
      img.src = assetPath;
      if (this.data.ln) {
        this.baseElement.setAttribute('id', this.data.ln);
      }
    };

    /* global PropertyFactory, degToRads, Matrix, extendPrototype, BaseElement, FrameElement, HierarchyElement */

    function HCameraElement(data, globalData, comp) {
      this.initFrame();
      this.initBaseData(data, globalData, comp);
      this.initHierarchy();
      var getProp = PropertyFactory.getProp;
      this.pe = getProp(this, data.pe, 0, 0, this);
      if (data.ks.p.s) {
        this.px = getProp(this, data.ks.p.x, 1, 0, this);
        this.py = getProp(this, data.ks.p.y, 1, 0, this);
        this.pz = getProp(this, data.ks.p.z, 1, 0, this);
      } else {
        this.p = getProp(this, data.ks.p, 1, 0, this);
      }
      if (data.ks.a) {
        this.a = getProp(this, data.ks.a, 1, 0, this);
      }
      if (data.ks.or.k.length && data.ks.or.k[0].to) {
        var i;
        var len = data.ks.or.k.length;
        for (i = 0; i < len; i += 1) {
          data.ks.or.k[i].to = null;
          data.ks.or.k[i].ti = null;
        }
      }
      this.or = getProp(this, data.ks.or, 1, degToRads, this);
      this.or.sh = true;
      this.rx = getProp(this, data.ks.rx, 0, degToRads, this);
      this.ry = getProp(this, data.ks.ry, 0, degToRads, this);
      this.rz = getProp(this, data.ks.rz, 0, degToRads, this);
      this.mat = new Matrix();
      this._prevMat = new Matrix();
      this._isFirstFrame = true;

      // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
      this.finalTransform = {
        mProp: this,
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement);

    HCameraElement.prototype.setup = function () {
      var i;
      var len = this.comp.threeDElements.length;
      var comp;
      var perspectiveStyle;
      var containerStyle;
      for (i = 0; i < len; i += 1) {
        // [perspectiveElem,container]
        comp = this.comp.threeDElements[i];
        if (comp.type === '3d') {
          perspectiveStyle = comp.perspectiveElem.style;
          containerStyle = comp.container.style;
          var perspective = this.pe.v + 'px';
          var origin = '0px 0px 0px';
          var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';
          perspectiveStyle.perspective = perspective;
          perspectiveStyle.webkitPerspective = perspective;
          containerStyle.transformOrigin = origin;
          containerStyle.mozTransformOrigin = origin;
          containerStyle.webkitTransformOrigin = origin;
          perspectiveStyle.transform = matrix;
          perspectiveStyle.webkitTransform = matrix;
        }
      }
    };

    HCameraElement.prototype.createElements = function () {
    };

    HCameraElement.prototype.hide = function () {
    };

    HCameraElement.prototype.renderFrame = function () {
      var _mdf = this._isFirstFrame;
      var i;
      var len;
      if (this.hierarchy) {
        len = this.hierarchy.length;
        for (i = 0; i < len; i += 1) {
          _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;
        }
      }
      if (_mdf || this.pe._mdf || (this.p && this.p._mdf) || (this.px && (this.px._mdf || this.py._mdf || this.pz._mdf)) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || (this.a && this.a._mdf)) {
        this.mat.reset();

        if (this.hierarchy) {
          len = this.hierarchy.length - 1;
          for (i = len; i >= 0; i -= 1) {
            var mTransf = this.hierarchy[i].finalTransform.mProp;
            this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);
            this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);
            this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);
            this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);
            this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);
          }
        }
        if (this.p) {
          this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);
        } else {
          this.mat.translate(-this.px.v, -this.py.v, this.pz.v);
        }
        if (this.a) {
          var diffVector;
          if (this.p) {
            diffVector = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]];
          } else {
            diffVector = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          }
          var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));
          // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
          var lookDir = [diffVector[0] / mag, diffVector[1] / mag, diffVector[2] / mag];
          var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);
          var mRotationX = (Math.atan2(lookDir[1], lookLengthOnXZ));
          var mRotationY = (Math.atan2(lookDir[0], -lookDir[2]));
          this.mat.rotateY(mRotationY).rotateX(-mRotationX);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);
        this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);
        this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);
        this.mat.translate(0, 0, this.pe.v);

        var hasMatrixChanged = !this._prevMat.equals(this.mat);
        if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {
          len = this.comp.threeDElements.length;
          var comp;
          var perspectiveStyle;
          var containerStyle;
          for (i = 0; i < len; i += 1) {
            comp = this.comp.threeDElements[i];
            if (comp.type === '3d') {
              if (hasMatrixChanged) {
                var matValue = this.mat.toCSS();
                containerStyle = comp.container.style;
                containerStyle.transform = matValue;
                containerStyle.webkitTransform = matValue;
              }
              if (this.pe._mdf) {
                perspectiveStyle = comp.perspectiveElem.style;
                perspectiveStyle.perspective = this.pe.v + 'px';
                perspectiveStyle.webkitPerspective = this.pe.v + 'px';
              }
            }
          }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = false;
    };

    HCameraElement.prototype.prepareFrame = function (num) {
      this.prepareProperties(num, true);
    };

    HCameraElement.prototype.destroy = function () {
    };
    HCameraElement.prototype.getBaseElement = function () { return null; };

    /* global createTag, AnimationItem */
    /* exported animationManager */

    var animationManager = (function () {
      var moduleOb = {};
      var registeredAnimations = [];
      var initTime = 0;
      var len = 0;
      var playingAnimationsNum = 0;
      var _stopped = true;
      var _isFrozen = false;

      function removeElement(ev) {
        var i = 0;
        var animItem = ev.target;
        while (i < len) {
          if (registeredAnimations[i].animation === animItem) {
            registeredAnimations.splice(i, 1);
            i -= 1;
            len -= 1;
            if (!animItem.isPaused) {
              subtractPlayingCount();
            }
          }
          i += 1;
        }
      }

      function registerAnimation(element, animationData) {
        if (!element) {
          return null;
        }
        var i = 0;
        while (i < len) {
          if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {
            return registeredAnimations[i].animation;
          }
          i += 1;
        }
        var animItem = new AnimationItem();
        setupAnimation(animItem, element);
        animItem.setData(element, animationData);
        return animItem;
      }

      function getRegisteredAnimations() {
        var i;
        var lenAnims = registeredAnimations.length;
        var animations = [];
        for (i = 0; i < lenAnims; i += 1) {
          animations.push(registeredAnimations[i].animation);
        }
        return animations;
      }

      function addPlayingCount() {
        playingAnimationsNum += 1;
        activate();
      }

      function subtractPlayingCount() {
        playingAnimationsNum -= 1;
      }

      function setupAnimation(animItem, element) {
        animItem.addEventListener('destroy', removeElement);
        animItem.addEventListener('_active', addPlayingCount);
        animItem.addEventListener('_idle', subtractPlayingCount);
        registeredAnimations.push({ elem: element, animation: animItem });
        len += 1;
      }

      function loadAnimation(params) {
        var animItem = new AnimationItem();
        setupAnimation(animItem, null);
        animItem.setParams(params);
        return animItem;
      }

      function setSpeed(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setSpeed(val, animation);
        }
      }

      function setDirection(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setDirection(val, animation);
        }
      }

      function play(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.play(animation);
        }
      }
      function resume(nowTime) {
        var elapsedTime = nowTime - initTime;
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.advanceTime(elapsedTime);
        }
        initTime = nowTime;
        if (playingAnimationsNum && !_isFrozen) {
          window.requestAnimationFrame(resume);
        } else {
          _stopped = true;
        }
      }

      function first(nowTime) {
        initTime = nowTime;
        window.requestAnimationFrame(resume);
      }

      function pause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.pause(animation);
        }
      }

      function goToAndStop(value, isFrame, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);
        }
      }

      function stop(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.stop(animation);
        }
      }

      function togglePause(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.togglePause(animation);
        }
      }

      function destroy(animation) {
        var i;
        for (i = (len - 1); i >= 0; i -= 1) {
          registeredAnimations[i].animation.destroy(animation);
        }
      }

      function searchAnimations(animationData, standalone, renderer) {
        var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')),
          [].slice.call(document.getElementsByClassName('bodymovin')));
        var i;
        var lenAnims = animElements.length;
        for (i = 0; i < lenAnims; i += 1) {
          if (renderer) {
            animElements[i].setAttribute('data-bm-type', renderer);
          }
          registerAnimation(animElements[i], animationData);
        }
        if (standalone && lenAnims === 0) {
          if (!renderer) {
            renderer = 'svg';
          }
          var body = document.getElementsByTagName('body')[0];
          body.innerText = '';
          var div = createTag('div');
          div.style.width = '100%';
          div.style.height = '100%';
          div.setAttribute('data-bm-type', renderer);
          body.appendChild(div);
          registerAnimation(div, animationData);
        }
      }

      function resize() {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.resize();
        }
      }

      function activate() {
        if (!_isFrozen && playingAnimationsNum) {
          if (_stopped) {
            window.requestAnimationFrame(first);
            _stopped = false;
          }
        }
      }

      function freeze() {
        _isFrozen = true;
      }

      function unfreeze() {
        _isFrozen = false;
        activate();
      }

      function setVolume(val, animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.setVolume(val, animation);
        }
      }

      function mute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.mute(animation);
        }
      }

      function unmute(animation) {
        var i;
        for (i = 0; i < len; i += 1) {
          registeredAnimations[i].animation.unmute(animation);
        }
      }

      moduleOb.registerAnimation = registerAnimation;
      moduleOb.loadAnimation = loadAnimation;
      moduleOb.setSpeed = setSpeed;
      moduleOb.setDirection = setDirection;
      moduleOb.play = play;
      moduleOb.pause = pause;
      moduleOb.stop = stop;
      moduleOb.togglePause = togglePause;
      moduleOb.searchAnimations = searchAnimations;
      moduleOb.resize = resize;
      // moduleOb.start = start;
      moduleOb.goToAndStop = goToAndStop;
      moduleOb.destroy = destroy;
      moduleOb.freeze = freeze;
      moduleOb.unfreeze = unfreeze;
      moduleOb.setVolume = setVolume;
      moduleOb.mute = mute;
      moduleOb.unmute = unmute;
      moduleOb.getRegisteredAnimations = getRegisteredAnimations;
      return moduleOb;
    }());

    /* global createElementID, subframeEnabled, ProjectInterface, ImagePreloader, audioControllerFactory, extendPrototype, BaseEvent,
    CanvasRenderer, SVGRenderer, HybridRenderer, dataManager, expressionsPlugin, BMEnterFrameEvent, BMCompleteLoopEvent,
    BMCompleteEvent, BMSegmentStartEvent, BMDestroyEvent, BMEnterFrameEvent, BMCompleteLoopEvent, BMCompleteEvent, BMSegmentStartEvent,
    BMDestroyEvent, BMRenderFrameErrorEvent, BMConfigErrorEvent, markerParser */

    var AnimationItem = function () {
      this._cbs = [];
      this.name = '';
      this.path = '';
      this.isLoaded = false;
      this.currentFrame = 0;
      this.currentRawFrame = 0;
      this.firstFrame = 0;
      this.totalFrames = 0;
      this.frameRate = 0;
      this.frameMult = 0;
      this.playSpeed = 1;
      this.playDirection = 1;
      this.playCount = 0;
      this.animationData = {};
      this.assets = [];
      this.isPaused = true;
      this.autoplay = false;
      this.loop = true;
      this.renderer = null;
      this.animationID = createElementID();
      this.assetsPath = '';
      this.timeCompleted = 0;
      this.segmentPos = 0;
      this.isSubframeEnabled = subframeEnabled;
      this.segments = [];
      this._idle = true;
      this._completedLoop = false;
      this.projectInterface = ProjectInterface();
      this.imagePreloader = new ImagePreloader();
      this.audioController = audioControllerFactory();
      this.markers = [];
      this.configAnimation = this.configAnimation.bind(this);
      this.onSetupError = this.onSetupError.bind(this);
      this.onSegmentComplete = this.onSegmentComplete.bind(this);
    };

    extendPrototype([BaseEvent], AnimationItem);

    AnimationItem.prototype.setParams = function (params) {
      if (params.wrapper || params.container) {
        this.wrapper = params.wrapper || params.container;
      }
      var animType = 'svg';
      if (params.animType) {
        animType = params.animType;
      } else if (params.renderer) {
        animType = params.renderer;
      }
      switch (animType) {
        case 'canvas':
          this.renderer = new CanvasRenderer(this, params.rendererSettings);
          break;
        case 'svg':
          this.renderer = new SVGRenderer(this, params.rendererSettings);
          break;
        default:
          this.renderer = new HybridRenderer(this, params.rendererSettings);
          break;
      }
      this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
      this.renderer.setProjectInterface(this.projectInterface);
      this.animType = animType;
      if (params.loop === ''
            || params.loop === null
            || params.loop === undefined
            || params.loop === true) {
        this.loop = true;
      } else if (params.loop === false) {
        this.loop = false;
      } else {
        this.loop = parseInt(params.loop, 10);
      }
      this.autoplay = 'autoplay' in params ? params.autoplay : true;
      this.name = params.name ? params.name : '';
      this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;
      this.assetsPath = params.assetsPath;
      this.initialSegment = params.initialSegment;
      if (params.audioFactory) {
        this.audioController.setAudioFactory(params.audioFactory);
      }
      if (params.animationData) {
        this.setupAnimation(params.animationData);
      } else if (params.path) {
        if (params.path.lastIndexOf('\\') !== -1) {
          this.path = params.path.substr(0, params.path.lastIndexOf('\\') + 1);
        } else {
          this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);
        }
        this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);
        this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));
        dataManager.loadAnimation(
          params.path,
          this.configAnimation,
          this.onSetupError
        );
      }
    };

    AnimationItem.prototype.onSetupError = function () {
      this.trigger('data_failed');
    };

    AnimationItem.prototype.setupAnimation = function (data) {
      dataManager.completeAnimation(
        data,
        this.configAnimation
      );
    };

    AnimationItem.prototype.setData = function (wrapper, animationData) {
      if (animationData) {
        if (typeof animationData !== 'object') {
          animationData = JSON.parse(animationData);
        }
      }
      var params = {
        wrapper: wrapper,
        animationData: animationData,
      };
      var wrapperAttributes = wrapper.attributes;

      params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-animation-path').value
        : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-path').value
          : wrapperAttributes.getNamedItem('bm-path')
            ? wrapperAttributes.getNamedItem('bm-path').value
            : '';
      params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-type').value
        : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-type').value
          : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary
            ? wrapperAttributes.getNamedItem('bm-type').value
            : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary
              ? wrapperAttributes.getNamedItem('data-bm-renderer').value
              : wrapperAttributes.getNamedItem('bm-renderer')
                ? wrapperAttributes.getNamedItem('bm-renderer').value
                : 'canvas';

      var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-loop').value
        : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-loop').value
          : wrapperAttributes.getNamedItem('bm-loop')
            ? wrapperAttributes.getNamedItem('bm-loop').value
            : '';
      if (loop === 'false') {
        params.loop = false;
      } else if (loop === 'true') {
        params.loop = true;
      } else if (loop !== '') {
        params.loop = parseInt(loop, 10);
      }
      var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-autoplay').value
        : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-autoplay').value
          : wrapperAttributes.getNamedItem('bm-autoplay')
            ? wrapperAttributes.getNamedItem('bm-autoplay').value
            : true;
      params.autoplay = autoplay !== 'false';

      params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-name').value
        : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-name').value
          : wrapperAttributes.getNamedItem('bm-name')
            ? wrapperAttributes.getNamedItem('bm-name').value
            : '';
      var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary
        ? wrapperAttributes.getNamedItem('data-anim-prerender').value
        : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary
          ? wrapperAttributes.getNamedItem('data-bm-prerender').value
          : wrapperAttributes.getNamedItem('bm-prerender')
            ? wrapperAttributes.getNamedItem('bm-prerender').value
            : '';

      if (prerender === 'false') {
        params.prerender = false;
      }
      this.setParams(params);
    };

    AnimationItem.prototype.includeLayers = function (data) {
      if (data.op > this.animationData.op) {
        this.animationData.op = data.op;
        this.totalFrames = Math.floor(data.op - this.animationData.ip);
      }
      var layers = this.animationData.layers;
      var i;
      var len = layers.length;
      var newLayers = data.layers;
      var j;
      var jLen = newLayers.length;
      for (j = 0; j < jLen; j += 1) {
        i = 0;
        while (i < len) {
          if (layers[i].id === newLayers[j].id) {
            layers[i] = newLayers[j];
            break;
          }
          i += 1;
        }
      }
      if (data.chars || data.fonts) {
        this.renderer.globalData.fontManager.addChars(data.chars);
        this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
      }
      if (data.assets) {
        len = data.assets.length;
        for (i = 0; i < len; i += 1) {
          this.animationData.assets.push(data.assets[i]);
        }
      }
      this.animationData.__complete = false;
      dataManager.completeAnimation(
        this.animationData,
        this.onSegmentComplete
      );
    };

    AnimationItem.prototype.onSegmentComplete = function (data) {
      this.animationData = data;
      if (expressionsPlugin) {
        expressionsPlugin.initExpressions(this);
      }
      this.loadNextSegment();
    };

    AnimationItem.prototype.loadNextSegment = function () {
      var segments = this.animationData.segments;
      if (!segments || segments.length === 0 || !this.autoloadSegments) {
        this.trigger('data_ready');
        this.timeCompleted = this.totalFrames;
        return;
      }
      var segment = segments.shift();
      this.timeCompleted = segment.time * this.frameRate;
      var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';
      this.segmentPos += 1;
      dataManager.loadData(segmentPath, this.includeLayers.bind(this), function () {
        this.trigger('data_failed');
      }.bind(this));
    };

    AnimationItem.prototype.loadSegments = function () {
      var segments = this.animationData.segments;
      if (!segments) {
        this.timeCompleted = this.totalFrames;
      }
      this.loadNextSegment();
    };

    AnimationItem.prototype.imagesLoaded = function () {
      this.trigger('loaded_images');
      this.checkLoaded();
    };

    AnimationItem.prototype.preloadImages = function () {
      this.imagePreloader.setAssetsPath(this.assetsPath);
      this.imagePreloader.setPath(this.path);
      this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    };

    AnimationItem.prototype.configAnimation = function (animData) {
      if (!this.renderer) {
        return;
      }
      try {
        this.animationData = animData;
        if (this.initialSegment) {
          this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
          this.firstFrame = Math.round(this.initialSegment[0]);
        } else {
          this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
          this.firstFrame = Math.round(this.animationData.ip);
        }
        this.renderer.configAnimation(animData);
        if (!animData.assets) {
          animData.assets = [];
        }

        this.assets = this.animationData.assets;
        this.frameRate = this.animationData.fr;
        this.frameMult = this.animationData.fr / 1000;
        this.renderer.searchExtraCompositions(animData.assets);
        this.markers = markerParser(animData.markers || []);
        this.trigger('config_ready');
        this.preloadImages();
        this.loadSegments();
        this.updaFrameModifier();
        this.waitForFontsLoaded();
        if (this.isPaused) {
          this.audioController.pause();
        }
      } catch (error) {
        this.triggerConfigError(error);
      }
    };

    AnimationItem.prototype.waitForFontsLoaded = function () {
      if (!this.renderer) {
        return;
      }
      if (this.renderer.globalData.fontManager.isLoaded) {
        this.checkLoaded();
      } else {
        setTimeout(this.waitForFontsLoaded.bind(this), 20);
      }
    };

    AnimationItem.prototype.checkLoaded = function () {
      if (!this.isLoaded
            && this.renderer.globalData.fontManager.isLoaded
            && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas')
            && (this.imagePreloader.loadedFootages())
      ) {
        this.isLoaded = true;
        if (expressionsPlugin) {
          expressionsPlugin.initExpressions(this);
        }
        this.renderer.initItems();
        setTimeout(function () {
          this.trigger('DOMLoaded');
        }.bind(this), 0);
        this.gotoFrame();
        if (this.autoplay) {
          this.play();
        }
      }
    };

    AnimationItem.prototype.resize = function () {
      this.renderer.updateContainerSize();
    };

    AnimationItem.prototype.setSubframe = function (flag) {
      this.isSubframeEnabled = !!flag;
    };

    AnimationItem.prototype.gotoFrame = function () {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise

      if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
        this.currentFrame = this.timeCompleted;
      }
      this.trigger('enterFrame');
      this.renderFrame();
      this.trigger('drawnFrame');
    };

    AnimationItem.prototype.renderFrame = function () {
      if (this.isLoaded === false || !this.renderer) {
        return;
      }
      try {
        this.renderer.renderFrame(this.currentFrame + this.firstFrame);
      } catch (error) {
        this.triggerRenderFrameError(error);
      }
    };

    AnimationItem.prototype.play = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === true) {
        this.isPaused = false;
        this.audioController.resume();
        if (this._idle) {
          this._idle = false;
          this.trigger('_active');
        }
      }
    };

    AnimationItem.prototype.pause = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === false) {
        this.isPaused = true;
        this._idle = true;
        this.trigger('_idle');
        this.audioController.pause();
      }
    };

    AnimationItem.prototype.togglePause = function (name) {
      if (name && this.name !== name) {
        return;
      }
      if (this.isPaused === true) {
        this.play();
      } else {
        this.pause();
      }
    };

    AnimationItem.prototype.stop = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.pause();
      this.playCount = 0;
      this._completedLoop = false;
      this.setCurrentRawFrameValue(0);
    };

    AnimationItem.prototype.getMarkerData = function (markerName) {
      var marker;
      for (var i = 0; i < this.markers.length; i += 1) {
        marker = this.markers[i];
        if (marker.payload && marker.payload.name === markerName) {
          return marker;
        }
      }
      return null;
    };

    AnimationItem.prototype.goToAndStop = function (value, isFrame, name) {
      if (name && this.name !== name) {
        return;
      }
      var numValue = Number(value);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value);
        if (marker) {
          this.goToAndStop(marker.time, true);
        }
      } else if (isFrame) {
        this.setCurrentRawFrameValue(value);
      } else {
        this.setCurrentRawFrameValue(value * this.frameModifier);
      }
      this.pause();
    };

    AnimationItem.prototype.goToAndPlay = function (value, isFrame, name) {
      if (name && this.name !== name) {
        return;
      }
      var numValue = Number(value);
      if (isNaN(numValue)) {
        var marker = this.getMarkerData(value);
        if (marker) {
          if (!marker.duration) {
            this.goToAndStop(marker.time, true);
          } else {
            this.playSegments([marker.time, marker.time + marker.duration], true);
          }
        }
      } else {
        this.goToAndStop(numValue, isFrame, name);
      }
      this.play();
    };

    AnimationItem.prototype.advanceTime = function (value) {
      if (this.isPaused === true || this.isLoaded === false) {
        return;
      }
      var nextValue = this.currentRawFrame + value * this.frameModifier;
      var _isComplete = false;
      // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
      // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
      if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
        if (!this.loop || this.playCount === this.loop) {
          if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
            _isComplete = true;
            nextValue = this.totalFrames - 1;
          }
        } else if (nextValue >= this.totalFrames) {
          this.playCount += 1;
          if (!this.checkSegments(nextValue % this.totalFrames)) {
            this.setCurrentRawFrameValue(nextValue % this.totalFrames);
            this._completedLoop = true;
            this.trigger('loopComplete');
          }
        } else {
          this.setCurrentRawFrameValue(nextValue);
        }
      } else if (nextValue < 0) {
        if (!this.checkSegments(nextValue % this.totalFrames)) {
          if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) { // eslint-disable-line no-plusplus
            this.setCurrentRawFrameValue(this.totalFrames + (nextValue % this.totalFrames));
            if (!this._completedLoop) {
              this._completedLoop = true;
            } else {
              this.trigger('loopComplete');
            }
          } else {
            _isComplete = true;
            nextValue = 0;
          }
        }
      } else {
        this.setCurrentRawFrameValue(nextValue);
      }
      if (_isComplete) {
        this.setCurrentRawFrameValue(nextValue);
        this.pause();
        this.trigger('complete');
      }
    };

    AnimationItem.prototype.adjustSegment = function (arr, offset) {
      this.playCount = 0;
      if (arr[1] < arr[0]) {
        if (this.frameModifier > 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(-1);
          }
        }
        this.totalFrames = arr[0] - arr[1];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[1];
        this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);
      } else if (arr[1] > arr[0]) {
        if (this.frameModifier < 0) {
          if (this.playSpeed < 0) {
            this.setSpeed(-this.playSpeed);
          } else {
            this.setDirection(1);
          }
        }
        this.totalFrames = arr[1] - arr[0];
        this.timeCompleted = this.totalFrames;
        this.firstFrame = arr[0];
        this.setCurrentRawFrameValue(0.001 + offset);
      }
      this.trigger('segmentStart');
    };
    AnimationItem.prototype.setSegment = function (init, end) {
      var pendingFrame = -1;
      if (this.isPaused) {
        if (this.currentRawFrame + this.firstFrame < init) {
          pendingFrame = init;
        } else if (this.currentRawFrame + this.firstFrame > end) {
          pendingFrame = end - init;
        }
      }

      this.firstFrame = init;
      this.totalFrames = end - init;
      this.timeCompleted = this.totalFrames;
      if (pendingFrame !== -1) {
        this.goToAndStop(pendingFrame, true);
      }
    };

    AnimationItem.prototype.playSegments = function (arr, forceFlag) {
      if (forceFlag) {
        this.segments.length = 0;
      }
      if (typeof arr[0] === 'object') {
        var i;
        var len = arr.length;
        for (i = 0; i < len; i += 1) {
          this.segments.push(arr[i]);
        }
      } else {
        this.segments.push(arr);
      }
      if (this.segments.length && forceFlag) {
        this.adjustSegment(this.segments.shift(), 0);
      }
      if (this.isPaused) {
        this.play();
      }
    };

    AnimationItem.prototype.resetSegments = function (forceFlag) {
      this.segments.length = 0;
      this.segments.push([this.animationData.ip, this.animationData.op]);
      if (forceFlag) {
        this.checkSegments(0);
      }
    };
    AnimationItem.prototype.checkSegments = function (offset) {
      if (this.segments.length) {
        this.adjustSegment(this.segments.shift(), offset);
        return true;
      }
      return false;
    };

    AnimationItem.prototype.destroy = function (name) {
      if ((name && this.name !== name) || !this.renderer) {
        return;
      }
      this.renderer.destroy();
      this.imagePreloader.destroy();
      this.trigger('destroy');
      this._cbs = null;
      this.onEnterFrame = null;
      this.onLoopComplete = null;
      this.onComplete = null;
      this.onSegmentStart = null;
      this.onDestroy = null;
      this.renderer = null;
      this.renderer = null;
      this.imagePreloader = null;
      this.projectInterface = null;
    };

    AnimationItem.prototype.setCurrentRawFrameValue = function (value) {
      this.currentRawFrame = value;
      this.gotoFrame();
    };

    AnimationItem.prototype.setSpeed = function (val) {
      this.playSpeed = val;
      this.updaFrameModifier();
    };

    AnimationItem.prototype.setDirection = function (val) {
      this.playDirection = val < 0 ? -1 : 1;
      this.updaFrameModifier();
    };

    AnimationItem.prototype.setVolume = function (val, name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.setVolume(val);
    };

    AnimationItem.prototype.getVolume = function () {
      return this.audioController.getVolume();
    };

    AnimationItem.prototype.mute = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.mute();
    };

    AnimationItem.prototype.unmute = function (name) {
      if (name && this.name !== name) {
        return;
      }
      this.audioController.unmute();
    };

    AnimationItem.prototype.updaFrameModifier = function () {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
      this.audioController.setRate(this.playSpeed * this.playDirection);
    };

    AnimationItem.prototype.getPath = function () {
      return this.path;
    };

    AnimationItem.prototype.getAssetsPath = function (assetData) {
      var path = '';
      if (assetData.e) {
        path = assetData.p;
      } else if (this.assetsPath) {
        var imagePath = assetData.p;
        if (imagePath.indexOf('images/') !== -1) {
          imagePath = imagePath.split('/')[1];
        }
        path = this.assetsPath + imagePath;
      } else {
        path = this.path;
        path += assetData.u ? assetData.u : '';
        path += assetData.p;
      }
      return path;
    };

    AnimationItem.prototype.getAssetData = function (id) {
      var i = 0;
      var len = this.assets.length;
      while (i < len) {
        if (id === this.assets[i].id) {
          return this.assets[i];
        }
        i += 1;
      }
      return null;
    };

    AnimationItem.prototype.hide = function () {
      this.renderer.hide();
    };

    AnimationItem.prototype.show = function () {
      this.renderer.show();
    };

    AnimationItem.prototype.getDuration = function (isFrame) {
      return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
    };

    AnimationItem.prototype.trigger = function (name) {
      if (this._cbs && this._cbs[name]) {
        switch (name) {
          case 'enterFrame':
          case 'drawnFrame':
            this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case 'loopComplete':
            this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
            break;
          case 'complete':
            this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
            break;
          case 'segmentStart':
            this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
            break;
          case 'destroy':
            this.triggerEvent(name, new BMDestroyEvent(name, this));
            break;
          default:
            this.triggerEvent(name);
        }
      }
      if (name === 'enterFrame' && this.onEnterFrame) {
        this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
      }
      if (name === 'loopComplete' && this.onLoopComplete) {
        this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
      }
      if (name === 'complete' && this.onComplete) {
        this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
      }
      if (name === 'segmentStart' && this.onSegmentStart) {
        this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
      }
      if (name === 'destroy' && this.onDestroy) {
        this.onDestroy.call(this, new BMDestroyEvent(name, this));
      }
    };

    AnimationItem.prototype.triggerRenderFrameError = function (nativeError) {
      var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent('error', error);

      if (this.onError) {
        this.onError.call(this, error);
      }
    };

    AnimationItem.prototype.triggerConfigError = function (nativeError) {
      var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
      this.triggerEvent('error', error);

      if (this.onError) {
        this.onError.call(this, error);
      }
    };

    /* global CompExpressionInterface, expressionsPlugin: writable */
    /* exported expressionsPlugin */

    var Expressions = (function () {
      var ob = {};
      ob.initExpressions = initExpressions;

      function initExpressions(animation) {
        var stackCount = 0;
        var registers = [];

        function pushExpression() {
          stackCount += 1;
        }

        function popExpression() {
          stackCount -= 1;
          if (stackCount === 0) {
            releaseInstances();
          }
        }

        function registerExpressionProperty(expression) {
          if (registers.indexOf(expression) === -1) {
            registers.push(expression);
          }
        }

        function releaseInstances() {
          var i;
          var len = registers.length;
          for (i = 0; i < len; i += 1) {
            registers[i].release();
          }
          registers.length = 0;
        }

        animation.renderer.compInterface = CompExpressionInterface(animation.renderer);
        animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);
        animation.renderer.globalData.pushExpression = pushExpression;
        animation.renderer.globalData.popExpression = popExpression;
        animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;
      }
      return ob;
    }());

    expressionsPlugin = Expressions;

    /* eslint-disable camelcase, no-unused-vars */
    /* global BMMath, BezierFactory, createTypedArray, degToRads, shapePool */

    var ExpressionManager = (function () {

      var ob = {};
      var Math = BMMath;

      BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;
      BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;
      BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;

      function initiateExpression(elem, data, property) {
        var val = data.x;
        var needsVelocity = /velocity(?![\w\d])/.test(val);
        var _needsRandom = val.indexOf('random') !== -1;
        var elemType = elem.data.ty;
        var transform;
        var content;
        var effect;
        var thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime;
        Object.defineProperty(thisProperty, 'value', {
          get: function () {
            return thisProperty.v;
          },
        });
        elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;
        elem.comp.displayStartTime = 0;
        elem.data.ip / elem.comp.globalData.frameRate;
        elem.data.op / elem.comp.globalData.frameRate;
        elem.data.sw ? elem.data.sw : 0;
        elem.data.sh ? elem.data.sh : 0;
        elem.data.nm;
        var thisLayer;
        var velocityAtTime;

        var scoped_bm_rt;
        // val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
        var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval
        property.kf ? data.k.length : 0;

        !this.data || this.data.hd !== true;

        (function wiggle(freq, amp) {
          var iWiggle;
          var j;
          var lenWiggle = this.pv.length ? this.pv.length : 1;
          var addedAmps = createTypedArray('float32', lenWiggle);
          freq = 5;
          var iterations = Math.floor(time * freq);
          iWiggle = 0;
          j = 0;
          while (iWiggle < iterations) {
            // var rnd = BMMath.random();
            for (j = 0; j < lenWiggle; j += 1) {
              addedAmps[j] += -amp + amp * 2 * BMMath.random();
              // addedAmps[j] += -amp + amp*2*rnd;
            }
            iWiggle += 1;
          }
          // var rnd2 = BMMath.random();
          var periods = time * freq;
          var perc = periods - Math.floor(periods);
          var arr = createTypedArray('float32', lenWiggle);
          if (lenWiggle > 1) {
            for (j = 0; j < lenWiggle; j += 1) {
              arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;
              // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
              // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
            }
            return arr;
          }
          return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;
        }).bind(this);

        if (thisProperty.loopIn) {
          thisProperty.loopIn.bind(thisProperty);
        }

        if (thisProperty.loopOut) {
          thisProperty.loopOut.bind(thisProperty);
        }

        if (thisProperty.smooth) {
          thisProperty.smooth.bind(thisProperty);
        }

        if (this.getValueAtTime) {
          this.getValueAtTime.bind(this);
        }

        if (this.getVelocityAtTime) {
          velocityAtTime = this.getVelocityAtTime.bind(this);
        }

        elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);

        function seedRandom(seed) {
          BMMath.seedrandom(randSeed + seed);
        }

        var time;
        var value;
        elem.data.ind;
        var hasParent = !!(elem.hierarchy && elem.hierarchy.length);
        var parent;
        var randSeed = Math.floor(Math.random() * 1000000);
        elem.globalData;
        function executeExpression(_value) {
          // globalData.pushExpression();
          value = _value;
          if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {
            return value;
          }
          if (this.propType === 'textSelector') ;
          if (!thisLayer) {
            elem.layerInterface.text;
            thisLayer = elem.layerInterface;
            elem.comp.compInterface;
            thisLayer.toWorld.bind(thisLayer);
            thisLayer.fromWorld.bind(thisLayer);
            thisLayer.fromComp.bind(thisLayer);
            thisLayer.toComp.bind(thisLayer);
            thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;
          }
          if (!transform) {
            transform = elem.layerInterface('ADBE Transform Group');
          }

          if (elemType === 4 && !content) {
            content = thisLayer('ADBE Root Vectors Group');
          }
          if (!effect) {
            effect = thisLayer(4);
          }
          hasParent = !!(elem.hierarchy && elem.hierarchy.length);
          if (hasParent && !parent) {
            parent = elem.hierarchy[0].layerInterface;
          }
          time = this.comp.renderedFrame / this.comp.globalData.frameRate;
          if (_needsRandom) {
            seedRandom(randSeed + time);
          }
          if (needsVelocity) {
            velocityAtTime(time);
          }
          expression_function();
          this.frameExpressionId = elem.globalData.frameId;

          // TODO: Check if it's possible to return on ShapeInterface the .v value
          if (scoped_bm_rt.propType === 'shape') ;
          // globalData.popExpression();
          return scoped_bm_rt;
        }
        return executeExpression;
      }

      ob.initiateExpression = initiateExpression;
      return ob;
    }());

    /* global ExpressionManager, createTypedArray */
    /* exported expressionHelpers */

    var expressionHelpers = (function () {
      function searchExpressions(elem, data, prop) {
        if (data.x) {
          prop.k = true;
          prop.x = true;
          prop.initiateExpression = ExpressionManager.initiateExpression;
          prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));
        }
      }

      function getValueAtTime(frameNum) {
        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastFrame) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;
          this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);
          this._cachingAtTime.lastFrame = frameNum;
        }
        return this._cachingAtTime.value;
      }

      function getSpeedAtTime(frameNum) {
        var delta = -0.01;
        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var speed = 0;
        if (v1.length) {
          var i;
          for (i = 0; i < v1.length; i += 1) {
            speed += Math.pow(v2[i] - v1[i], 2);
          }
          speed = Math.sqrt(speed) * 100;
        } else {
          speed = 0;
        }
        return speed;
      }

      function getVelocityAtTime(frameNum) {
        if (this.vel !== undefined) {
          return this.vel;
        }
        var delta = -0.001;
        // frameNum += this.elem.data.st;
        var v1 = this.getValueAtTime(frameNum);
        var v2 = this.getValueAtTime(frameNum + delta);
        var velocity;
        if (v1.length) {
          velocity = createTypedArray('float32', v1.length);
          var i;
          for (i = 0; i < v1.length; i += 1) {
            // removing frameRate
            // if needed, don't add it here
            // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
            velocity[i] = (v2[i] - v1[i]) / delta;
          }
        } else {
          velocity = (v2 - v1) / delta;
        }
        return velocity;
      }

      function getStaticValueAtTime() {
        return this.pv;
      }

      function setGroupProperty(propertyGroup) {
        this.propertyGroup = propertyGroup;
      }

      return {
        searchExpressions: searchExpressions,
        getSpeedAtTime: getSpeedAtTime,
        getVelocityAtTime: getVelocityAtTime,
        getValueAtTime: getValueAtTime,
        getStaticValueAtTime: getStaticValueAtTime,
        setGroupProperty: setGroupProperty,
      };
    }());

    /* global createTypedArray, Matrix, TransformPropertyFactory, expressionHelpers, PropertyFactory, expressionHelpers,
    initialDefaultFrame, shapePool, ShapePropertyFactory, bez, extendPrototype, ExpressionManager, createSizedArray */

    (function addPropertyDecorator() {
      function loopOut(type, duration, durationFlag) {
        if (!this.k || !this.keyframes) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : '';
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var lastKeyFrame = keyframes[keyframes.length - 1].t;
        if (currentFrame <= lastKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var firstKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);
          } else {
            cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);
          }
          firstKeyFrame = lastKeyFrame - cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === 'pingpong') {
          var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (iterations % 2 !== 0) {
              return this.getValueAtTime(((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
            var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line
          var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = (endV[i] - initV[i]) * repeats + current[i];
            }
            return ret;
          }
          return (endV - initV) * repeats + current;
        } else if (type === 'continue') {
          var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(lastValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
                ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line
            }
            return ret;
          }
          return lastValue + (lastValue - nextLastValue) * (((currentFrame - lastKeyFrame)) / 0.001);
        }
          return this.getValueAtTime((((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line

      }

      function loopIn(type, duration, durationFlag) {
        if (!this.k) {
          return this.pv;
        }
        type = type ? type.toLowerCase() : '';
        var currentFrame = this.comp.renderedFrame;
        var keyframes = this.keyframes;
        var firstKeyFrame = keyframes[0].t;
        if (currentFrame >= firstKeyFrame) {
          return this.pv;
        }
        var cycleDuration;
        var lastKeyFrame;
        if (!durationFlag) {
          if (!duration || duration > keyframes.length - 1) {
            duration = keyframes.length - 1;
          }
          lastKeyFrame = keyframes[duration].t;
          cycleDuration = lastKeyFrame - firstKeyFrame;
        } else {
          if (!duration) {
            cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);
          } else {
            cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);
          }
          lastKeyFrame = firstKeyFrame + cycleDuration;
        }
        var i;
        var len;
        var ret;
        if (type === 'pingpong') {
          var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);
          if (iterations % 2 === 0) {
              return this.getValueAtTime((((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line
          }
        } else if (type === 'offset') {
          var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);
          var current = this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration) + firstKeyFrame) / this.comp.globalData.frameRate, 0);
          var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;
          if (this.pv.length) {
            ret = new Array(initV.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = current[i] - (endV[i] - initV[i]) * repeats;
            }
            return ret;
          }
          return current - (endV - initV) * repeats;
        } else if (type === 'continue') {
          var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);
          var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            ret = new Array(firstValue.length);
            len = ret.length;
            for (i = 0; i < len; i += 1) {
              ret[i] = firstValue[i] + ((firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame)) / 0.001;
            }
            return ret;
          }
          return firstValue + ((firstValue - nextFirstValue) * (firstKeyFrame - currentFrame)) / 0.001;
        }
          return this.getValueAtTime(((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame))) / this.comp.globalData.frameRate, 0); // eslint-disable-line

      }

      function smooth(width, samples) {
        if (!this.k) {
          return this.pv;
        }
        width = (width || 0.4) * 0.5;
        samples = Math.floor(samples || 5);
        if (samples <= 1) {
          return this.pv;
        }
        var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;
        var initFrame = currentTime - width;
        var endFrame = currentTime + width;
        var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;
        var i = 0;
        var j = 0;
        var value;
        if (this.pv.length) {
          value = createTypedArray('float32', this.pv.length);
        } else {
          value = 0;
        }
        var sampleValue;
        while (i < samples) {
          sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);
          if (this.pv.length) {
            for (j = 0; j < this.pv.length; j += 1) {
              value[j] += sampleValue[j];
            }
          } else {
            value += sampleValue;
          }
          i += 1;
        }
        if (this.pv.length) {
          for (j = 0; j < this.pv.length; j += 1) {
            value[j] /= samples;
          }
        } else {
          value /= samples;
        }
        return value;
      }

      function getTransformValueAtTime(time) {
        if (!this._transformCachingAtTime) {
          this._transformCachingAtTime = {
            v: new Matrix(),
          };
        }
        /// /
        var matrix = this._transformCachingAtTime.v;
        matrix.cloneFromProps(this.pre.props);
        if (this.appliedTransformations < 1) {
          var anchor = this.a.getValueAtTime(time);
          matrix.translate(
            -anchor[0] * this.a.mult,
            -anchor[1] * this.a.mult,
            anchor[2] * this.a.mult
          );
        }
        if (this.appliedTransformations < 2) {
          var scale = this.s.getValueAtTime(time);
          matrix.scale(
            scale[0] * this.s.mult,
            scale[1] * this.s.mult,
            scale[2] * this.s.mult
          );
        }
        if (this.sk && this.appliedTransformations < 3) {
          var skew = this.sk.getValueAtTime(time);
          var skewAxis = this.sa.getValueAtTime(time);
          matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var rotation = this.r.getValueAtTime(time);
          matrix.rotate(-rotation * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var rotationZ = this.rz.getValueAtTime(time);
          var rotationY = this.ry.getValueAtTime(time);
          var rotationX = this.rx.getValueAtTime(time);
          var orientation = this.or.getValueAtTime(time);
          matrix.rotateZ(-rotationZ * this.rz.mult)
            .rotateY(rotationY * this.ry.mult)
            .rotateX(rotationX * this.rx.mult)
            .rotateZ(-orientation[2] * this.or.mult)
            .rotateY(orientation[1] * this.or.mult)
            .rotateX(orientation[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var positionX = this.px.getValueAtTime(time);
          var positionY = this.py.getValueAtTime(time);
          if (this.data.p.z) {
            var positionZ = this.pz.getValueAtTime(time);
            matrix.translate(
              positionX * this.px.mult,
              positionY * this.py.mult,
              -positionZ * this.pz.mult
            );
          } else {
            matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);
          }
        } else {
          var position = this.p.getValueAtTime(time);
          matrix.translate(
            position[0] * this.p.mult,
            position[1] * this.p.mult,
            -position[2] * this.p.mult
          );
        }
        return matrix;
        /// /
      }

      function getTransformStaticValueAtTime() {
        return this.v.clone(new Matrix());
      }

      var getTransformProperty = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function (elem, data, container) {
        var prop = getTransformProperty(elem, data, container);
        if (prop.dynamicProperties.length) {
          prop.getValueAtTime = getTransformValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        return prop;
      };

      var propertyGetProp = PropertyFactory.getProp;
      PropertyFactory.getProp = function (elem, data, type, mult, container) {
        var prop = propertyGetProp(elem, data, type, mult, container);
        // prop.getVelocityAtTime = getVelocityAtTime;
        // prop.loopOut = loopOut;
        // prop.loopIn = loopIn;
        if (prop.kf) {
          prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);
        } else {
          prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);
        }
        prop.setGroupProperty = expressionHelpers.setGroupProperty;
        prop.loopOut = loopOut;
        prop.loopIn = loopIn;
        prop.smooth = smooth;
        prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);
        prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);
        prop.numKeys = data.a === 1 ? data.k.length : 0;
        prop.propertyIndex = data.ix;
        var value = 0;
        if (type !== 0) {
          value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);
        }
        prop._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: value,
        };
        expressionHelpers.searchExpressions(elem, data, prop);
        if (prop.k) {
          container.addDynamicProperty(prop);
        }

        return prop;
      };

      function getShapeValueAtTime(frameNum) {
        // For now this caching object is created only when needed instead of creating it when the shape is initialized.
        if (!this._cachingAtTime) {
          this._cachingAtTime = {
            shapeValue: shapePool.clone(this.pv),
            lastIndex: 0,
            lastTime: initialDefaultFrame,
          };
        }

        frameNum *= this.elem.globalData.frameRate;
        frameNum -= this.offsetTime;
        if (frameNum !== this._cachingAtTime.lastTime) {
          this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;
          this._cachingAtTime.lastTime = frameNum;
          this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);
        }
        return this._cachingAtTime.shapeValue;
      }

      var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();
      var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();

      function ShapeExpressions() {}
      ShapeExpressions.prototype = {
        vertices: function (prop, time) {
          if (this.k) {
            this.getValue();
          }
          var shapePath = this.v;
          if (time !== undefined) {
            shapePath = this.getValueAtTime(time, 0);
          }
          var i;
          var len = shapePath._length;
          var vertices = shapePath[prop];
          var points = shapePath.v;
          var arr = createSizedArray(len);
          for (i = 0; i < len; i += 1) {
            if (prop === 'i' || prop === 'o') {
              arr[i] = [vertices[i][0] - points[i][0], vertices[i][1] - points[i][1]];
            } else {
              arr[i] = [vertices[i][0], vertices[i][1]];
            }
          }
          return arr;
        },
        points: function (time) {
          return this.vertices('v', time);
        },
        inTangents: function (time) {
          return this.vertices('i', time);
        },
        outTangents: function (time) {
          return this.vertices('o', time);
        },
        isClosed: function () {
          return this.v.c;
        },
        pointOnPath: function (perc, time) {
          var shapePath = this.v;
          if (time !== undefined) {
            shapePath = this.getValueAtTime(time, 0);
          }
          if (!this._segmentsLength) {
            this._segmentsLength = bez.getSegmentsLength(shapePath);
          }

          var segmentsLength = this._segmentsLength;
          var lengths = segmentsLength.lengths;
          var lengthPos = segmentsLength.totalLength * perc;
          var i = 0;
          var len = lengths.length;
          var accumulatedLength = 0;
          var pt;
          while (i < len) {
            if (accumulatedLength + lengths[i].addedLength > lengthPos) {
              var initIndex = i;
              var endIndex = (shapePath.c && i === len - 1) ? 0 : i + 1;
              var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;
              pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);
              break;
            } else {
              accumulatedLength += lengths[i].addedLength;
            }
            i += 1;
          }
          if (!pt) {
            pt = shapePath.c ? [shapePath.v[0][0], shapePath.v[0][1]] : [shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1]];
          }
          return pt;
        },
        vectorOnPath: function (perc, time, vectorType) {
          // perc doesn't use triple equality because it can be a Number object as well as a primitive.
          if (perc == 1) { // eslint-disable-line eqeqeq
            perc = this.v.c;
          } else if (perc == 0) { // eslint-disable-line eqeqeq
            perc = 0.999;
          }
          var pt1 = this.pointOnPath(perc, time);
          var pt2 = this.pointOnPath(perc + 0.001, time);
          var xLength = pt2[0] - pt1[0];
          var yLength = pt2[1] - pt1[1];
          var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));
          if (magnitude === 0) {
            return [0, 0];
          }
          var unitVector = vectorType === 'tangent' ? [xLength / magnitude, yLength / magnitude] : [-yLength / magnitude, xLength / magnitude];
          return unitVector;
        },
        tangentOnPath: function (perc, time) {
          return this.vectorOnPath(perc, time, 'tangent');
        },
        normalOnPath: function (perc, time) {
          return this.vectorOnPath(perc, time, 'normal');
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime,
      };
      extendPrototype([ShapeExpressions], ShapePropertyConstructorFunction);
      extendPrototype([ShapeExpressions], KeyframedShapePropertyConstructorFunction);
      KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;
      KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;

      var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function (elem, data, type, arr, trims) {
        var prop = propertyGetShapeProp(elem, data, type, arr, trims);
        prop.propertyIndex = data.ix;
        prop.lock = false;
        if (type === 3) {
          expressionHelpers.searchExpressions(elem, data.pt, prop);
        } else if (type === 4) {
          expressionHelpers.searchExpressions(elem, data.ks, prop);
        }
        if (prop.k) {
          elem.addDynamicProperty(prop);
        }
        return prop;
      };
    }());

    /* global ExpressionManager, TextProperty */

    (function addDecorator() {
      function searchExpressions() {
        if (this.data.d.x) {
          this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);
          this.addEffect(this.getExpressionValue.bind(this));
          return true;
        }
        return null;
      }

      TextProperty.prototype.getExpressionValue = function (currentValue, text) {
        var newValue = this.calculateExpression(text);
        if (currentValue.t !== newValue) {
          var newData = {};
          this.copyData(newData, currentValue);
          newData.t = newValue.toString();
          newData.__complete = false;
          return newData;
        }
        return currentValue;
      };

      TextProperty.prototype.searchProperty = function () {
        var isKeyframed = this.searchKeyframes();
        var hasExpressions = this.searchExpressions();
        this.kf = isKeyframed || hasExpressions;
        return this.kf;
      };

      TextProperty.prototype.searchExpressions = searchExpressions;
    }());

    /* global propertyGroupFactory, PropertyInterface */
    /* exported ShapePathInterface */

    var ShapePathInterface = (

      function () {
        return function pathInterfaceFactory(shape, view, propertyGroup) {
          var prop = view.sh;

          function interfaceFunction(val) {
            if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {
              return interfaceFunction.path;
            }
            return null;
          }

          var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
          prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));
          Object.defineProperties(interfaceFunction, {
            path: {
              get: function () {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              },
            },
            shape: {
              get: function () {
                if (prop.k) {
                  prop.getValue();
                }
                return prop;
              },
            },
            _name: { value: shape.nm },
            ix: { value: shape.ix },
            propertyIndex: { value: shape.ix },
            mn: { value: shape.mn },
            propertyGroup: { value: propertyGroup },
          });
          return interfaceFunction;
        };
      }()
    );

    /* exported propertyGroupFactory */

    var propertyGroupFactory = (function () {
      return function (interfaceFunction, parentPropertyGroup) {
        return function (val) {
          val = val === undefined ? 1 : val;
          if (val <= 0) {
            return interfaceFunction;
          }
          return parentPropertyGroup(val - 1);
        };
      };
    }());

    /* exported PropertyInterface */

    var PropertyInterface = (function () {
      return function (propertyName, propertyGroup) {
        var interfaceFunction = {
          _name: propertyName,
        };

        function _propertyGroup(val) {
          val = val === undefined ? 1 : val;
          if (val <= 0) {
            return interfaceFunction;
          }
          return propertyGroup(val - 1);
        }

        return _propertyGroup;
      };
    }());

    /* global ExpressionPropertyInterface, PropertyInterface, propertyGroupFactory, ShapePathInterface */
    /* exported ShapeExpressionInterface */

    var ShapeExpressionInterface = (function () {
      function iterateElements(shapes, view, propertyGroup) {
        var arr = [];
        var i;
        var len = shapes ? shapes.length : 0;
        for (i = 0; i < len; i += 1) {
          if (shapes[i].ty === 'gr') {
            arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'fl') {
            arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'st') {
            arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'tm') {
            arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'tr') ; else if (shapes[i].ty === 'el') {
            arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'sr') {
            arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'sh') {
            arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rc') {
            arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rd') {
            arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'rp') {
            arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else if (shapes[i].ty === 'gf') {
            arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));
          } else {
            arr.push(defaultInterfaceFactory(shapes[i], view[i]));
          }
        }
        return arr;
      }

      function contentsInterfaceFactory(shape, view, propertyGroup) {
        var interfaces;
        var interfaceFunction = function _interfaceFunction(value) {
          var i = 0;
          var len = interfaces.length;
          while (i < len) {
            if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {
              return interfaces[i];
            }
            i += 1;
          }
          if (typeof value === 'number') {
            return interfaces[value - 1];
          }
          return null;
        };

        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);
        interfaceFunction.numProperties = interfaces.length;
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.transform = transformInterface;
        interfaceFunction.propertyIndex = shape.cix;
        interfaceFunction._name = shape.nm;

        return interfaceFunction;
      }

      function groupInterfaceFactory(shape, view, propertyGroup) {
        var interfaceFunction = function _interfaceFunction(value) {
          switch (value) {
            case 'ADBE Vectors Group':
            case 'Contents':
            case 2:
              return interfaceFunction.content;
              // Not necessary for now. Keeping them here in case a new case appears
              // case 'ADBE Vector Transform Group':
              // case 3:
            default:
              return interfaceFunction.transform;
          }
        };
        interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);
        var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);
        interfaceFunction.content = content;
        interfaceFunction.transform = transformInterface;
        Object.defineProperty(interfaceFunction, '_name', {
          get: function () {
            return shape.nm;
          },
        });
        // interfaceFunction.content = interfaceFunction;
        interfaceFunction.numProperties = shape.np;
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.nm = shape.nm;
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function fillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === 'Color' || val === 'color') {
            return interfaceFunction.color;
          } if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c),
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o),
          },
          _name: { value: shape.nm },
          mn: { value: shape.mn },
        });

        view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
        return interfaceFunction;
      }

      function gradientFillInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === 'Start Point' || val === 'start point') {
            return interfaceFunction.startPoint;
          }
          if (val === 'End Point' || val === 'end point') {
            return interfaceFunction.endPoint;
          }
          if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          startPoint: {
            get: ExpressionPropertyInterface(view.s),
          },
          endPoint: {
            get: ExpressionPropertyInterface(view.e),
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o),
          },
          type: {
            get: function () {
              return 'a';
            },
          },
          _name: { value: shape.nm },
          mn: { value: shape.mn },
        });

        view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));
        view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));
        return interfaceFunction;
      }
      function defaultInterfaceFactory() {
        function interfaceFunction() {
          return null;
        }
        return interfaceFunction;
      }

      function strokeInterfaceFactory(shape, view, propertyGroup) {
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);
        function addPropertyToDashOb(i) {
          Object.defineProperty(dashOb, shape.d[i].nm, {
            get: ExpressionPropertyInterface(view.d.dataProps[i].p),
          });
        }
        var i;
        var len = shape.d ? shape.d.length : 0;
        var dashOb = {};
        for (i = 0; i < len; i += 1) {
          addPropertyToDashOb(i);
          view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);
        }

        function interfaceFunction(val) {
          if (val === 'Color' || val === 'color') {
            return interfaceFunction.color;
          } if (val === 'Opacity' || val === 'opacity') {
            return interfaceFunction.opacity;
          } if (val === 'Stroke Width' || val === 'stroke width') {
            return interfaceFunction.strokeWidth;
          }
          return null;
        }
        Object.defineProperties(interfaceFunction, {
          color: {
            get: ExpressionPropertyInterface(view.c),
          },
          opacity: {
            get: ExpressionPropertyInterface(view.o),
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(view.w),
          },
          dash: {
            get: function () {
              return dashOb;
            },
          },
          _name: { value: shape.nm },
          mn: { value: shape.mn },
        });

        view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));
        return interfaceFunction;
      }

      function trimInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(val) {
          if (val === shape.e.ix || val === 'End' || val === 'end') {
            return interfaceFunction.end;
          }
          if (val === shape.s.ix) {
            return interfaceFunction.start;
          }
          if (val === shape.o.ix) {
            return interfaceFunction.offset;
          }
          return null;
        }

        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;

        view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));
        view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));
        view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
        interfaceFunction.propertyIndex = shape.ix;
        interfaceFunction.propertyGroup = propertyGroup;

        Object.defineProperties(interfaceFunction, {
          start: {
            get: ExpressionPropertyInterface(view.s),
          },
          end: {
            get: ExpressionPropertyInterface(view.e),
          },
          offset: {
            get: ExpressionPropertyInterface(view.o),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function transformInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.a.ix === value || value === 'Anchor Point') {
            return interfaceFunction.anchorPoint;
          }
          if (shape.o.ix === value || value === 'Opacity') {
            return interfaceFunction.opacity;
          }
          if (shape.p.ix === value || value === 'Position') {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {
            return interfaceFunction.rotation;
          }
          if (shape.s.ix === value || value === 'Scale') {
            return interfaceFunction.scale;
          }
          if ((shape.sk && shape.sk.ix === value) || value === 'Skew') {
            return interfaceFunction.skew;
          }
          if ((shape.sa && shape.sa.ix === value) || value === 'Skew Axis') {
            return interfaceFunction.skewAxis;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));
        view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));
        view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
        if (view.transform.mProps.sk) {
          view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));
          view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));
        }
        view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          opacity: {
            get: ExpressionPropertyInterface(view.transform.mProps.o),
          },
          position: {
            get: ExpressionPropertyInterface(view.transform.mProps.p),
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(view.transform.mProps.a),
          },
          scale: {
            get: ExpressionPropertyInterface(view.transform.mProps.s),
          },
          rotation: {
            get: ExpressionPropertyInterface(view.transform.mProps.r),
          },
          skew: {
            get: ExpressionPropertyInterface(view.transform.mProps.sk),
          },
          skewAxis: {
            get: ExpressionPropertyInterface(view.transform.mProps.sa),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.ty = 'tr';
        interfaceFunction.mn = shape.mn;
        interfaceFunction.propertyGroup = propertyGroup;
        return interfaceFunction;
      }

      function ellipseInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.s.ix === value) {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        interfaceFunction.propertyIndex = shape.ix;
        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));

        Object.defineProperties(interfaceFunction, {
          size: {
            get: ExpressionPropertyInterface(prop.s),
          },
          position: {
            get: ExpressionPropertyInterface(prop.p),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function starInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value) {
            return interfaceFunction.rotation;
          }
          if (shape.pt.ix === value) {
            return interfaceFunction.points;
          }
          if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {
            return interfaceFunction.outerRadius;
          }
          if (shape.os.ix === value) {
            return interfaceFunction.outerRoundness;
          }
          if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {
            return interfaceFunction.innerRadius;
          }
          if (shape.is && shape.is.ix === value) {
            return interfaceFunction.innerRoundness;
          }
          return null;
        }

        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));
        prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));
        prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));
        if (shape.ir) {
          prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));
          prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));
        }

        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p),
          },
          rotation: {
            get: ExpressionPropertyInterface(prop.r),
          },
          points: {
            get: ExpressionPropertyInterface(prop.pt),
          },
          outerRadius: {
            get: ExpressionPropertyInterface(prop.or),
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(prop.os),
          },
          innerRadius: {
            get: ExpressionPropertyInterface(prop.ir),
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(prop.is),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function rectInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.p.ix === value) {
            return interfaceFunction.position;
          }
          if (shape.r.ix === value) {
            return interfaceFunction.roundness;
          }
          if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {
            return interfaceFunction.size;
          }
          return null;
        }
        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);

        var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;
        interfaceFunction.propertyIndex = shape.ix;
        prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));
        prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));
        prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));

        Object.defineProperties(interfaceFunction, {
          position: {
            get: ExpressionPropertyInterface(prop.p),
          },
          roundness: {
            get: ExpressionPropertyInterface(prop.r),
          },
          size: {
            get: ExpressionPropertyInterface(prop.s),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function roundedInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.r.ix === value || value === 'Round Corners 1') {
            return interfaceFunction.radius;
          }
          return null;
        }

        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));

        Object.defineProperties(interfaceFunction, {
          radius: {
            get: ExpressionPropertyInterface(prop.rd),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      function repeaterInterfaceFactory(shape, view, propertyGroup) {
        function interfaceFunction(value) {
          if (shape.c.ix === value || value === 'Copies') {
            return interfaceFunction.copies;
          } if (shape.o.ix === value || value === 'Offset') {
            return interfaceFunction.offset;
          }
          return null;
        }

        var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);
        var prop = view;
        interfaceFunction.propertyIndex = shape.ix;
        prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));
        prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));
        Object.defineProperties(interfaceFunction, {
          copies: {
            get: ExpressionPropertyInterface(prop.c),
          },
          offset: {
            get: ExpressionPropertyInterface(prop.o),
          },
          _name: { value: shape.nm },
        });
        interfaceFunction.mn = shape.mn;
        return interfaceFunction;
      }

      return function (shapes, view, propertyGroup) {
        var interfaces;
        function _interfaceFunction(value) {
          if (typeof value === 'number') {
            value = value === undefined ? 1 : value;
            if (value === 0) {
              return propertyGroup;
            }
            return interfaces[value - 1];
          }
          var i = 0;
          var len = interfaces.length;
          while (i < len) {
            if (interfaces[i]._name === value) {
              return interfaces[i];
            }
            i += 1;
          }
          return null;
        }
        function parentGroupWrapper() {
          return propertyGroup;
        }
        _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);
        interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);
        _interfaceFunction.numProperties = interfaces.length;
        _interfaceFunction._name = 'Contents';
        return _interfaceFunction;
      };
    }());

    /* exported TextExpressionInterface */

    var TextExpressionInterface = (function () {
      return function (elem) {
        var _prevValue;
        var _sourceText;
        function _thisLayerFunction(name) {
          switch (name) {
            case 'ADBE Text Document':
              return _thisLayerFunction.sourceText;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisLayerFunction, 'sourceText', {
          get: function () {
            elem.textProperty.getValue();
            var stringValue = elem.textProperty.currentData.t;
            if (stringValue !== _prevValue) {
              elem.textProperty.currentData.t = _prevValue;
              _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers
              // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
              _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers
            }
            return _sourceText;
          },
        });
        return _thisLayerFunction;
      };
    }());

    /* global Matrix, MaskManagerInterface, TransformExpressionInterface, getDescriptor */
    /* exported LayerExpressionInterface */

    var LayerExpressionInterface = (function () {
      function getMatrix(time) {
        var toWorldMat = new Matrix();
        if (time !== undefined) {
          var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);
          propMatrix.clone(toWorldMat);
        } else {
          var transformMat = this._elem.finalTransform.mProp;
          transformMat.applyToMatrix(toWorldMat);
        }
        return toWorldMat;
      }

      function toWorldVec(arr, time) {
        var toWorldMat = this.getMatrix(time);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.applyPoint(toWorldMat, arr);
      }

      function toWorld(arr, time) {
        var toWorldMat = this.getMatrix(time);
        return this.applyPoint(toWorldMat, arr);
      }

      function fromWorldVec(arr, time) {
        var toWorldMat = this.getMatrix(time);
        toWorldMat.props[12] = 0;
        toWorldMat.props[13] = 0;
        toWorldMat.props[14] = 0;
        return this.invertPoint(toWorldMat, arr);
      }

      function fromWorld(arr, time) {
        var toWorldMat = this.getMatrix(time);
        return this.invertPoint(toWorldMat, arr);
      }

      function applyPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);
      }

      function invertPoint(matrix, arr) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);
          }
        }
        return matrix.inversePoint(arr);
      }

      function fromComp(arr) {
        var toWorldMat = new Matrix();
        toWorldMat.reset();
        this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var i;
          var len = this._elem.hierarchy.length;
          for (i = 0; i < len; i += 1) {
            this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);
          }
          return toWorldMat.inversePoint(arr);
        }
        return toWorldMat.inversePoint(arr);
      }

      function sampleImage() {
        return [1, 1, 1, 1];
      }

      return function (elem) {
        var transformInterface;

        function _registerMaskInterface(maskManager) {
          _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);
        }
        function _registerEffectsInterface(effects) {
          _thisLayerFunction.effect = effects;
        }

        function _thisLayerFunction(name) {
          switch (name) {
            case 'ADBE Root Vectors Group':
            case 'Contents':
            case 2:
              return _thisLayerFunction.shapeInterface;
            case 1:
            case 6:
            case 'Transform':
            case 'transform':
            case 'ADBE Transform Group':
              return transformInterface;
            case 4:
            case 'ADBE Effect Parade':
            case 'effects':
            case 'Effects':
              return _thisLayerFunction.effect;
            case 'ADBE Text Properties':
              return _thisLayerFunction.textInterface;
            default:
              return null;
          }
        }
        _thisLayerFunction.getMatrix = getMatrix;
        _thisLayerFunction.invertPoint = invertPoint;
        _thisLayerFunction.applyPoint = applyPoint;
        _thisLayerFunction.toWorld = toWorld;
        _thisLayerFunction.toWorldVec = toWorldVec;
        _thisLayerFunction.fromWorld = fromWorld;
        _thisLayerFunction.fromWorldVec = fromWorldVec;
        _thisLayerFunction.toComp = toWorld;
        _thisLayerFunction.fromComp = fromComp;
        _thisLayerFunction.sampleImage = sampleImage;
        _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);
        _thisLayerFunction._elem = elem;
        transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);
        var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');
        Object.defineProperties(_thisLayerFunction, {
          hasParent: {
            get: function () {
              return elem.hierarchy.length;
            },
          },
          parent: {
            get: function () {
              return elem.hierarchy[0].layerInterface;
            },
          },
          rotation: getDescriptor(transformInterface, 'rotation'),
          scale: getDescriptor(transformInterface, 'scale'),
          position: getDescriptor(transformInterface, 'position'),
          opacity: getDescriptor(transformInterface, 'opacity'),
          anchorPoint: anchorPointDescriptor,
          anchor_point: anchorPointDescriptor,
          transform: {
            get: function () {
              return transformInterface;
            },
          },
          active: {
            get: function () {
              return elem.isInRange;
            },
          },
        });

        _thisLayerFunction.startTime = elem.data.st;
        _thisLayerFunction.index = elem.data.ind;
        _thisLayerFunction.source = elem.data.refId;
        _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;
        _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;
        _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;
        _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;
        _thisLayerFunction._name = elem.data.nm;

        _thisLayerFunction.registerMaskInterface = _registerMaskInterface;
        _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;
        return _thisLayerFunction;
      };
    }());

    /* global */
    /* exported FootageInterface */

    var FootageInterface = (function () {
      var outlineInterfaceFactory = (function (elem) {
        var currentPropertyName = '';
        var currentProperty = elem.getFootageData();
        function init() {
          currentPropertyName = '';
          currentProperty = elem.getFootageData();
          return searchProperty;
        }
        function searchProperty(value) {
          if (currentProperty[value]) {
            currentPropertyName = value;
            currentProperty = currentProperty[value];
            if (typeof currentProperty === 'object') {
              return searchProperty;
            }
            return currentProperty;
          }
          var propertyNameIndex = value.indexOf(currentPropertyName);
          if (propertyNameIndex !== -1) {
            var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);
            currentProperty = currentProperty[index];
            if (typeof currentProperty === 'object') {
              return searchProperty;
            }
            return currentProperty;
          }
          return '';
        }
        return init;
      });

      var dataInterfaceFactory = function (elem) {
        function interfaceFunction(value) {
          if (value === 'Outline') {
            return interfaceFunction.outlineInterface();
          }
          return null;
        }

        interfaceFunction._name = 'Outline';
        interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);
        return interfaceFunction;
      };

      return function (elem) {
        function _interfaceFunction(value) {
          if (value === 'Data') {
            return _interfaceFunction.dataInterface;
          }
          return null;
        }

        _interfaceFunction._name = 'Data';
        _interfaceFunction.dataInterface = dataInterfaceFactory(elem);
        return _interfaceFunction;
      };
    }());

    /* exported CompExpressionInterface */

    var CompExpressionInterface = (function () {
      return function (comp) {
        function _thisLayerFunction(name) {
          var i = 0;
          var len = comp.layers.length;
          while (i < len) {
            if (comp.layers[i].nm === name || comp.layers[i].ind === name) {
              return comp.elements[i].layerInterface;
            }
            i += 1;
          }
          return null;
          // return {active:false};
        }
        Object.defineProperty(_thisLayerFunction, '_name', { value: comp.data.nm });
        _thisLayerFunction.layer = _thisLayerFunction;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;
        _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;
        _thisLayerFunction.pixelAspect = 1;
        _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;
        _thisLayerFunction.displayStartTime = 0;
        _thisLayerFunction.numLayers = comp.layers.length;
        return _thisLayerFunction;
      };
    }());

    /* global ExpressionPropertyInterface */
    /* exported TransformExpressionInterface */

    var TransformExpressionInterface = (function () {
      return function (transform) {
        function _thisFunction(name) {
          switch (name) {
            case 'scale':
            case 'Scale':
            case 'ADBE Scale':
            case 6:
              return _thisFunction.scale;
            case 'rotation':
            case 'Rotation':
            case 'ADBE Rotation':
            case 'ADBE Rotate Z':
            case 10:
              return _thisFunction.rotation;
            case 'ADBE Rotate X':
              return _thisFunction.xRotation;
            case 'ADBE Rotate Y':
              return _thisFunction.yRotation;
            case 'position':
            case 'Position':
            case 'ADBE Position':
            case 2:
              return _thisFunction.position;
            case 'ADBE Position_0':
              return _thisFunction.xPosition;
            case 'ADBE Position_1':
              return _thisFunction.yPosition;
            case 'ADBE Position_2':
              return _thisFunction.zPosition;
            case 'anchorPoint':
            case 'AnchorPoint':
            case 'Anchor Point':
            case 'ADBE AnchorPoint':
            case 1:
              return _thisFunction.anchorPoint;
            case 'opacity':
            case 'Opacity':
            case 11:
              return _thisFunction.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(_thisFunction, 'rotation', {
          get: ExpressionPropertyInterface(transform.r || transform.rz),
        });

        Object.defineProperty(_thisFunction, 'zRotation', {
          get: ExpressionPropertyInterface(transform.rz || transform.r),
        });

        Object.defineProperty(_thisFunction, 'xRotation', {
          get: ExpressionPropertyInterface(transform.rx),
        });

        Object.defineProperty(_thisFunction, 'yRotation', {
          get: ExpressionPropertyInterface(transform.ry),
        });
        Object.defineProperty(_thisFunction, 'scale', {
          get: ExpressionPropertyInterface(transform.s),
        });
        var _px;
        var _py;
        var _pz;
        var _transformFactory;
        if (transform.p) {
          _transformFactory = ExpressionPropertyInterface(transform.p);
        } else {
          _px = ExpressionPropertyInterface(transform.px);
          _py = ExpressionPropertyInterface(transform.py);
          if (transform.pz) {
            _pz = ExpressionPropertyInterface(transform.pz);
          }
        }
        Object.defineProperty(_thisFunction, 'position', {
          get: function () {
            if (transform.p) {
              return _transformFactory();
            }
            return [
              _px(),
              _py(),
              _pz ? _pz() : 0];
          },
        });

        Object.defineProperty(_thisFunction, 'xPosition', {
          get: ExpressionPropertyInterface(transform.px),
        });

        Object.defineProperty(_thisFunction, 'yPosition', {
          get: ExpressionPropertyInterface(transform.py),
        });

        Object.defineProperty(_thisFunction, 'zPosition', {
          get: ExpressionPropertyInterface(transform.pz),
        });

        Object.defineProperty(_thisFunction, 'anchorPoint', {
          get: ExpressionPropertyInterface(transform.a),
        });

        Object.defineProperty(_thisFunction, 'opacity', {
          get: ExpressionPropertyInterface(transform.o),
        });

        Object.defineProperty(_thisFunction, 'skew', {
          get: ExpressionPropertyInterface(transform.sk),
        });

        Object.defineProperty(_thisFunction, 'skewAxis', {
          get: ExpressionPropertyInterface(transform.sa),
        });

        Object.defineProperty(_thisFunction, 'orientation', {
          get: ExpressionPropertyInterface(transform.or),
        });

        return _thisFunction;
      };
    }());

    /* exported ProjectInterface */

    var ProjectInterface = (function () {
      function registerComposition(comp) {
        this.compositions.push(comp);
      }

      return function () {
        function _thisProjectFunction(name) {
          var i = 0;
          var len = this.compositions.length;
          while (i < len) {
            if (this.compositions[i].data && this.compositions[i].data.nm === name) {
              if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {
                this.compositions[i].prepareFrame(this.currentFrame);
              }
              return this.compositions[i].compInterface;
            }
            i += 1;
          }
          return null;
        }

        _thisProjectFunction.compositions = [];
        _thisProjectFunction.currentFrame = 0;

        _thisProjectFunction.registerComposition = registerComposition;

        return _thisProjectFunction;
      };
    }());

    /* global propertyGroupFactory, ExpressionPropertyInterface, PropertyInterface */
    /* exported EffectsExpressionInterface */

    var EffectsExpressionInterface = (function () {
      var ob = {
        createEffectsInterface: createEffectsInterface,
      };

      function createEffectsInterface(elem, propertyGroup) {
        if (elem.effectsManager) {
          var effectElements = [];
          var effectsData = elem.data.ef;
          var i;
          var len = elem.effectsManager.effectElements.length;
          for (i = 0; i < len; i += 1) {
            effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));
          }

          var effects = elem.data.ef || [];
          var groupInterface = function (name) {
            i = 0;
            len = effects.length;
            while (i < len) {
              if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
                return effectElements[i];
              }
              i += 1;
            }
            return null;
          };
          Object.defineProperty(groupInterface, 'numProperties', {
            get: function () {
              return effects.length;
            },
          });
          return groupInterface;
        }
        return null;
      }

      function createGroupInterface(data, elements, propertyGroup, elem) {
        function groupInterface(name) {
          var effects = data.ef;
          var i = 0;
          var len = effects.length;
          while (i < len) {
            if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {
              if (effects[i].ty === 5) {
                return effectElements[i];
              }
              return effectElements[i]();
            }
            i += 1;
          }
          throw new Error();
        }
        var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);

        var effectElements = [];
        var i;
        var len = data.ef.length;
        for (i = 0; i < len; i += 1) {
          if (data.ef[i].ty === 5) {
            effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));
          } else {
            effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));
          }
        }

        if (data.mn === 'ADBE Color Control') {
          Object.defineProperty(groupInterface, 'color', {
            get: function () {
              return effectElements[0]();
            },
          });
        }
        Object.defineProperties(groupInterface, {
          numProperties: {
            get: function () {
              return data.np;
            },
          },
          _name: { value: data.nm },
          propertyGroup: { value: _propertyGroup },
        });
        groupInterface.enabled = data.en !== 0;
        groupInterface.active = groupInterface.enabled;
        return groupInterface;
      }

      function createValueInterface(element, type, elem, propertyGroup) {
        var expressionProperty = ExpressionPropertyInterface(element.p);
        function interfaceFunction() {
          if (type === 10) {
            return elem.comp.compInterface(element.p.v);
          }
          return expressionProperty();
        }

        if (element.p.setGroupProperty) {
          element.p.setGroupProperty(PropertyInterface('', propertyGroup));
        }

        return interfaceFunction;
      }

      return ob;
    }());

    /* global createSizedArray */
    /* exported MaskManagerInterface */

    var MaskManagerInterface = (function () {
      function MaskInterface(mask, data) {
        this._mask = mask;
        this._data = data;
      }
      Object.defineProperty(MaskInterface.prototype, 'maskPath', {
        get: function () {
          if (this._mask.prop.k) {
            this._mask.prop.getValue();
          }
          return this._mask.prop;
        },
      });
      Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {
        get: function () {
          if (this._mask.op.k) {
            this._mask.op.getValue();
          }
          return this._mask.op.v * 100;
        },
      });

      var MaskManager = function (maskManager) {
        var _masksInterfaces = createSizedArray(maskManager.viewData.length);
        var i;
        var len = maskManager.viewData.length;
        for (i = 0; i < len; i += 1) {
          _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);
        }

        var maskFunction = function (name) {
          i = 0;
          while (i < len) {
            if (maskManager.masksProperties[i].nm === name) {
              return _masksInterfaces[i];
            }
            i += 1;
          }
          return null;
        };
        return maskFunction;
      };
      return MaskManager;
    }());

    /* global createTypedArray */
    /* exported ExpressionPropertyInterface */

    var ExpressionPropertyInterface = (function () {
      var defaultUnidimensionalValue = { pv: 0, v: 0, mult: 1 };
      var defaultMultidimensionalValue = { pv: [0, 0, 0], v: [0, 0, 0], mult: 1 };

      function completeProperty(expressionValue, property, type) {
        Object.defineProperty(expressionValue, 'velocity', {
          get: function () {
            return property.getVelocityAtTime(property.comp.currentFrame);
          },
        });
        expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;
        expressionValue.key = function (pos) {
          if (!expressionValue.numKeys) {
            return 0;
          }
          var value = '';
          if ('s' in property.keyframes[pos - 1]) {
            value = property.keyframes[pos - 1].s;
          } else if ('e' in property.keyframes[pos - 2]) {
            value = property.keyframes[pos - 2].e;
          } else {
            value = property.keyframes[pos - 2].s;
          }
          var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers
          valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;
          valueProp.value = type === 'unidimensional' ? value[0] : value;
          return valueProp;
        };
        expressionValue.valueAtTime = property.getValueAtTime;
        expressionValue.speedAtTime = property.getSpeedAtTime;
        expressionValue.velocityAtTime = property.getVelocityAtTime;
        expressionValue.propertyGroup = property.propertyGroup;
      }

      function UnidimensionalPropertyInterface(property) {
        if (!property || !('pv' in property)) {
          property = defaultUnidimensionalValue;
        }
        var mult = 1 / property.mult;
        var val = property.pv * mult;
        var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
        expressionValue.value = val;
        completeProperty(expressionValue, property, 'unidimensional');

        return function () {
          if (property.k) {
            property.getValue();
          }
          val = property.v * mult;
          if (expressionValue.value !== val) {
            expressionValue = new Number(val); // eslint-disable-line no-new-wrappers
            expressionValue.value = val;
            completeProperty(expressionValue, property, 'unidimensional');
          }
          return expressionValue;
        };
      }

      function MultidimensionalPropertyInterface(property) {
        if (!property || !('pv' in property)) {
          property = defaultMultidimensionalValue;
        }
        var mult = 1 / property.mult;
        var len = (property.data && property.data.l) || property.pv.length;
        var expressionValue = createTypedArray('float32', len);
        var arrValue = createTypedArray('float32', len);
        expressionValue.value = arrValue;
        completeProperty(expressionValue, property, 'multidimensional');

        return function () {
          if (property.k) {
            property.getValue();
          }
          for (var i = 0; i < len; i += 1) {
            arrValue[i] = property.v[i] * mult;
            expressionValue[i] = arrValue[i];
          }
          return expressionValue;
        };
      }

      // TODO: try to avoid using this getter
      function defaultGetter() {
        return defaultUnidimensionalValue;
      }

      return function (property) {
        if (!property) {
          return defaultGetter;
        } if (property.propType === 'unidimensional') {
          return UnidimensionalPropertyInterface(property);
        }
        return MultidimensionalPropertyInterface(property);
      };
    }());

    /* global expressionHelpers, TextSelectorProp, ExpressionManager */
    /* exported TextExpressionSelectorPropFactory */

    var TextExpressionSelectorPropFactory = (function () { // eslint-disable-line no-unused-vars
      function getValueProxy(index, total) {
        this.textIndex = index + 1;
        this.textTotal = total;
        this.v = this.getValue() * this.mult;
        return this.v;
      }

      return function (elem, data) {
        this.pv = 1;
        this.comp = elem.comp;
        this.elem = elem;
        this.mult = 0.01;
        this.propType = 'textSelector';
        this.textTotal = data.totalChars;
        this.selectorValue = 100;
        this.lastValue = [1, 1, 1];
        this.k = true;
        this.x = true;
        this.getValue = ExpressionManager.initiateExpression.bind(this)(elem, data, this);
        this.getMult = getValueProxy;
        this.getVelocityAtTime = expressionHelpers.getVelocityAtTime;
        if (this.kf) {
          this.getValueAtTime = expressionHelpers.getValueAtTime.bind(this);
        } else {
          this.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(this);
        }
        this.setGroupProperty = expressionHelpers.setGroupProperty;
      };
    }());

    var propertyGetTextProp = TextSelectorProp.getTextSelectorProp;
    TextSelectorProp.getTextSelectorProp = function (elem, data, arr) {
      if (data.t === 1) {
        return new TextExpressionSelectorPropFactory(elem, data, arr); // eslint-disable-line no-undef
      }
      return propertyGetTextProp(elem, data, arr);
    };

    /* global PropertyFactory */
    /* exported SliderEffect, AngleEffect, ColorEffect, PointEffect, LayerIndexEffect, MaskIndexEffect, CheckboxEffect, NoValueEffect */

    function SliderEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function AngleEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function ColorEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function PointEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);
    }
    function LayerIndexEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function MaskIndexEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function CheckboxEffect(data, elem, container) {
      this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);
    }
    function NoValueEffect() {
      this.p = {};
    }

    /* global extendPrototype, SliderEffect, AngleEffect, ColorEffect, PointEffect, CheckboxEffect, LayerIndexEffect,
    MaskIndexEffect, NoValueEffect, DynamicPropertyContainer */

    function EffectsManager(data, element) {
      var effects = data.ef || [];
      this.effectElements = [];
      var i;
      var len = effects.length;
      var effectItem;
      for (i = 0; i < len; i += 1) {
        effectItem = new GroupEffect(effects[i], element);
        this.effectElements.push(effectItem);
      }
    }

    function GroupEffect(data, element) {
      this.init(data, element);
    }

    extendPrototype([DynamicPropertyContainer], GroupEffect);

    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;

    GroupEffect.prototype.init = function (data, element) {
      this.data = data;
      this.effectElements = [];
      this.initDynamicPropertyContainer(element);
      var i;
      var len = this.data.ef.length;
      var eff;
      var effects = this.data.ef;
      for (i = 0; i < len; i += 1) {
        eff = null;
        switch (effects[i].ty) {
          case 0:
            eff = new SliderEffect(effects[i], element, this);
            break;
          case 1:
            eff = new AngleEffect(effects[i], element, this);
            break;
          case 2:
            eff = new ColorEffect(effects[i], element, this);
            break;
          case 3:
            eff = new PointEffect(effects[i], element, this);
            break;
          case 4:
          case 7:
            eff = new CheckboxEffect(effects[i], element, this);
            break;
          case 10:
            eff = new LayerIndexEffect(effects[i], element, this);
            break;
          case 11:
            eff = new MaskIndexEffect(effects[i], element, this);
            break;
          case 5:
            eff = new EffectsManager(effects[i], element, this);
            break;
            // case 6:
          default:
            eff = new NoValueEffect(effects[i], element, this);
            break;
        }
        if (eff) {
          this.effectElements.push(eff);
        }
      }
    };


    var lottie = {};

    function setLocationHref(href) {
      locationHref = href;
    }

    function searchAnimations() {
      {
        animationManager.searchAnimations();
      }
    }

    function setSubframeRendering(flag) {
      subframeEnabled = flag;
    }

    function setIDPrefix(prefix) {
      idPrefix = prefix;
    }

    function loadAnimation(params) {
      return animationManager.loadAnimation(params);
    }

    function setQuality(value) {
      if (typeof value === 'string') {
        switch (value) {
          case 'high':
            defaultCurveSegments = 200;
            break;
          default:
          case 'medium':
            defaultCurveSegments = 50;
            break;
          case 'low':
            defaultCurveSegments = 10;
            break;
        }
      } else if (!isNaN(value) && value > 1) {
        defaultCurveSegments = value;
      }
    }

    function inBrowser() {
      return typeof navigator !== 'undefined';
    }

    function installPlugin(type, plugin) {
      if (type === 'expressions') {
        expressionsPlugin = plugin;
      }
    }

    function getFactory(name) {
      switch (name) {
        case 'propertyFactory':
          return PropertyFactory;
        case 'shapePropertyFactory':
          return ShapePropertyFactory;
        case 'matrix':
          return Matrix;
        default:
          return null;
      }
    }

    lottie.play = animationManager.play;
    lottie.pause = animationManager.pause;
    lottie.setLocationHref = setLocationHref;
    lottie.togglePause = animationManager.togglePause;
    lottie.setSpeed = animationManager.setSpeed;
    lottie.setDirection = animationManager.setDirection;
    lottie.stop = animationManager.stop;
    lottie.searchAnimations = searchAnimations;
    lottie.registerAnimation = animationManager.registerAnimation;
    lottie.loadAnimation = loadAnimation;
    lottie.setSubframeRendering = setSubframeRendering;
    lottie.resize = animationManager.resize;
    // lottie.start = start;
    lottie.goToAndStop = animationManager.goToAndStop;
    lottie.destroy = animationManager.destroy;
    lottie.setQuality = setQuality;
    lottie.inBrowser = inBrowser;
    lottie.installPlugin = installPlugin;
    lottie.freeze = animationManager.freeze;
    lottie.unfreeze = animationManager.unfreeze;
    lottie.setVolume = animationManager.setVolume;
    lottie.mute = animationManager.mute;
    lottie.unmute = animationManager.unmute;
    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
    lottie.useWebWorker = function (flag) {
      _useWebWorker = flag;
    };
    lottie.setIDPrefix = setIDPrefix;
    lottie.__getFactory = getFactory;
    lottie.version = '5.8.1';

    function checkReady() {
      if (document.readyState === 'complete') {
        clearInterval(readyStateCheckInterval);
        searchAnimations();
      }
    }

    function getQueryVariable(variable) {
      var vars = queryString.split('&');
      for (var i = 0; i < vars.length; i += 1) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) { // eslint-disable-line eqeqeq
          return decodeURIComponent(pair[1]);
        }
      }
      return null;
    }
    var queryString;
    {
      var scripts = document.getElementsByTagName('script');
      var index = scripts.length - 1;
      var myScript = scripts[index] || {
        src: '',
      };
      queryString = myScript.src.replace(/^[^\?]+\??/, ''); // eslint-disable-line no-useless-escape
      getQueryVariable('renderer');
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);

    return lottie;
    }));
    });

    /* node_modules/@lottiefiles/svelte-lottie-player/src/components/ColorPicker.svelte generated by Svelte v3.44.2 */
    const file$k = "node_modules/@lottiefiles/svelte-lottie-player/src/components/ColorPicker.svelte";

    function create_fragment$k(ctx) {
    	let div7;
    	let div3;
    	let div0;
    	let strong0;
    	let t1;
    	let input0;
    	let t2;
    	let input1;
    	let t3;
    	let div1;
    	let strong1;
    	let t5;
    	let input2;
    	let t6;
    	let input3;
    	let t7;
    	let div2;
    	let strong2;
    	let t9;
    	let input4;
    	let t10;
    	let input5;
    	let t11;
    	let div6;
    	let div4;
    	let t12;
    	let div5;
    	let input6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			strong0 = element("strong");
    			strong0.textContent = "Red";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			input1 = element("input");
    			t3 = space();
    			div1 = element("div");
    			strong1 = element("strong");
    			strong1.textContent = "Green";
    			t5 = space();
    			input2 = element("input");
    			t6 = space();
    			input3 = element("input");
    			t7 = space();
    			div2 = element("div");
    			strong2 = element("strong");
    			strong2.textContent = "Blue";
    			t9 = space();
    			input4 = element("input");
    			t10 = space();
    			input5 = element("input");
    			t11 = space();
    			div6 = element("div");
    			div4 = element("div");
    			t12 = space();
    			div5 = element("div");
    			input6 = element("input");
    			attr_dev(strong0, "class", "svelte-w9go3q");
    			add_location(strong0, file$k, 119, 6, 2291);
    			attr_dev(input0, "type", "range");
    			attr_dev(input0, "min", "0");
    			attr_dev(input0, "max", "255");
    			attr_dev(input0, "class", "svelte-w9go3q");
    			add_location(input0, file$k, 120, 6, 2318);
    			attr_dev(input1, "class", "text-input svelte-w9go3q");
    			attr_dev(input1, "type", "number");
    			add_location(input1, file$k, 121, 6, 2382);
    			attr_dev(div0, "class", "color-component svelte-w9go3q");
    			add_location(div0, file$k, 118, 4, 2255);
    			attr_dev(strong1, "class", "svelte-w9go3q");
    			add_location(strong1, file$k, 124, 6, 2493);
    			attr_dev(input2, "type", "range");
    			attr_dev(input2, "min", "0");
    			attr_dev(input2, "max", "255");
    			attr_dev(input2, "class", "svelte-w9go3q");
    			add_location(input2, file$k, 125, 6, 2522);
    			attr_dev(input3, "class", "text-input svelte-w9go3q");
    			attr_dev(input3, "type", "number");
    			add_location(input3, file$k, 126, 6, 2588);
    			attr_dev(div1, "class", "color-component svelte-w9go3q");
    			add_location(div1, file$k, 123, 4, 2457);
    			attr_dev(strong2, "class", "svelte-w9go3q");
    			add_location(strong2, file$k, 129, 6, 2701);
    			attr_dev(input4, "type", "range");
    			attr_dev(input4, "min", "0");
    			attr_dev(input4, "max", "255");
    			attr_dev(input4, "class", "svelte-w9go3q");
    			add_location(input4, file$k, 130, 6, 2729);
    			attr_dev(input5, "class", "text-input svelte-w9go3q");
    			attr_dev(input5, "type", "number");
    			add_location(input5, file$k, 131, 6, 2794);
    			attr_dev(div2, "class", "color-component svelte-w9go3q");
    			add_location(div2, file$k, 128, 4, 2665);
    			attr_dev(div3, "class", "color-selectors svelte-w9go3q");
    			add_location(div3, file$k, 117, 2, 2221);
    			attr_dev(div4, "class", "preview svelte-w9go3q");
    			set_style(div4, "background", /*rgb*/ ctx[4]);
    			add_location(div4, file$k, 135, 4, 2909);
    			attr_dev(input6, "class", "text-input svelte-w9go3q");
    			attr_dev(input6, "type", "text");
    			input6.value = /*hex*/ ctx[3];
    			add_location(input6, file$k, 137, 6, 2975);
    			add_location(div5, file$k, 136, 4, 2963);
    			attr_dev(div6, "class", "color-preview svelte-w9go3q");
    			add_location(div6, file$k, 134, 2, 2877);
    			attr_dev(div7, "class", "color-picker svelte-w9go3q");
    			add_location(div7, file$k, 116, 0, 2192);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div3);
    			append_dev(div3, div0);
    			append_dev(div0, strong0);
    			append_dev(div0, t1);
    			append_dev(div0, input0);
    			set_input_value(input0, /*red*/ ctx[0]);
    			append_dev(div0, t2);
    			append_dev(div0, input1);
    			set_input_value(input1, /*red*/ ctx[0]);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, strong1);
    			append_dev(div1, t5);
    			append_dev(div1, input2);
    			set_input_value(input2, /*green*/ ctx[1]);
    			append_dev(div1, t6);
    			append_dev(div1, input3);
    			set_input_value(input3, /*green*/ ctx[1]);
    			append_dev(div3, t7);
    			append_dev(div3, div2);
    			append_dev(div2, strong2);
    			append_dev(div2, t9);
    			append_dev(div2, input4);
    			set_input_value(input4, /*blue*/ ctx[2]);
    			append_dev(div2, t10);
    			append_dev(div2, input5);
    			set_input_value(input5, /*blue*/ ctx[2]);
    			append_dev(div7, t11);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			append_dev(div6, t12);
    			append_dev(div6, div5);
    			append_dev(div5, input6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*input0_change_input_handler*/ ctx[7]),
    					listen_dev(input0, "input", /*input0_change_input_handler*/ ctx[7]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input2, "change", /*input2_change_input_handler*/ ctx[9]),
    					listen_dev(input2, "input", /*input2_change_input_handler*/ ctx[9]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[10]),
    					listen_dev(input4, "change", /*input4_change_input_handler*/ ctx[11]),
    					listen_dev(input4, "input", /*input4_change_input_handler*/ ctx[11]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[12]),
    					listen_dev(input6, "change", /*change_handler*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*red*/ 1) {
    				set_input_value(input0, /*red*/ ctx[0]);
    			}

    			if (dirty & /*red*/ 1 && to_number(input1.value) !== /*red*/ ctx[0]) {
    				set_input_value(input1, /*red*/ ctx[0]);
    			}

    			if (dirty & /*green*/ 2) {
    				set_input_value(input2, /*green*/ ctx[1]);
    			}

    			if (dirty & /*green*/ 2 && to_number(input3.value) !== /*green*/ ctx[1]) {
    				set_input_value(input3, /*green*/ ctx[1]);
    			}

    			if (dirty & /*blue*/ 4) {
    				set_input_value(input4, /*blue*/ ctx[2]);
    			}

    			if (dirty & /*blue*/ 4 && to_number(input5.value) !== /*blue*/ ctx[2]) {
    				set_input_value(input5, /*blue*/ ctx[2]);
    			}

    			if (dirty & /*rgb*/ 16) {
    				set_style(div4, "background", /*rgb*/ ctx[4]);
    			}

    			if (dirty & /*hex*/ 8 && input6.value !== /*hex*/ ctx[3]) {
    				prop_dev(input6, "value", /*hex*/ ctx[3]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let rgb;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ColorPicker', slots, []);
    	const dispatch = createEventDispatcher();
    	let { color } = $$props;
    	let red = 0;
    	let green = 0;
    	let blue = 0;
    	let rgba = null;
    	let hex = null;

    	const parseColor = input => {
    		if (typeof input !== "string") {
    			return;
    		}

    		let colorComponents = [];

    		if (input[0] === "#") {
    			colorComponents = input.length === 4
    			? [input.slice(1, 2), input.slice(2, 3), input.slice(3, 4)].map(n => parseInt(`${n}${n}`, 16))
    			: [input.slice(1, 3), input.slice(3, 5), input.slice(5, 7)].map(n => parseInt(n, 16));
    		} else if (input.startsWith("rgb")) {
    			colorComponents = input.match(/\d+/g).map(n => parseInt(n));
    		}

    		if (colorComponents.length) {
    			$$invalidate(0, red = colorComponents[0]);
    			$$invalidate(1, green = colorComponents[1]);
    			$$invalidate(2, blue = colorComponents[2]);
    		}
    	};

    	const writable_props = ['color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ColorPicker> was created with unknown prop '${key}'`);
    	});

    	function input0_change_input_handler() {
    		red = to_number(this.value);
    		$$invalidate(0, red);
    	}

    	function input1_input_handler() {
    		red = to_number(this.value);
    		$$invalidate(0, red);
    	}

    	function input2_change_input_handler() {
    		green = to_number(this.value);
    		$$invalidate(1, green);
    	}

    	function input3_input_handler() {
    		green = to_number(this.value);
    		$$invalidate(1, green);
    	}

    	function input4_change_input_handler() {
    		blue = to_number(this.value);
    		$$invalidate(2, blue);
    	}

    	function input5_input_handler() {
    		blue = to_number(this.value);
    		$$invalidate(2, blue);
    	}

    	const change_handler = e => parseColor(e.target.value);

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		color,
    		red,
    		green,
    		blue,
    		rgba,
    		hex,
    		parseColor,
    		rgb
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(6, color = $$props.color);
    		if ('red' in $$props) $$invalidate(0, red = $$props.red);
    		if ('green' in $$props) $$invalidate(1, green = $$props.green);
    		if ('blue' in $$props) $$invalidate(2, blue = $$props.blue);
    		if ('rgba' in $$props) rgba = $$props.rgba;
    		if ('hex' in $$props) $$invalidate(3, hex = $$props.hex);
    		if ('rgb' in $$props) $$invalidate(4, rgb = $$props.rgb);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*color*/ 64) {
    			parseColor(color);
    		}

    		if ($$self.$$.dirty & /*red, green, blue*/ 7) {
    			$$invalidate(3, hex = "#" + (red | 1 << 8).toString(16).slice(1) + (green | 1 << 8).toString(16).slice(1) + (blue | 1 << 8).toString(16).slice(1));
    		}

    		if ($$self.$$.dirty & /*red, green, blue*/ 7) {
    			$$invalidate(4, rgb = `rgb(${red}, ${green}, ${blue})`);
    		}

    		if ($$self.$$.dirty & /*hex, rgb*/ 24) {
    			{
    				dispatch("color", { hex, rgb });
    			}
    		}
    	};

    	return [
    		red,
    		green,
    		blue,
    		hex,
    		rgb,
    		parseColor,
    		color,
    		input0_change_input_handler,
    		input1_input_handler,
    		input2_change_input_handler,
    		input3_input_handler,
    		input4_change_input_handler,
    		input5_input_handler,
    		change_handler
    	];
    }

    class ColorPicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$k, safe_not_equal, { color: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColorPicker",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*color*/ ctx[6] === undefined && !('color' in props)) {
    			console.warn("<ColorPicker> was created without expected prop 'color'");
    		}
    	}

    	get color() {
    		throw new Error("<ColorPicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<ColorPicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@lottiefiles/svelte-lottie-player/src/components/Info.svelte generated by Svelte v3.44.2 */

    const file$j = "node_modules/@lottiefiles/svelte-lottie-player/src/components/Info.svelte";

    // (64:0) {#if version}
    function create_if_block_10$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Lottie Version";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*version*/ ctx[9]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 65, 4, 1272);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 66, 4, 1318);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 64, 2, 1245);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*version*/ 512) set_data_dev(t2, /*version*/ ctx[9]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(64:0) {#if version}",
    		ctx
    	});

    	return block;
    }

    // (71:0) {#if numFrames}
    function create_if_block_9$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Frames";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numFrames*/ ctx[6]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 72, 4, 1416);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 73, 4, 1454);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 71, 2, 1389);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numFrames*/ 64) set_data_dev(t2, /*numFrames*/ ctx[6]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(71:0) {#if numFrames}",
    		ctx
    	});

    	return block;
    }

    // (78:0) {#if frameRate}
    function create_if_block_8$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Frame Rate";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*frameRate*/ ctx[1]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 79, 4, 1554);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 80, 4, 1596);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 78, 2, 1527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*frameRate*/ 2) set_data_dev(t2, /*frameRate*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(78:0) {#if frameRate}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if numLayers}
    function create_if_block_7$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Layers";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numLayers*/ ctx[7]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 86, 4, 1696);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 87, 4, 1734);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 85, 2, 1669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numLayers*/ 128) set_data_dev(t2, /*numLayers*/ ctx[7]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(85:0) {#if numLayers}",
    		ctx
    	});

    	return block;
    }

    // (92:0) {#if numAssets}
    function create_if_block_6$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Assets";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numAssets*/ ctx[4]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 93, 4, 1834);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 94, 4, 1872);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 92, 2, 1807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numAssets*/ 16) set_data_dev(t2, /*numAssets*/ ctx[4]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(92:0) {#if numAssets}",
    		ctx
    	});

    	return block;
    }

    // (99:0) {#if numFonts}
    function create_if_block_5$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Fonts";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*numFonts*/ ctx[5]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 100, 4, 1971);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 101, 4, 2008);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 99, 2, 1944);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*numFonts*/ 32) set_data_dev(t2, /*numFonts*/ ctx[5]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(99:0) {#if numFonts}",
    		ctx
    	});

    	return block;
    }

    // (106:0) {#if hasMeta}
    function create_if_block$3(ctx) {
    	let hr;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let if_block3_anchor;
    	let if_block0 = /*generator*/ ctx[2] && create_if_block_4$1(ctx);
    	let if_block1 = /*author*/ ctx[0] && create_if_block_3$1(ctx);
    	let if_block2 = /*keywords*/ ctx[3] && create_if_block_2$2(ctx);
    	let if_block3 = /*themeColor*/ ctx[8] && create_if_block_1$3(ctx);

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			if_block3_anchor = empty();
    			add_location(hr, file$j, 106, 2, 2078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, if_block3_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*generator*/ ctx[2]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*author*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*keywords*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_2$2(ctx);
    					if_block2.c();
    					if_block2.m(t3.parentNode, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*themeColor*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_1$3(ctx);
    					if_block3.c();
    					if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(if_block3_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(106:0) {#if hasMeta}",
    		ctx
    	});

    	return block;
    }

    // (109:2) {#if generator}
    function create_if_block_4$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Generator";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*generator*/ ctx[2]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 110, 6, 2137);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 111, 6, 2180);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 109, 4, 2108);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*generator*/ 4) set_data_dev(t2, /*generator*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(109:2) {#if generator}",
    		ctx
    	});

    	return block;
    }

    // (116:2) {#if author}
    function create_if_block_3$1(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Author";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*author*/ ctx[0]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 117, 6, 2287);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 118, 6, 2327);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 116, 4, 2258);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*author*/ 1) set_data_dev(t2, /*author*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(116:2) {#if author}",
    		ctx
    	});

    	return block;
    }

    // (123:2) {#if keywords}
    function create_if_block_2$2(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Keywords";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*keywords*/ ctx[3]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 124, 6, 2433);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 125, 6, 2475);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 123, 4, 2404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*keywords*/ 8) set_data_dev(t2, /*keywords*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(123:2) {#if keywords}",
    		ctx
    	});

    	return block;
    }

    // (130:2) {#if themeColor}
    function create_if_block_1$3(ctx) {
    	let div;
    	let span0;
    	let t1;
    	let span1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			span0.textContent = "Theme Color";
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*themeColor*/ ctx[8]);
    			attr_dev(span0, "class", "label svelte-1gm5gmt");
    			add_location(span0, file$j, 131, 6, 2585);
    			attr_dev(span1, "class", "value svelte-1gm5gmt");
    			add_location(span1, file$j, 132, 6, 2630);
    			attr_dev(div, "class", "property svelte-1gm5gmt");
    			add_location(div, file$j, 130, 4, 2556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*themeColor*/ 256) set_data_dev(t2, /*themeColor*/ ctx[8]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(130:2) {#if themeColor}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let h4;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let if_block6_anchor;
    	let if_block0 = /*version*/ ctx[9] && create_if_block_10$1(ctx);
    	let if_block1 = /*numFrames*/ ctx[6] && create_if_block_9$1(ctx);
    	let if_block2 = /*frameRate*/ ctx[1] && create_if_block_8$1(ctx);
    	let if_block3 = /*numLayers*/ ctx[7] && create_if_block_7$1(ctx);
    	let if_block4 = /*numAssets*/ ctx[4] && create_if_block_6$1(ctx);
    	let if_block5 = /*numFonts*/ ctx[5] && create_if_block_5$1(ctx);
    	let if_block6 = /*hasMeta*/ ctx[10] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Info";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (if_block5) if_block5.c();
    			t7 = space();
    			if (if_block6) if_block6.c();
    			if_block6_anchor = empty();
    			attr_dev(h4, "class", "svelte-1gm5gmt");
    			add_location(h4, file$j, 61, 0, 1214);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t7, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, if_block6_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*version*/ ctx[9]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_10$1(ctx);
    					if_block0.c();
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*numFrames*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_9$1(ctx);
    					if_block1.c();
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*frameRate*/ ctx[1]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_8$1(ctx);
    					if_block2.c();
    					if_block2.m(t4.parentNode, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*numLayers*/ ctx[7]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_7$1(ctx);
    					if_block3.c();
    					if_block3.m(t5.parentNode, t5);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (/*numAssets*/ ctx[4]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_6$1(ctx);
    					if_block4.c();
    					if_block4.m(t6.parentNode, t6);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (/*numFonts*/ ctx[5]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_5$1(ctx);
    					if_block5.c();
    					if_block5.m(t7.parentNode, t7);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*hasMeta*/ ctx[10]) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);
    				} else {
    					if_block6 = create_if_block$3(ctx);
    					if_block6.c();
    					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(if_block6_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Info', slots, []);
    	let { animationData } = $$props;
    	let author;
    	let frameRate;
    	let generator;
    	let keywords;
    	let numAssets;
    	let numFonts;
    	let numFrames;
    	let numLayers;
    	let themeColor;
    	let version;
    	let hasMeta = false;
    	const writable_props = ['animationData'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Info> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('animationData' in $$props) $$invalidate(11, animationData = $$props.animationData);
    	};

    	$$self.$capture_state = () => ({
    		animationData,
    		author,
    		frameRate,
    		generator,
    		keywords,
    		numAssets,
    		numFonts,
    		numFrames,
    		numLayers,
    		themeColor,
    		version,
    		hasMeta
    	});

    	$$self.$inject_state = $$props => {
    		if ('animationData' in $$props) $$invalidate(11, animationData = $$props.animationData);
    		if ('author' in $$props) $$invalidate(0, author = $$props.author);
    		if ('frameRate' in $$props) $$invalidate(1, frameRate = $$props.frameRate);
    		if ('generator' in $$props) $$invalidate(2, generator = $$props.generator);
    		if ('keywords' in $$props) $$invalidate(3, keywords = $$props.keywords);
    		if ('numAssets' in $$props) $$invalidate(4, numAssets = $$props.numAssets);
    		if ('numFonts' in $$props) $$invalidate(5, numFonts = $$props.numFonts);
    		if ('numFrames' in $$props) $$invalidate(6, numFrames = $$props.numFrames);
    		if ('numLayers' in $$props) $$invalidate(7, numLayers = $$props.numLayers);
    		if ('themeColor' in $$props) $$invalidate(8, themeColor = $$props.themeColor);
    		if ('version' in $$props) $$invalidate(9, version = $$props.version);
    		if ('hasMeta' in $$props) $$invalidate(10, hasMeta = $$props.hasMeta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*animationData*/ 2048) {
    			{
    				if (animationData) {
    					$$invalidate(1, frameRate = animationData.fr);
    					$$invalidate(4, numAssets = animationData.assets ? animationData.assets.length : 0);
    					$$invalidate(5, numFonts = animationData.fonts ? animationData.fonts.length : 0);
    					$$invalidate(6, numFrames = animationData.op - animationData.ip);
    					$$invalidate(7, numLayers = animationData.layers ? animationData.layers.length : 0);
    					$$invalidate(9, version = animationData.v);

    					if (animationData.meta) {
    						$$invalidate(10, hasMeta = true);
    						$$invalidate(0, author = animationData.meta.a);
    						$$invalidate(2, generator = animationData.meta.g);
    						$$invalidate(3, keywords = animationData.meta.k);
    						$$invalidate(8, themeColor = animationData.meta.tc);
    					}
    				}
    			}
    		}
    	};

    	return [
    		author,
    		frameRate,
    		generator,
    		keywords,
    		numAssets,
    		numFonts,
    		numFrames,
    		numLayers,
    		themeColor,
    		version,
    		hasMeta,
    		animationData
    	];
    }

    class Info extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$j, safe_not_equal, { animationData: 11 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Info",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*animationData*/ ctx[11] === undefined && !('animationData' in props)) {
    			console.warn("<Info> was created without expected prop 'animationData'");
    		}
    	}

    	get animationData() {
    		throw new Error("<Info>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animationData(value) {
    		throw new Error("<Info>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@lottiefiles/svelte-lottie-player/src/components/Popover.svelte generated by Svelte v3.44.2 */
    const file$i = "node_modules/@lottiefiles/svelte-lottie-player/src/components/Popover.svelte";
    const get_content_slot_changes = dirty => ({});
    const get_content_slot_context = ctx => ({});
    const get_target_slot_changes = dirty => ({});
    const get_target_slot_context = ctx => ({});

    function create_fragment$i(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let t1;
    	let div1;
    	let current;
    	let mounted;
    	let dispose;
    	const target_slot_template = /*#slots*/ ctx[8].target;
    	const target_slot = create_slot(target_slot_template, ctx, /*$$scope*/ ctx[7], get_target_slot_context);
    	const content_slot_template = /*#slots*/ ctx[8].content;
    	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[7], get_content_slot_context);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			if (target_slot) target_slot.c();
    			t0 = space();
    			div2 = element("div");
    			if (content_slot) content_slot.c();
    			t1 = space();
    			div1 = element("div");
    			add_location(div0, file$i, 88, 2, 1540);
    			attr_dev(div1, "class", "arrow svelte-cq7jp3");
    			set_style(div1, "border-color", /*color*/ ctx[0] + " transparent transparent transparent");
    			add_location(div1, file$i, 98, 4, 1811);
    			attr_dev(div2, "class", "popover-content svelte-cq7jp3");
    			toggle_class(div2, "hidden", !/*_open*/ ctx[4]);
    			toggle_class(div2, "left-align", /*_alignment*/ ctx[3] !== -1);
    			toggle_class(div2, "right-align", /*_alignment*/ ctx[3] === -1);
    			add_location(div2, file$i, 91, 2, 1608);
    			attr_dev(div3, "class", "popover svelte-cq7jp3");
    			add_location(div3, file$i, 81, 0, 1427);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);

    			if (target_slot) {
    				target_slot.m(div0, null);
    			}

    			/*div0_binding*/ ctx[12](div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);

    			if (content_slot) {
    				content_slot.m(div2, null);
    			}

    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			/*div2_binding*/ ctx[13](div2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div3, "mousedown", /*mousedown_handler*/ ctx[9], false, false, false),
    					listen_dev(div3, "mouseover", /*show*/ ctx[5], false, false, false),
    					listen_dev(div3, "mouseout", /*hide*/ ctx[6], false, false, false),
    					listen_dev(div3, "mouseup", /*mouseup_handler*/ ctx[10], false, false, false),
    					listen_dev(div3, "mousewheel", /*mousewheel_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (target_slot) {
    				if (target_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						target_slot,
    						target_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(target_slot_template, /*$$scope*/ ctx[7], dirty, get_target_slot_changes),
    						get_target_slot_context
    					);
    				}
    			}

    			if (content_slot) {
    				if (content_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						content_slot,
    						content_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(content_slot_template, /*$$scope*/ ctx[7], dirty, get_content_slot_changes),
    						get_content_slot_context
    					);
    				}
    			}

    			if (!current || dirty & /*color*/ 1) {
    				set_style(div1, "border-color", /*color*/ ctx[0] + " transparent transparent transparent");
    			}

    			if (dirty & /*_open*/ 16) {
    				toggle_class(div2, "hidden", !/*_open*/ ctx[4]);
    			}

    			if (dirty & /*_alignment*/ 8) {
    				toggle_class(div2, "left-align", /*_alignment*/ ctx[3] !== -1);
    			}

    			if (dirty & /*_alignment*/ 8) {
    				toggle_class(div2, "right-align", /*_alignment*/ ctx[3] === -1);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(target_slot, local);
    			transition_in(content_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(target_slot, local);
    			transition_out(content_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (target_slot) target_slot.d(detaching);
    			/*div0_binding*/ ctx[12](null);
    			if (content_slot) content_slot.d(detaching);
    			/*div2_binding*/ ctx[13](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Popover', slots, ['target','content']);
    	let { color = "transparent" } = $$props;
    	let _triggerRef;
    	let _contentRef;
    	let _alignment;
    	let _open = true;

    	onMount(() => {
    		const triggerBounds = _triggerRef.getBoundingClientRect();
    		const contentBounds = _contentRef.getBoundingClientRect();

    		$$invalidate(3, _alignment = triggerBounds.left + contentBounds.width > window.innerWidth
    		? -1
    		: 0);

    		$$invalidate(2, _contentRef.style.bottom = triggerBounds.height + "px", _contentRef);

    		// Start with content box hidden
    		hide();
    	});

    	/**
     * Show content box
     */
    	const show = () => {
    		$$invalidate(4, _open = true);
    	};

    	/**
     * Hide content box
     */
    	const hide = () => {
    		$$invalidate(4, _open = false);
    	};

    	const writable_props = ['color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Popover> was created with unknown prop '${key}'`);
    	});

    	function mousedown_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mouseup_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function mousewheel_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_triggerRef = $$value;
    			$$invalidate(1, _triggerRef);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_contentRef = $$value;
    			$$invalidate(2, _contentRef);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		color,
    		_triggerRef,
    		_contentRef,
    		_alignment,
    		_open,
    		show,
    		hide
    	});

    	$$self.$inject_state = $$props => {
    		if ('color' in $$props) $$invalidate(0, color = $$props.color);
    		if ('_triggerRef' in $$props) $$invalidate(1, _triggerRef = $$props._triggerRef);
    		if ('_contentRef' in $$props) $$invalidate(2, _contentRef = $$props._contentRef);
    		if ('_alignment' in $$props) $$invalidate(3, _alignment = $$props._alignment);
    		if ('_open' in $$props) $$invalidate(4, _open = $$props._open);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		color,
    		_triggerRef,
    		_contentRef,
    		_alignment,
    		_open,
    		show,
    		hide,
    		$$scope,
    		slots,
    		mousedown_handler,
    		mouseup_handler,
    		mousewheel_handler,
    		div0_binding,
    		div2_binding
    	];
    }

    class Popover extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$i, safe_not_equal, { color: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popover",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get color() {
    		throw new Error("<Popover>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Popover>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const PlayerRender = {
      SVG: 'svg',
      Canvas: 'canvas'
    };

    // Define valid player states
    const PlayerState = {
      Loading: 'loading',
      Playing: 'playing',
      Paused: 'paused',
      Stopped: 'stopped',
      Frozen: 'frozen',
      Error: 'error',
    };

    // Define play modes
    const PlayMode = {
      Normal: 'normal',
      Bounce: 'bounce',
    };

    // Define player events
    const PlayerEvents = {
      Load: 'load',
      Error: 'error',
      Ready: 'ready',
      Play: 'play',
      Pause: 'pause',
      Stop: 'stop',
      Freeze: 'freeze',
      Loop: 'loop',
      Complete: 'complete',
      Frame: 'frame',
    };

    // Define controls layout options
    const ControlsLayoutOptions = [
      "previousFrame",
      "playpause",
      "stop",
      "nextFrame",
      "progress",
      "frame",
      "loop",
      "spacer",
      "background",
      "snapshot",
      "info",
      "zoom"
    ];

    /**
     * Parse a resource into a JSON object or a URL string
     */
    const parseSrc = src => {
      if (typeof src === 'object') {
        return src;
      }

      try {
        return JSON.parse(src);
      } catch (e) {
        // Try construct an absolute URL from the src URL
        const srcUrl = new URL(src, window.location.href);

        return srcUrl.toString();
      }
    };

    /**
     * Trigger the download of the given data URI as a file
     *
     * @param {string} dataUri
     * @param {string} name
     */
    const triggerDownload = (dataUri, filename) => {
      const element = document.createElement('a');
      element.href = dataUri;
      element.download = filename;
      document.body.appendChild(element);

      element.click();

      document.body.removeChild(element);
    };

    /* node_modules/@lottiefiles/svelte-lottie-player/src/components/Controls.svelte generated by Svelte v3.44.2 */
    const file$h = "node_modules/@lottiefiles/svelte-lottie-player/src/components/Controls.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[40] = list[i];
    	return child_ctx;
    }

    // (426:32) 
    function create_if_block_13(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "spacer svelte-9yox50");
    			add_location(div, file$h, 426, 6, 13905);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(426:32) ",
    		ctx
    	});

    	return block;
    }

    // (419:39) 
    function create_if_block_12(ctx) {
    	let div;
    	let svg;
    	let path;
    	let rect;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			rect = svg_element("rect");
    			t = space();
    			attr_dev(path, "d", "M22 4.5a1.4 1.4 0 00-2.1-1.2l-13 7.5a1.4 1.4 0 000 2.4l13 7.5a1.4 1.4 0 002.1-1.2z");
    			add_location(path, file$h, 421, 10, 13641);
    			attr_dev(rect, "height", "17.1");
    			attr_dev(rect, "rx", "1.4");
    			attr_dev(rect, "transform", "matrix(-1 0 0 1 7.7 3.4)");
    			attr_dev(rect, "width", "5.7");
    			add_location(rect, file$h, 422, 10, 13752);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 420, 8, 13610);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$h, 419, 6, 13556);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(svg, rect);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*oPreviousFrame*/ ctx[24], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(419:39) ",
    		ctx
    	});

    	return block;
    }

    // (409:35) 
    function create_if_block_11(ctx) {
    	let div;
    	let svg;
    	let path;
    	let rect;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			rect = svg_element("rect");
    			t = space();
    			attr_dev(path, "d", "M2 19.513a1.429 1.429 0 0 0 2.148 1.234l12.88-7.513a1.429 1.429 0 0 0 0-2.468L4.147 3.253A1.429 1.429 0 0\n            0 2 4.487z");
    			add_location(path, file$h, 411, 10, 13204);
    			attr_dev(rect, "height", "17.143");
    			attr_dev(rect, "rx", "1.429");
    			attr_dev(rect, "transform", "matrix(1 0 0 -1 16.286 20.571)");
    			attr_dev(rect, "width", "5.714");
    			add_location(rect, file$h, 415, 10, 13384);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 410, 8, 13173);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$h, 409, 6, 13122);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(svg, rect);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onNextFrame*/ ctx[23], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(409:35) ",
    		ctx
    	});

    	return block;
    }

    // (397:31) 
    function create_if_block_10(ctx) {
    	let div;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t = space();
    			attr_dev(input, "class", "frame-number svelte-9yox50");
    			attr_dev(input, "type", "text");
    			add_location(input, file$h, 398, 8, 12677);
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$h, 397, 6, 12654);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*formattedFrame*/ ctx[15]);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[34]),
    					listen_dev(input, "mouseout", /*mouseout_handler_1*/ ctx[35], false, false, false),
    					listen_dev(input, "mouseover", /*mouseover_handler_1*/ ctx[36], false, false, false),
    					listen_dev(input, "input", /*input_handler*/ ctx[37], false, false, false),
    					listen_dev(input, "mousewheel", /*mousewheel_handler_1*/ ctx[38], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*formattedFrame*/ 32768 && input.value !== /*formattedFrame*/ ctx[15]) {
    				set_input_value(input, /*formattedFrame*/ ctx[15]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(397:31) ",
    		ctx
    	});

    	return block;
    }

    // (372:30) 
    function create_if_block_9(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot_2],
    					target: [create_target_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$h, 372, 6, 11620);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*animationData*/ 2 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(372:30) ",
    		ctx
    	});

    	return block;
    }

    // (350:30) 
    function create_if_block_7(ctx) {
    	let div;
    	let t;
    	let mounted;
    	let dispose;

    	function select_block_type_2(ctx, dirty) {
    		if (/*isZoomed*/ ctx[14]) return create_if_block_8;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t = space();
    			attr_dev(div, "class", "btn svelte-9yox50");
    			add_location(div, file$h, 350, 6, 10627);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*onToggleZoom*/ ctx[22], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(350:30) ",
    		ctx
    	});

    	return block;
    }

    // (316:34) 
    function create_if_block_6(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot_1],
    					target: [create_target_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	popover.$on("mousewheel", /*mousewheel_handler*/ ctx[31]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$h, 316, 6, 8924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseout", /*mouseout_handler*/ ctx[32], false, false, false),
    					listen_dev(div, "mouseover", /*mouseover_handler*/ ctx[33], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*snapshot, formattedFrame*/ 33792 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(316:34) ",
    		ctx
    	});

    	return block;
    }

    // (297:36) 
    function create_if_block_5(ctx) {
    	let div;
    	let popover;
    	let t;
    	let current;

    	popover = new Popover({
    			props: {
    				color: "#fff",
    				$$slots: {
    					content: [create_content_slot],
    					target: [create_target_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(popover.$$.fragment);
    			t = space();
    			attr_dev(div, "class", " svelte-9yox50");
    			add_location(div, file$h, 297, 6, 7986);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(popover, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const popover_changes = {};

    			if (dirty[0] & /*background*/ 4 | dirty[1] & /*$$scope*/ 4096) {
    				popover_changes.$$scope = { dirty, ctx };
    			}

    			popover.$set(popover_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popover.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popover.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(popover);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(297:36) ",
    		ctx
    	});

    	return block;
    }

    // (268:30) 
    function create_if_block_4(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t = space();
    			attr_dev(path0, "d", "M12.5 16.8137h-.13v1.8939h4.9696c3.6455 0 6.6113-2.9658 6.6113-6.6116\n            0-3.64549-2.9658-6.61131-6.6113-6.61131-.5231 0-.947.42391-.947.94696 0 .52304.4239.94696.947.94696 2.6011 0\n            4.7174 2.11634 4.7174 4.71739 0 2.6014-2.1166 4.7177-4.7174 4.7177H12.5zM13.6025\n            5.61469v-.13H7.48137C3.83582 5.48469.87 8.45051.87 12.096c0 3.6509 3.17269 6.6117 6.81304 6.6117.52304 0\n            .94696-.424.94696-.947 0-.5231-.42392-.947-.94696-.947-2.60804 0-4.91907-2.1231-4.91907-4.7176 0-2.60115\n            2.11634-4.71744 4.7174-4.71744h6.12113V5.61469z");
    			attr_dev(path0, "stroke", "#8795A1");
    			attr_dev(path0, "stroke-width", ".26");
    			add_location(path0, file$h, 270, 10, 6259);
    			attr_dev(path1, "d", "M11.1482\n            2.20355h0l-.001-.00116c-.3412-.40061-.9405-.44558-1.33668-.0996h-.00001c-.39526.34519-.43936.94795-.09898\n            1.34767l2.51487 3.03683-2.51894 3.06468c-.33872.40088-.29282 1.00363.10347\n            1.34723l.08517-.0982-.08517.0982c.17853.1549.39807.2308.61647.2308.2671 0 .5328-.114.72-.3347h0l.0011-.0014\n            3.0435-3.68655.0006-.00068c.3035-.35872.3025-.88754-.0019-1.24526l-3.0425-3.65786zM13.9453\n            21.7965h0l.001.0011c.3413.4006.9407.4456 1.337.0996h0c.3953-.3452.4395-.9479.099-1.3477l-2.5154-3.0368\n            2.5195-3.0647c.3388-.4008.2929-1.0036-.1035-1.3472l-.0852.0982.0852-.0982c-.1786-.1549-.3981-.2308-.6166-.2308-.2671\n            0-.5329.114-.7202.3347h0l-.0011.0014-3.0442\n            3.6865c-.0001.0003-.0003.0005-.0005.0007-.3036.3587-.3027.8876.0019 1.2453l3.0431 3.6579z");
    			attr_dev(path1, "fill", "#8795A1");
    			attr_dev(path1, "stroke", "#8795A1");
    			attr_dev(path1, "stroke-width", ".26");
    			add_location(path1, file$h, 280, 10, 6948);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 269, 8, 6228);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*loop*/ ctx[7]);
    			add_location(div, file$h, 268, 6, 6153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*toggleLooping*/ ctx[12])) /*toggleLooping*/ ctx[12].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);

    			if (dirty[0] & /*loop*/ 128) {
    				toggle_class(div, "active", /*loop*/ ctx[7]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(268:30) ",
    		ctx
    	});

    	return block;
    }

    // (252:34) 
    function create_if_block_3(ctx) {
    	let input;
    	let input_style_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "class", "progress svelte-9yox50");
    			attr_dev(input, "type", "range");
    			attr_dev(input, "min", "0");
    			attr_dev(input, "step", "1");
    			attr_dev(input, "max", "100");

    			attr_dev(input, "style", input_style_value = `
          background-image: -webkit-gradient(linear, left top, right top, color-stop(${/*progress*/ ctx[0]}%, rgba(15, 204, 206, 0.4)), color-stop(${/*progress*/ ctx[0]}%, #DAE1E7));
          background-image: -moz-linear-gradient(left center, rgba(15, 204, 206, 0.4) 0%, rgba(15, 204, 206, 0.4) ${/*progress*/ ctx[0]}%, #DAE1E7 ${/*progress*/ ctx[0]}%, #DAE1E7 100%);
        `);

    			add_location(input, file$h, 252, 6, 5516);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*progress*/ ctx[0]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_input_handler*/ ctx[28]),
    					listen_dev(input, "input", /*input_change_input_handler*/ ctx[28]),
    					listen_dev(input, "input", /*onHandleSeekChange*/ ctx[20], false, false, false),
    					listen_dev(
    						input,
    						"mousedown",
    						function () {
    							if (is_function(/*freeze*/ ctx[5])) /*freeze*/ ctx[5].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						input,
    						"mouseup",
    						function () {
    							if (is_function(/*play*/ ctx[8])) /*play*/ ctx[8].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*progress*/ 1 && input_style_value !== (input_style_value = `
          background-image: -webkit-gradient(linear, left top, right top, color-stop(${/*progress*/ ctx[0]}%, rgba(15, 204, 206, 0.4)), color-stop(${/*progress*/ ctx[0]}%, #DAE1E7));
          background-image: -moz-linear-gradient(left center, rgba(15, 204, 206, 0.4) 0%, rgba(15, 204, 206, 0.4) ${/*progress*/ ctx[0]}%, #DAE1E7 ${/*progress*/ ctx[0]}%, #DAE1E7 100%);
        `)) {
    				attr_dev(input, "style", input_style_value);
    			}

    			if (dirty[0] & /*progress*/ 1) {
    				set_input_value(input, /*progress*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(252:34) ",
    		ctx
    	});

    	return block;
    }

    // (243:30) 
    function create_if_block_2$1(ctx) {
    	let div;
    	let svg;
    	let path;
    	let t;
    	let mounted;
    	let dispose;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t = space();
    			attr_dev(path, "d", "M2 3.667A1.67 1.67 0 0 1 3.667 2h16.666A1.67 1.67 0 0 1 22 3.667v16.666A1.67 1.67 0 0 1 20.333\n            22H3.667A1.67 1.67 0 0 1 2 20.333z");
    			add_location(path, file$h, 245, 10, 5264);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 244, 8, 5233);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*isStopped*/ ctx[16]);
    			add_location(div, file$h, 243, 6, 5162);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*stop*/ ctx[11])) /*stop*/ ctx[11].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);

    			if (dirty[0] & /*isStopped*/ 65536) {
    				toggle_class(div, "active", /*isStopped*/ ctx[16]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(243:30) ",
    		ctx
    	});

    	return block;
    }

    // (230:4) {#if item === 'playpause'}
    function create_if_block$2(ctx) {
    	let div;
    	let t;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*isPlaying*/ ctx[18]) return create_if_block_1$2;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			t = space();
    			attr_dev(div, "class", "btn svelte-9yox50");
    			toggle_class(div, "active", /*isPlaying*/ ctx[18] || /*isPaused*/ ctx[17]);
    			add_location(div, file$h, 230, 6, 4611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(
    					div,
    					"click",
    					function () {
    						if (is_function(/*togglePlay*/ ctx[13])) /*togglePlay*/ ctx[13].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t);
    				}
    			}

    			if (dirty[0] & /*isPlaying, isPaused*/ 393216) {
    				toggle_class(div, "active", /*isPlaying*/ ctx[18] || /*isPaused*/ ctx[17]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(230:4) {#if item === 'playpause'}",
    		ctx
    	});

    	return block;
    }

    // (375:10) 
    function create_target_slot_2(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			attr_dev(path0, "fill-rule", "evenodd");
    			attr_dev(path0, "clip-rule", "evenodd");
    			attr_dev(path0, "d", "M3.15 0h17.7A3.12 3.12 0 0124 3.1v17.8c0 1.71-1.4 3.1-3.15 3.1H3.15A3.12 3.12 0 010 20.9V3.1C0 1.39\n                1.4 0 3.15 0zm0 2.05c-.6 0-1.07.47-1.07 1.05v17.8c0 .58.48 1.05 1.07 1.05h17.7c.6 0 1.07-.47\n                1.07-1.05V3.1c0-.58-.48-1.05-1.07-1.05H3.15z");
    			add_location(path0, file$h, 376, 14, 11755);
    			attr_dev(path1, "fill-rule", "evenodd");
    			attr_dev(path1, "clip-rule", "evenodd");
    			attr_dev(path1, "d", "M12 10c.55 0 1 .42 1 .94v6.12c0 .52-.45.94-1 .94s-1-.42-1-.94v-6.12c0-.52.45-.94 1-.94zM12 6a1 1 0\n                011 1v.42a1 1 0 11-2 0V7a1 1 0 011-1z");
    			add_location(path1, file$h, 383, 14, 12160);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 375, 12, 11720);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$h, 374, 10, 11676);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot_2.name,
    		type: "slot",
    		source: "(375:10) ",
    		ctx
    	});

    	return block;
    }

    // (392:10) 
    function create_content_slot_2(ctx) {
    	let div;
    	let info;
    	let current;

    	info = new Info({
    			props: { animationData: /*animationData*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(info.$$.fragment);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-info svelte-9yox50");
    			add_location(div, file$h, 391, 10, 12480);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(info, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const info_changes = {};
    			if (dirty[0] & /*animationData*/ 2) info_changes.animationData = /*animationData*/ ctx[1];
    			info.$set(info_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(info.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(info.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(info);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_2.name,
    		type: "slot",
    		source: "(392:10) ",
    		ctx
    	});

    	return block;
    }

    // (361:8) {:else}
    function create_else_block_1$1(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M21 8a1 1 0 102 0V4a3 3 0 00-3-3h-4a1 1 0 100 2h4a1 1 0 011 1v4zM1 8a1 1 0 102 0V4a1 1 0 011-1h4a1 1 0\n              100-2H4a3 3 0 00-3 3v4zm15 15h4a3 3 0 003-3v-4a1 1 0 10-2 0v4a1 1 0 01-1 1h-4a1 1 0 100 2zM4 23h4a1 1 0\n              100-2H4a1 1 0 01-1-1v-4a1 1 0 10-2 0v4a3 3 0 003 3z");
    			attr_dev(path, "stroke-width", ".2");
    			add_location(path, file$h, 362, 12, 11175);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 361, 10, 11142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(361:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (352:8) {#if isZoomed}
    function create_if_block_8(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M7 22a1 1 0 102 0v-4a3 3 0 00-3-3H2a1 1 0 100 2h4a1 1 0 011 1v4zm8 0a1 1 0 102 0v-4a1 1 0 011-1h4a1 1 0\n              100-2h-4a3 3 0 00-3 3v4zM2 9h4a3 3 0 003-3V2a1 1 0 10-2 0v4a1 1 0 01-1 1H2a1 1 0 100 2zm16 0h4a1 1 0\n              100-2h-4a1 1 0 01-1-1V2a1 1 0 10-2 0v4a3 3 0 003 3z");
    			attr_dev(path, "stroke-width", ".2");
    			add_location(path, file$h, 353, 12, 10737);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 352, 10, 10704);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(352:8) {#if isZoomed}",
    		ctx
    	});

    	return block;
    }

    // (323:10) 
    function create_target_slot_1(ctx) {
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let circle;
    	let path2;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			circle = svg_element("circle");
    			path2 = svg_element("path");
    			attr_dev(path0, "clip-rule", "evenodd");
    			attr_dev(path0, "d", "M0 3.01A2.983 2.983 0 012.983.027H16.99a2.983 2.983 0 012.983 2.983v14.008a2.982 2.982 0 01-2.983\n                2.983H2.983A2.983 2.983 0 010 17.018zm2.983-.941a.941.941 0 00-.942.94v14.01c0\n                .52.422.94.942.94H16.99a.94.94 0 00.941-.94V3.008a.941.941 0 00-.94-.94H2.981z");
    			attr_dev(path0, "fill-rule", "evenodd");
    			add_location(path0, file$h, 324, 14, 9290);
    			attr_dev(path1, "d", "M12.229 7.945l-2.07 4.598-2.586-2.605-2.414 2.758v2.146h9.656V11.93z");
    			add_location(path1, file$h, 331, 14, 9713);
    			attr_dev(circle, "cx", "7.444");
    			attr_dev(circle, "cy", "6.513");
    			attr_dev(circle, "r", "2.032");
    			add_location(circle, file$h, 332, 14, 9814);
    			attr_dev(path2, "d", "M9.561 23.916h11.25a2.929 2.929 0 002.926-2.927V9.954a1.06 1.06 0 10-2.122 0v11.035a.805.805 0\n                01-.803.804H9.562a1.061 1.061 0 100 2.123z");
    			attr_dev(path2, "stroke", "#8795a1");
    			attr_dev(path2, "stroke-width", ".215");
    			add_location(path2, file$h, 333, 14, 9878);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 323, 12, 9255);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$h, 322, 10, 9211);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, circle);
    			append_dev(svg, path2);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot_1.name,
    		type: "slot",
    		source: "(323:10) ",
    		ctx
    	});

    	return block;
    }

    // (342:10) 
    function create_content_slot_1(ctx) {
    	let div;
    	let h5;
    	let t0;
    	let t1;
    	let t2;
    	let a0;
    	let t4;
    	let a1;
    	let t6;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			h5 = element("h5");
    			t0 = text("Frame ");
    			t1 = text(/*formattedFrame*/ ctx[15]);
    			t2 = space();
    			a0 = element("a");
    			a0.textContent = "Download SVG";
    			t4 = space();
    			a1 = element("a");
    			a1.textContent = "Download PNG";
    			t6 = space();
    			i = element("i");
    			i.textContent = "Scroll with mousewheel to find exact frame";
    			attr_dev(h5, "class", "svelte-9yox50");
    			add_location(h5, file$h, 342, 12, 10262);
    			attr_dev(a0, "href", "#downloadsvg");
    			attr_dev(a0, "class", "svelte-9yox50");
    			add_location(a0, file$h, 343, 12, 10306);
    			attr_dev(a1, "href", "#downloadsvg");
    			attr_dev(a1, "class", "svelte-9yox50");
    			add_location(a1, file$h, 344, 12, 10392);
    			attr_dev(i, "class", "note svelte-9yox50");
    			add_location(i, file$h, 345, 12, 10478);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-snapshot svelte-9yox50");
    			add_location(div, file$h, 341, 10, 10196);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h5);
    			append_dev(h5, t0);
    			append_dev(h5, t1);
    			append_dev(div, t2);
    			append_dev(div, a0);
    			append_dev(div, t4);
    			append_dev(div, a1);
    			append_dev(div, t6);
    			append_dev(div, i);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[29], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[30], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*formattedFrame*/ 32768) set_data_dev(t1, /*formattedFrame*/ ctx[15]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot_1.name,
    		type: "slot",
    		source: "(342:10) ",
    		ctx
    	});

    	return block;
    }

    // (300:10) 
    function create_target_slot(ctx) {
    	let div;
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M12 3.1L6.1 8.6a7.6 7.6 0 00-2.2 4 7.2 7.2 0 00.4 4.4 7.9 7.9 0 003 3.5 8.7 8.7 0 004.7 1.3c1.6 0\n                3.2-.5 4.6-1.3s2.4-2 3-3.5a7.2 7.2 0 00.5-4.5 7.6 7.6 0 00-2.2-4L12 3.2zM12 0l7.5 7a9.8 9.8 0 013 5.1\n                9.3 9.3 0 01-.6 5.8c-.9 1.8-2.2 3.3-4 4.4A11.2 11.2 0 0112 24a11.2 11.2 0\n                01-6-1.7c-1.7-1-3-2.6-3.9-4.4a9.3 9.3 0 01-.6-5.8c.4-2 1.5-3.7 3-5L12 0zM6 14h12c0 1.5-.7 3-1.8 4s-2.6\n                1.6-4.2 1.6S9 19 7.8 18s-1.7-2.5-1.7-4z");
    			add_location(path, file$h, 301, 14, 8121);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 300, 12, 8086);
    			attr_dev(div, "class", "btn svelte-9yox50");
    			attr_dev(div, "slot", "target");
    			add_location(div, file$h, 299, 10, 8042);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_target_slot.name,
    		type: "slot",
    		source: "(300:10) ",
    		ctx
    	});

    	return block;
    }

    // (311:10) 
    function create_content_slot(ctx) {
    	let div;
    	let colorpicker;
    	let current;

    	colorpicker = new ColorPicker({
    			props: { color: /*background*/ ctx[2] },
    			$$inline: true
    		});

    	colorpicker.$on("color", /*onSelectBackground*/ ctx[21]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(colorpicker.$$.fragment);
    			attr_dev(div, "slot", "content");
    			attr_dev(div, "class", "popover popover-background svelte-9yox50");
    			add_location(div, file$h, 310, 10, 8697);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(colorpicker, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const colorpicker_changes = {};
    			if (dirty[0] & /*background*/ 4) colorpicker_changes.color = /*background*/ ctx[2];
    			colorpicker.$set(colorpicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(colorpicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(colorpicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(colorpicker);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_content_slot.name,
    		type: "slot",
    		source: "(311:10) ",
    		ctx
    	});

    	return block;
    }

    // (237:8) {:else}
    function create_else_block$1(ctx) {
    	let svg;
    	let path;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M2 3.4C2 1.9 3.5 1 4.8 1.8l16.5 9.6c1.2.7 1.2 2.5 0 3.2L4.8 24.2C3.5 25 2 24.1 2 22.6V3.4z");
    			add_location(path, file$h, 238, 12, 4972);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 237, 10, 4939);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(237:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (232:8) {#if isPlaying}
    function create_if_block_1$2(ctx) {
    	let svg;
    	let rect0;
    	let rect1;
    	let svg_levels = [/*ICON_SIZE*/ ctx[19]];
    	let svg_data = {};

    	for (let i = 0; i < svg_levels.length; i += 1) {
    		svg_data = assign(svg_data, svg_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect0 = svg_element("rect");
    			rect1 = svg_element("rect");
    			attr_dev(rect0, "height", "22.9");
    			attr_dev(rect0, "rx", "1.9");
    			attr_dev(rect0, "width", "7.6");
    			attr_dev(rect0, "x", "14");
    			attr_dev(rect0, "y", ".5");
    			add_location(rect0, file$h, 233, 12, 4759);
    			attr_dev(rect1, "height", "22.9");
    			attr_dev(rect1, "rx", "1.9");
    			attr_dev(rect1, "width", "7.6");
    			attr_dev(rect1, "x", "2");
    			attr_dev(rect1, "y", ".5");
    			add_location(rect1, file$h, 234, 12, 4834);
    			set_svg_attributes(svg, svg_data);
    			toggle_class(svg, "svelte-9yox50", true);
    			add_location(svg, file$h, 232, 10, 4726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect0);
    			append_dev(svg, rect1);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(svg, svg_data = get_spread_update(svg_levels, [/*ICON_SIZE*/ ctx[19]]));
    			toggle_class(svg, "svelte-9yox50", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(232:8) {#if isPlaying}",
    		ctx
    	});

    	return block;
    }

    // (229:2) {#each layout as item}
    function create_each_block$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block$2,
    		create_if_block_2$1,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5,
    		create_if_block_6,
    		create_if_block_7,
    		create_if_block_9,
    		create_if_block_10,
    		create_if_block_11,
    		create_if_block_12,
    		create_if_block_13
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[40] === 'playpause') return 0;
    		if (/*item*/ ctx[40] === 'stop') return 1;
    		if (/*item*/ ctx[40] === 'progress') return 2;
    		if (/*item*/ ctx[40] === 'loop') return 3;
    		if (/*item*/ ctx[40] === 'background') return 4;
    		if (/*item*/ ctx[40] === 'snapshot') return 5;
    		if (/*item*/ ctx[40] === 'zoom') return 6;
    		if (/*item*/ ctx[40] === 'info') return 7;
    		if (/*item*/ ctx[40] === 'frame') return 8;
    		if (/*item*/ ctx[40] === 'nextFrame') return 9;
    		if (/*item*/ ctx[40] === 'previousFrame') return 10;
    		if (/*item*/ ctx[40] === 'spacer') return 11;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(229:2) {#each layout as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div;
    	let current;
    	let each_value = /*layout*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "lottie-player-controls svelte-9yox50");
    			add_location(div, file$h, 227, 0, 4512);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*isPlaying, isPaused, togglePlay, ICON_SIZE, layout, isStopped, stop, progress, onHandleSeekChange, freeze, play, loop, toggleLooping, background, onSelectBackground, currentState, seek, frame, snapshot, formattedFrame, onToggleZoom, isZoomed, animationData, onNextFrame, oPreviousFrame*/ 33554431) {
    				each_value = /*layout*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1$1($$self, $$props, $$invalidate) {
    	let isPlaying;
    	let isPaused;
    	let isStopped;
    	let formattedFrame;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Controls', slots, []);

    	const ICON_SIZE = {
    		width: 14,
    		height: 14,
    		viewBox: '0 0 24 24'
    	};

    	// Create event dispatcher
    	const dispatch = createEventDispatcher();

    	let { animationData } = $$props;
    	let { background } = $$props;
    	let { currentState } = $$props;
    	let { frame } = $$props;
    	let { freeze } = $$props;
    	let { instance } = $$props;
    	let { layout = ControlsLayoutOptions } = $$props;
    	let { loop } = $$props;
    	let { play } = $$props;
    	let { progress } = $$props;
    	let { seek } = $$props;
    	let { snapshot } = $$props;
    	let { stop } = $$props;
    	let { toggleZoom } = $$props;
    	let { toggleLooping } = $$props;
    	let { togglePlay } = $$props;
    	let { totalFrames = 0 } = $$props;
    	let isZoomed = false;

    	const onHandleSeekChange = e => {
    		if (!instance || isNaN(e.target.value)) {
    			return;
    		}

    		const frame = e.target.value / 100 * totalFrames;
    		seek(frame);
    	};

    	const onSelectBackground = e => {
    		dispatch('background', { color: e.detail.hex });
    	};

    	const onToggleZoom = () => {
    		$$invalidate(14, isZoomed = !isZoomed);
    		toggleZoom();
    	};

    	const onNextFrame = () => {
    		const nextFrame = frame + 1;

    		if (nextFrame <= totalFrames) {
    			seek(nextFrame);
    		}
    	};

    	const oPreviousFrame = () => {
    		const prevFrame = frame - 1;

    		if (prevFrame >= 0) {
    			seek(prevFrame);
    		}
    	};

    	const writable_props = [
    		'animationData',
    		'background',
    		'currentState',
    		'frame',
    		'freeze',
    		'instance',
    		'layout',
    		'loop',
    		'play',
    		'progress',
    		'seek',
    		'snapshot',
    		'stop',
    		'toggleZoom',
    		'toggleLooping',
    		'togglePlay',
    		'totalFrames'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Controls> was created with unknown prop '${key}'`);
    	});

    	function input_change_input_handler() {
    		progress = to_number(this.value);
    		$$invalidate(0, progress);
    	}

    	const click_handler = () => snapshot(true);
    	const click_handler_1 = () => snapshot(true);
    	const mousewheel_handler = e => seek(frame + (e.deltaY > 0 ? -1 : 1));
    	const mouseout_handler = () => currentState === PlayerState.Frozen && play();
    	const mouseover_handler = () => currentState !== PlayerState.Paused && freeze();

    	function input_input_handler() {
    		formattedFrame = this.value;
    		($$invalidate(15, formattedFrame), $$invalidate(4, frame));
    	}

    	const mouseout_handler_1 = () => currentState === PlayerState.Frozen && play();
    	const mouseover_handler_1 = () => currentState !== PlayerState.Paused && freeze();
    	const input_handler = e => seek(e.target.value);
    	const mousewheel_handler_1 = e => seek(frame + (e.deltaY > 0 ? -1 : 1));

    	$$self.$$set = $$props => {
    		if ('animationData' in $$props) $$invalidate(1, animationData = $$props.animationData);
    		if ('background' in $$props) $$invalidate(2, background = $$props.background);
    		if ('currentState' in $$props) $$invalidate(3, currentState = $$props.currentState);
    		if ('frame' in $$props) $$invalidate(4, frame = $$props.frame);
    		if ('freeze' in $$props) $$invalidate(5, freeze = $$props.freeze);
    		if ('instance' in $$props) $$invalidate(25, instance = $$props.instance);
    		if ('layout' in $$props) $$invalidate(6, layout = $$props.layout);
    		if ('loop' in $$props) $$invalidate(7, loop = $$props.loop);
    		if ('play' in $$props) $$invalidate(8, play = $$props.play);
    		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
    		if ('seek' in $$props) $$invalidate(9, seek = $$props.seek);
    		if ('snapshot' in $$props) $$invalidate(10, snapshot = $$props.snapshot);
    		if ('stop' in $$props) $$invalidate(11, stop = $$props.stop);
    		if ('toggleZoom' in $$props) $$invalidate(26, toggleZoom = $$props.toggleZoom);
    		if ('toggleLooping' in $$props) $$invalidate(12, toggleLooping = $$props.toggleLooping);
    		if ('togglePlay' in $$props) $$invalidate(13, togglePlay = $$props.togglePlay);
    		if ('totalFrames' in $$props) $$invalidate(27, totalFrames = $$props.totalFrames);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		ColorPicker,
    		Info,
    		Popover,
    		ControlsLayoutOptions,
    		PlayerState,
    		ICON_SIZE,
    		dispatch,
    		animationData,
    		background,
    		currentState,
    		frame,
    		freeze,
    		instance,
    		layout,
    		loop,
    		play,
    		progress,
    		seek,
    		snapshot,
    		stop,
    		toggleZoom,
    		toggleLooping,
    		togglePlay,
    		totalFrames,
    		isZoomed,
    		onHandleSeekChange,
    		onSelectBackground,
    		onToggleZoom,
    		onNextFrame,
    		oPreviousFrame,
    		formattedFrame,
    		isStopped,
    		isPaused,
    		isPlaying
    	});

    	$$self.$inject_state = $$props => {
    		if ('animationData' in $$props) $$invalidate(1, animationData = $$props.animationData);
    		if ('background' in $$props) $$invalidate(2, background = $$props.background);
    		if ('currentState' in $$props) $$invalidate(3, currentState = $$props.currentState);
    		if ('frame' in $$props) $$invalidate(4, frame = $$props.frame);
    		if ('freeze' in $$props) $$invalidate(5, freeze = $$props.freeze);
    		if ('instance' in $$props) $$invalidate(25, instance = $$props.instance);
    		if ('layout' in $$props) $$invalidate(6, layout = $$props.layout);
    		if ('loop' in $$props) $$invalidate(7, loop = $$props.loop);
    		if ('play' in $$props) $$invalidate(8, play = $$props.play);
    		if ('progress' in $$props) $$invalidate(0, progress = $$props.progress);
    		if ('seek' in $$props) $$invalidate(9, seek = $$props.seek);
    		if ('snapshot' in $$props) $$invalidate(10, snapshot = $$props.snapshot);
    		if ('stop' in $$props) $$invalidate(11, stop = $$props.stop);
    		if ('toggleZoom' in $$props) $$invalidate(26, toggleZoom = $$props.toggleZoom);
    		if ('toggleLooping' in $$props) $$invalidate(12, toggleLooping = $$props.toggleLooping);
    		if ('togglePlay' in $$props) $$invalidate(13, togglePlay = $$props.togglePlay);
    		if ('totalFrames' in $$props) $$invalidate(27, totalFrames = $$props.totalFrames);
    		if ('isZoomed' in $$props) $$invalidate(14, isZoomed = $$props.isZoomed);
    		if ('formattedFrame' in $$props) $$invalidate(15, formattedFrame = $$props.formattedFrame);
    		if ('isStopped' in $$props) $$invalidate(16, isStopped = $$props.isStopped);
    		if ('isPaused' in $$props) $$invalidate(17, isPaused = $$props.isPaused);
    		if ('isPlaying' in $$props) $$invalidate(18, isPlaying = $$props.isPlaying);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(18, isPlaying = currentState === PlayerState.Playing);
    		}

    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(17, isPaused = currentState === PlayerState.Paused);
    		}

    		if ($$self.$$.dirty[0] & /*currentState*/ 8) {
    			$$invalidate(16, isStopped = currentState === PlayerState.Stopped);
    		}

    		if ($$self.$$.dirty[0] & /*frame*/ 16) {
    			$$invalidate(15, formattedFrame = Math.round(frame));
    		}
    	};

    	return [
    		progress,
    		animationData,
    		background,
    		currentState,
    		frame,
    		freeze,
    		layout,
    		loop,
    		play,
    		seek,
    		snapshot,
    		stop,
    		toggleLooping,
    		togglePlay,
    		isZoomed,
    		formattedFrame,
    		isStopped,
    		isPaused,
    		isPlaying,
    		ICON_SIZE,
    		onHandleSeekChange,
    		onSelectBackground,
    		onToggleZoom,
    		onNextFrame,
    		oPreviousFrame,
    		instance,
    		toggleZoom,
    		totalFrames,
    		input_change_input_handler,
    		click_handler,
    		click_handler_1,
    		mousewheel_handler,
    		mouseout_handler,
    		mouseover_handler,
    		input_input_handler,
    		mouseout_handler_1,
    		mouseover_handler_1,
    		input_handler,
    		mousewheel_handler_1
    	];
    }

    class Controls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1$1,
    			create_fragment$h,
    			safe_not_equal,
    			{
    				animationData: 1,
    				background: 2,
    				currentState: 3,
    				frame: 4,
    				freeze: 5,
    				instance: 25,
    				layout: 6,
    				loop: 7,
    				play: 8,
    				progress: 0,
    				seek: 9,
    				snapshot: 10,
    				stop: 11,
    				toggleZoom: 26,
    				toggleLooping: 12,
    				togglePlay: 13,
    				totalFrames: 27
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Controls",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*animationData*/ ctx[1] === undefined && !('animationData' in props)) {
    			console.warn("<Controls> was created without expected prop 'animationData'");
    		}

    		if (/*background*/ ctx[2] === undefined && !('background' in props)) {
    			console.warn("<Controls> was created without expected prop 'background'");
    		}

    		if (/*currentState*/ ctx[3] === undefined && !('currentState' in props)) {
    			console.warn("<Controls> was created without expected prop 'currentState'");
    		}

    		if (/*frame*/ ctx[4] === undefined && !('frame' in props)) {
    			console.warn("<Controls> was created without expected prop 'frame'");
    		}

    		if (/*freeze*/ ctx[5] === undefined && !('freeze' in props)) {
    			console.warn("<Controls> was created without expected prop 'freeze'");
    		}

    		if (/*instance*/ ctx[25] === undefined && !('instance' in props)) {
    			console.warn("<Controls> was created without expected prop 'instance'");
    		}

    		if (/*loop*/ ctx[7] === undefined && !('loop' in props)) {
    			console.warn("<Controls> was created without expected prop 'loop'");
    		}

    		if (/*play*/ ctx[8] === undefined && !('play' in props)) {
    			console.warn("<Controls> was created without expected prop 'play'");
    		}

    		if (/*progress*/ ctx[0] === undefined && !('progress' in props)) {
    			console.warn("<Controls> was created without expected prop 'progress'");
    		}

    		if (/*seek*/ ctx[9] === undefined && !('seek' in props)) {
    			console.warn("<Controls> was created without expected prop 'seek'");
    		}

    		if (/*snapshot*/ ctx[10] === undefined && !('snapshot' in props)) {
    			console.warn("<Controls> was created without expected prop 'snapshot'");
    		}

    		if (/*stop*/ ctx[11] === undefined && !('stop' in props)) {
    			console.warn("<Controls> was created without expected prop 'stop'");
    		}

    		if (/*toggleZoom*/ ctx[26] === undefined && !('toggleZoom' in props)) {
    			console.warn("<Controls> was created without expected prop 'toggleZoom'");
    		}

    		if (/*toggleLooping*/ ctx[12] === undefined && !('toggleLooping' in props)) {
    			console.warn("<Controls> was created without expected prop 'toggleLooping'");
    		}

    		if (/*togglePlay*/ ctx[13] === undefined && !('togglePlay' in props)) {
    			console.warn("<Controls> was created without expected prop 'togglePlay'");
    		}
    	}

    	get animationData() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set animationData(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get currentState() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set currentState(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get frame() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set frame(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get freeze() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set freeze(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get instance() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set instance(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get layout() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set layout(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get play() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set play(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get progress() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set progress(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seek() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set seek(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get snapshot() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set snapshot(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stop() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stop(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleZoom() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleZoom(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleLooping() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set toggleLooping(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get togglePlay() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set togglePlay(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get totalFrames() {
    		throw new Error("<Controls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set totalFrames(value) {
    		throw new Error("<Controls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/@lottiefiles/svelte-lottie-player/src/components/LottiePlayer.svelte generated by Svelte v3.44.2 */

    const file$g = "node_modules/@lottiefiles/svelte-lottie-player/src/components/LottiePlayer.svelte";

    // (559:6) {#if currentState === PlayerState.Error}
    function create_if_block_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "";
    			attr_dev(div, "class", "lottie-player-error svelte-1aiskgp");
    			add_location(div, file$g, 559, 8, 12693);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(559:6) {#if currentState === PlayerState.Error}",
    		ctx
    	});

    	return block;
    }

    // (563:4) {#if controls}
    function create_if_block$1(ctx) {
    	let controls_1;
    	let current;

    	controls_1 = new Controls({
    			props: {
    				layout: /*controlsLayout*/ ctx[3],
    				animationData: /*animationData*/ ctx[22],
    				background: /*background*/ ctx[1],
    				controls: /*controls*/ ctx[2],
    				currentState: /*currentState*/ ctx[28],
    				frame: /*frame*/ ctx[26],
    				freeze: /*freeze*/ ctx[11],
    				instance: /*instance*/ ctx[21],
    				loop: /*loop*/ ctx[0],
    				lottie: lottie$1,
    				pause: /*pause*/ ctx[9],
    				play: /*play*/ ctx[8],
    				progress: /*progress*/ ctx[27],
    				seek: /*seek*/ ctx[12],
    				setDirection: /*setDirection*/ ctx[16],
    				setSpeed: /*setSpeed*/ ctx[15],
    				setLooping: /*setLooping*/ ctx[14],
    				snapshot: /*snapshot*/ ctx[13],
    				src: /*src*/ ctx[5],
    				stop: /*stop*/ ctx[10],
    				toggleZoom: /*toggleZoom*/ ctx[20],
    				toggleLooping: /*toggleLooping*/ ctx[18],
    				togglePlay: /*togglePlay*/ ctx[17],
    				totalFrames: /*totalFrames*/ ctx[32]
    			},
    			$$inline: true
    		});

    	controls_1.$on("background", /*background_handler*/ ctx[46]);

    	const block = {
    		c: function create() {
    			create_component(controls_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(controls_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const controls_1_changes = {};
    			if (dirty[0] & /*controlsLayout*/ 8) controls_1_changes.layout = /*controlsLayout*/ ctx[3];
    			if (dirty[0] & /*animationData*/ 4194304) controls_1_changes.animationData = /*animationData*/ ctx[22];
    			if (dirty[0] & /*background*/ 2) controls_1_changes.background = /*background*/ ctx[1];
    			if (dirty[0] & /*controls*/ 4) controls_1_changes.controls = /*controls*/ ctx[2];
    			if (dirty[0] & /*currentState*/ 268435456) controls_1_changes.currentState = /*currentState*/ ctx[28];
    			if (dirty[0] & /*frame*/ 67108864) controls_1_changes.frame = /*frame*/ ctx[26];
    			if (dirty[0] & /*instance*/ 2097152) controls_1_changes.instance = /*instance*/ ctx[21];
    			if (dirty[0] & /*loop*/ 1) controls_1_changes.loop = /*loop*/ ctx[0];
    			if (dirty[0] & /*progress*/ 134217728) controls_1_changes.progress = /*progress*/ ctx[27];
    			if (dirty[0] & /*src*/ 32) controls_1_changes.src = /*src*/ ctx[5];
    			if (dirty[1] & /*totalFrames*/ 2) controls_1_changes.totalFrames = /*totalFrames*/ ctx[32];
    			controls_1.$set(controls_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controls_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controls_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(controls_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(563:4) {#if controls}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t;
    	let div2_style_value;
    	let div2_resize_listener;
    	let current;
    	let if_block0 = /*currentState*/ ctx[28] === PlayerState.Error && create_if_block_1$1(ctx);
    	let if_block1 = /*controls*/ ctx[2] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			set_style(div0, "background", /*background*/ ctx[1]);
    			attr_dev(div0, "class", "svelte-1aiskgp");
    			toggle_class(div0, "animation", true);
    			add_location(div0, file$g, 554, 4, 12533);
    			attr_dev(div1, "class", "lottie-player svelte-1aiskgp");
    			toggle_class(div1, "with-controls", /*controls*/ ctx[2]);
    			toggle_class(div1, "is-zoomed", /*isZoomed*/ ctx[29]);
    			add_location(div1, file$g, 549, 2, 12405);

    			attr_dev(div2, "style", div2_style_value = "" + ((/*width*/ ctx[7] ? `width:${/*width*/ ctx[7]}px;` : '') + (/*height*/ ctx[4]
    			? `height:${/*height*/ ctx[4]}px;`
    			: '') + /*style*/ ctx[6]));

    			add_render_callback(() => /*div2_elementresize_handler*/ ctx[49].call(div2));
    			add_location(div2, file$g, 544, 0, 12215);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			/*div0_binding*/ ctx[45](div0);
    			append_dev(div1, t);
    			if (if_block1) if_block1.m(div1, null);
    			/*div1_binding*/ ctx[47](div1);
    			/*div2_binding*/ ctx[48](div2);
    			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[49].bind(div2));
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*currentState*/ ctx[28] === PlayerState.Error) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty[0] & /*background*/ 2) {
    				set_style(div0, "background", /*background*/ ctx[1]);
    			}

    			if (/*controls*/ ctx[2]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*controls*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*controls*/ 4) {
    				toggle_class(div1, "with-controls", /*controls*/ ctx[2]);
    			}

    			if (dirty[0] & /*isZoomed*/ 536870912) {
    				toggle_class(div1, "is-zoomed", /*isZoomed*/ ctx[29]);
    			}

    			if (!current || dirty[0] & /*width, height, style*/ 208 && div2_style_value !== (div2_style_value = "" + ((/*width*/ ctx[7] ? `width:${/*width*/ ctx[7]}px;` : '') + (/*height*/ ctx[4]
    			? `height:${/*height*/ ctx[4]}px;`
    			: '') + /*style*/ ctx[6]))) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			/*div0_binding*/ ctx[45](null);
    			if (if_block1) if_block1.d();
    			/*div1_binding*/ ctx[47](null);
    			/*div2_binding*/ ctx[48](null);
    			div2_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance_1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('LottiePlayer', slots, []);
    	let { autoplay = false } = $$props;
    	let { background } = $$props;
    	let { controls } = $$props;
    	let { controlsLayout } = $$props;
    	let { count = undefined } = $$props;
    	let { defaultFrame = 0 } = $$props;
    	let { direction = 1 } = $$props;
    	let { height } = $$props;
    	let { hover = false } = $$props;
    	let { loop = false } = $$props;
    	let { mode = PlayMode.Normal } = $$props;
    	let { onToggleZoom = undefined } = $$props;
    	let { renderer = PlayerRender.SVG } = $$props;
    	let { speed = 1 } = $$props;
    	let { src = "" } = $$props;
    	let { style = "" } = $$props;
    	let { width } = $$props;
    	let animationData;
    	let animationRef;
    	let playerRef;
    	let wrapperRef;
    	let instance;
    	let frame = 0;
    	let progress = 0;
    	let io;
    	let currentState = PlayerState.Loading;
    	let isZoomed = false;
    	let playerHeight;
    	let playerWidth;
    	let totalFrames;

    	/**
     * Handle visibility change events.
     */
    	const onVisibilityChange = () => {
    		if (document.hidden === true && currentState === PlayerState.Playing) {
    			freeze();
    		} else if (currentState === PlayerState.Frozen) {
    			play();
    		}
    	};

    	/**
     * Initialize everything on component mount.
     */
    	onMount(() => {
    		if ("IntersectionObserver" in window) {
    			io = new IntersectionObserver(entries => {
    					if (entries[0].isIntersecting) {
    						if (currentState === PlayerState.Frozen) {
    							play();
    						}
    					} else if (currentState === PlayerState.Playing) {
    						freeze();
    					}
    				});

    			io.observe(animationRef);
    		}

    		// Add listener for Visibility API's change event.
    		if (typeof document.hidden !== "undefined") {
    			document.addEventListener("visibilitychange", onVisibilityChange);
    		}

    		// Setup lottie player
    		if (src) {
    			load(src);
    		}
    	});

    	/**
     * Cleanup on component destroy.
     */
    	onDestroy(() => {
    		// Remove intersection observer for detecting component being out-of-view.
    		if (io) {
    			io.disconnect();
    			io = undefined;
    		}

    		// Remove the attached Visibility API's change event listener.
    		document.removeEventListener("visibilitychange", onVisibilityChange);
    	});

    	const load = srcValue => {
    		if (!animationRef) {
    			return;
    		}

    		// Clear previous animation, if any
    		if (instance) {
    			instance.destroy();
    		}

    		const options = {
    			container: animationRef,
    			loop,
    			autoplay,
    			renderer,
    			rendererSettings: {
    				preserveAspectRatio: "xMidYMid meet",
    				clearCanvas: true,
    				progressiveLoad: true,
    				hideOnTransparent: true
    			}
    		};

    		// Load the resource information
    		try {
    			const srcParsed = parseSrc(srcValue);
    			const srcAttrib = typeof srcParsed === "string" ? "path" : "animationData";

    			// Initialize lottie player and load animation
    			$$invalidate(21, instance = lottie$1.loadAnimation({ ...options, [srcAttrib]: srcParsed }));
    		} catch(err) {
    			$$invalidate(28, currentState = PlayerState.Error);
    			dispatchEvent(new CustomEvent(PlayerEvents.Error));
    		}

    		if (instance) {
    			// Calculate and save the current progress of the animation
    			instance.addEventListener("enterFrame", () => {
    				$$invalidate(26, frame = instance.currentFrame);
    				$$invalidate(27, progress = instance.currentFrame / instance.totalFrames * 100);

    				dispatchEvent(new CustomEvent(PlayerEvents.Frame,
    				{
    						detail: { frame: instance.currentFrame, progress }
    					}));
    			});

    			instance.addEventListener("complete", () => {
    				if (currentState !== PlayerState.Playing) {
    					dispatchEvent(new CustomEvent(PlayerEvents.Complete));
    					return;
    				}

    				if (!loop || count && _counter >= count) {
    					dispatchEvent(new CustomEvent(PlayerEvents.Complete));
    					return;
    				}

    				if (mode === PlayMode.Bounce) {
    					if (count) {
    						_counter += 0.5;
    					}

    					setTimeout(
    						() => {
    							dispatchEvent(new CustomEvent(PlayerEvents.Loop));

    							if (currentState === PlayerState.Playing) {
    								instance.setDirection(instance.playDirection * -1);
    								instance.play();
    							}
    						},
    						intermission
    					);
    				} else {
    					if (count) {
    						_counter += 1;
    					}

    					window.setTimeout(
    						() => {
    							dispatchEvent(new CustomEvent(PlayerEvents.Loop));

    							if (currentState === PlayerState.Playing) {
    								instance.stop();
    								instance.play();
    							}
    						},
    						intermission
    					);
    				}
    			});

    			// Handle animation data load complete
    			instance.addEventListener("data_ready", () => {
    				$$invalidate(22, animationData = instance.animationData);
    				$$invalidate(32, totalFrames = instance.totalFrames);
    			});

    			// Set error state when animation load fail event triggers
    			instance.addEventListener("data_failed", () => {
    				$$invalidate(28, currentState = PlayerState.Error);
    				dispatchEvent(new CustomEvent(PlayerEvents.Error));
    			});

    			// Set handlers to auto play animation on hover if enabled
    			animationRef.addEventListener("mouseenter", () => {
    				if (hover && currentState !== PlayerState.Playing) {
    					play();
    				}
    			});

    			animationRef.addEventListener("mouseleave", () => {
    				if (hover && currentState === PlayerState.Playing) {
    					stop();
    				}
    			});

    			// Set initial playback speed and direction
    			setSpeed(speed);

    			setDirection(direction);

    			// Start playing if autoplay is enabled
    			if (autoplay) {
    				play();
    			} else if (!isNaN(defaultFrame)) {
    				instance.goToAndStop(defaultFrame, true);
    			}
    		}
    	};

    	const getLottie = () => {
    		return instance;
    	};

    	const play = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Playing);
    		instance.play();
    		dispatchEvent(new CustomEvent(PlayerEvents.Play));
    	};

    	const pause = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Paused);
    		instance.pause();
    		dispatchEvent(new CustomEvent(PlayerEvents.Pause));
    	};

    	const stop = () => {
    		if (!instance) {
    			return;
    		}

    		$$invalidate(28, currentState = PlayerState.Stopped);
    		instance.stop();
    		dispatchEvent(new CustomEvent(PlayerEvents.Stop));
    	};

    	const freeze = () => {
    		if (!instance) {
    			return;
    		}

    		instance.pause();
    		$$invalidate(28, currentState = PlayerState.Frozen);
    		dispatchEvent(new CustomEvent(PlayerEvents.Freeze));
    	};

    	const resize = () => {
    		if (!instance) {
    			return;
    		}

    		instance.resize();
    	};

    	const seek = value => {
    		if (!instance) {
    			return;
    		}

    		// Extract frame number from either number or percentage value
    		const matches = value.toString().match(/^([0-9\.]+)(%?)$/);

    		if (!matches) {
    			return;
    		}

    		// Calculate and set the frame number
    		const resolvedFrame = matches[2] === "%"
    		? instance.totalFrames * Number(matches[1]) / 100
    		: Number(matches[1]);

    		// Send lottie player to the new frame
    		if (currentState === PlayerState.Playing) {
    			instance.goToAndPlay(resolvedFrame, true);
    		} else {
    			instance.goToAndStop(resolvedFrame, true);
    			instance.pause();
    		}
    	};

    	const snapshot = (download = true) => {
    		let data;

    		if (renderer === PlayerRender.SVG) {
    			// Get SVG element and serialize markup
    			const svgElement = animationRef.querySelector("svg");

    			const serializedSvg = new XMLSerializer().serializeToString(svgElement);
    			data = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(serializedSvg);

    			// Trigger file download if needed
    			if (download) {
    				triggerDownload(data, `snapshot_${progress}.svg`);
    			}
    		} else if (renderer === PlayerRender.Canvas) {
    			const canvas = animationRef.querySelector("canvas");
    			data = canvas.toDataURL("image/png");

    			// Trigger file download if needed
    			if (download) {
    				triggerDownload(data, `snapshot_${progress}.png`);
    			}
    		}

    		return data;
    	};

    	const setLooping = value => {
    		if (instance) {
    			$$invalidate(0, loop = value);
    		}
    	};

    	const setSpeed = value => {
    		if (instance) {
    			$$invalidate(34, speed = value);
    		}
    	};

    	const setDirection = value => {
    		if (instance) {
    			$$invalidate(33, direction = value);
    		}
    	};

    	const togglePlay = () => {
    		return currentState === PlayerState.Playing ? pause() : play();
    	};

    	const toggleLooping = () => {
    		setLooping(!loop);
    	};

    	const setBackground = value => {
    		$$invalidate(1, background = value);
    	};

    	const toggleZoom = () => {
    		// Check if custom handler for zoom toggle is set
    		if (typeof onToggleZoom === "function") {
    			// Call the custom zoom toggle handler with current zoom status
    			// Set return value as the zoom status
    			$$invalidate(29, isZoomed = Boolean(onToggleZoom(isZoomed)));

    			return;
    		}

    		if (!isZoomed) {
    			$$invalidate(25, wrapperRef.style.height = playerHeight + "px", wrapperRef);
    			$$invalidate(25, wrapperRef.style.width = playerWidth + "px", wrapperRef);
    			document.body.appendChild(playerRef);
    		} else {
    			wrapperRef.appendChild(playerRef);
    			$$invalidate(25, wrapperRef.style.height = undefined, wrapperRef);
    			$$invalidate(25, wrapperRef.style.width = undefined, wrapperRef);
    		}

    		$$invalidate(29, isZoomed = !isZoomed);
    		setTimeout(() => resize(), 100);
    	};

    	const writable_props = [
    		'autoplay',
    		'background',
    		'controls',
    		'controlsLayout',
    		'count',
    		'defaultFrame',
    		'direction',
    		'height',
    		'hover',
    		'loop',
    		'mode',
    		'onToggleZoom',
    		'renderer',
    		'speed',
    		'src',
    		'style',
    		'width'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LottiePlayer> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			animationRef = $$value;
    			$$invalidate(23, animationRef);
    		});
    	}

    	const background_handler = e => setBackground(e.detail.color);

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playerRef = $$value;
    			$$invalidate(24, playerRef);
    		});
    	}

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			wrapperRef = $$value;
    			$$invalidate(25, wrapperRef);
    		});
    	}

    	function div2_elementresize_handler() {
    		playerHeight = this.clientHeight;
    		playerWidth = this.clientWidth;
    		$$invalidate(30, playerHeight);
    		$$invalidate(31, playerWidth);
    	}

    	$$self.$$set = $$props => {
    		if ('autoplay' in $$props) $$invalidate(35, autoplay = $$props.autoplay);
    		if ('background' in $$props) $$invalidate(1, background = $$props.background);
    		if ('controls' in $$props) $$invalidate(2, controls = $$props.controls);
    		if ('controlsLayout' in $$props) $$invalidate(3, controlsLayout = $$props.controlsLayout);
    		if ('count' in $$props) $$invalidate(36, count = $$props.count);
    		if ('defaultFrame' in $$props) $$invalidate(37, defaultFrame = $$props.defaultFrame);
    		if ('direction' in $$props) $$invalidate(33, direction = $$props.direction);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('hover' in $$props) $$invalidate(38, hover = $$props.hover);
    		if ('loop' in $$props) $$invalidate(0, loop = $$props.loop);
    		if ('mode' in $$props) $$invalidate(39, mode = $$props.mode);
    		if ('onToggleZoom' in $$props) $$invalidate(40, onToggleZoom = $$props.onToggleZoom);
    		if ('renderer' in $$props) $$invalidate(41, renderer = $$props.renderer);
    		if ('speed' in $$props) $$invalidate(34, speed = $$props.speed);
    		if ('src' in $$props) $$invalidate(5, src = $$props.src);
    		if ('style' in $$props) $$invalidate(6, style = $$props.style);
    		if ('width' in $$props) $$invalidate(7, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		onMount,
    		lottie: lottie$1,
    		Controls,
    		PlayerEvents,
    		PlayerRender,
    		PlayerState,
    		PlayMode,
    		parseSrc,
    		triggerDownload,
    		autoplay,
    		background,
    		controls,
    		controlsLayout,
    		count,
    		defaultFrame,
    		direction,
    		height,
    		hover,
    		loop,
    		mode,
    		onToggleZoom,
    		renderer,
    		speed,
    		src,
    		style,
    		width,
    		animationData,
    		animationRef,
    		playerRef,
    		wrapperRef,
    		instance,
    		frame,
    		progress,
    		io,
    		currentState,
    		isZoomed,
    		playerHeight,
    		playerWidth,
    		totalFrames,
    		onVisibilityChange,
    		load,
    		getLottie,
    		play,
    		pause,
    		stop,
    		freeze,
    		resize,
    		seek,
    		snapshot,
    		setLooping,
    		setSpeed,
    		setDirection,
    		togglePlay,
    		toggleLooping,
    		setBackground,
    		toggleZoom
    	});

    	$$self.$inject_state = $$props => {
    		if ('autoplay' in $$props) $$invalidate(35, autoplay = $$props.autoplay);
    		if ('background' in $$props) $$invalidate(1, background = $$props.background);
    		if ('controls' in $$props) $$invalidate(2, controls = $$props.controls);
    		if ('controlsLayout' in $$props) $$invalidate(3, controlsLayout = $$props.controlsLayout);
    		if ('count' in $$props) $$invalidate(36, count = $$props.count);
    		if ('defaultFrame' in $$props) $$invalidate(37, defaultFrame = $$props.defaultFrame);
    		if ('direction' in $$props) $$invalidate(33, direction = $$props.direction);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('hover' in $$props) $$invalidate(38, hover = $$props.hover);
    		if ('loop' in $$props) $$invalidate(0, loop = $$props.loop);
    		if ('mode' in $$props) $$invalidate(39, mode = $$props.mode);
    		if ('onToggleZoom' in $$props) $$invalidate(40, onToggleZoom = $$props.onToggleZoom);
    		if ('renderer' in $$props) $$invalidate(41, renderer = $$props.renderer);
    		if ('speed' in $$props) $$invalidate(34, speed = $$props.speed);
    		if ('src' in $$props) $$invalidate(5, src = $$props.src);
    		if ('style' in $$props) $$invalidate(6, style = $$props.style);
    		if ('width' in $$props) $$invalidate(7, width = $$props.width);
    		if ('animationData' in $$props) $$invalidate(22, animationData = $$props.animationData);
    		if ('animationRef' in $$props) $$invalidate(23, animationRef = $$props.animationRef);
    		if ('playerRef' in $$props) $$invalidate(24, playerRef = $$props.playerRef);
    		if ('wrapperRef' in $$props) $$invalidate(25, wrapperRef = $$props.wrapperRef);
    		if ('instance' in $$props) $$invalidate(21, instance = $$props.instance);
    		if ('frame' in $$props) $$invalidate(26, frame = $$props.frame);
    		if ('progress' in $$props) $$invalidate(27, progress = $$props.progress);
    		if ('io' in $$props) io = $$props.io;
    		if ('currentState' in $$props) $$invalidate(28, currentState = $$props.currentState);
    		if ('isZoomed' in $$props) $$invalidate(29, isZoomed = $$props.isZoomed);
    		if ('playerHeight' in $$props) $$invalidate(30, playerHeight = $$props.playerHeight);
    		if ('playerWidth' in $$props) $$invalidate(31, playerWidth = $$props.playerWidth);
    		if ('totalFrames' in $$props) $$invalidate(32, totalFrames = $$props.totalFrames);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*src*/ 32) {
    			// Try load new animation when the src value changes
    			load(src);
    		}

    		if ($$self.$$.dirty[0] & /*instance, loop*/ 2097153) {
    			// Update the player with loop prop changes
    			{
    				if (instance) {
    					$$invalidate(21, instance.loop = loop, instance);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*instance*/ 2097152 | $$self.$$.dirty[1] & /*speed*/ 8) {
    			// Update the player with speed prop changes
    			{
    				if (instance) {
    					instance.setSpeed(speed);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*instance*/ 2097152 | $$self.$$.dirty[1] & /*direction*/ 4) {
    			// Update the player with direction prop changes
    			{
    				if (instance) {
    					instance.setDirection(direction);
    				}
    			}
    		}
    	};

    	return [
    		loop,
    		background,
    		controls,
    		controlsLayout,
    		height,
    		src,
    		style,
    		width,
    		play,
    		pause,
    		stop,
    		freeze,
    		seek,
    		snapshot,
    		setLooping,
    		setSpeed,
    		setDirection,
    		togglePlay,
    		toggleLooping,
    		setBackground,
    		toggleZoom,
    		instance,
    		animationData,
    		animationRef,
    		playerRef,
    		wrapperRef,
    		frame,
    		progress,
    		currentState,
    		isZoomed,
    		playerHeight,
    		playerWidth,
    		totalFrames,
    		direction,
    		speed,
    		autoplay,
    		count,
    		defaultFrame,
    		hover,
    		mode,
    		onToggleZoom,
    		renderer,
    		load,
    		getLottie,
    		resize,
    		div0_binding,
    		background_handler,
    		div1_binding,
    		div2_binding,
    		div2_elementresize_handler
    	];
    }

    class LottiePlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance_1,
    			create_fragment$g,
    			safe_not_equal,
    			{
    				autoplay: 35,
    				background: 1,
    				controls: 2,
    				controlsLayout: 3,
    				count: 36,
    				defaultFrame: 37,
    				direction: 33,
    				height: 4,
    				hover: 38,
    				loop: 0,
    				mode: 39,
    				onToggleZoom: 40,
    				renderer: 41,
    				speed: 34,
    				src: 5,
    				style: 6,
    				width: 7,
    				load: 42,
    				getLottie: 43,
    				play: 8,
    				pause: 9,
    				stop: 10,
    				freeze: 11,
    				resize: 44,
    				seek: 12,
    				snapshot: 13,
    				setLooping: 14,
    				setSpeed: 15,
    				setDirection: 16,
    				togglePlay: 17,
    				toggleLooping: 18,
    				setBackground: 19,
    				toggleZoom: 20
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LottiePlayer",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*background*/ ctx[1] === undefined && !('background' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'background'");
    		}

    		if (/*controls*/ ctx[2] === undefined && !('controls' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'controls'");
    		}

    		if (/*controlsLayout*/ ctx[3] === undefined && !('controlsLayout' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'controlsLayout'");
    		}

    		if (/*height*/ ctx[4] === undefined && !('height' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'height'");
    		}

    		if (/*width*/ ctx[7] === undefined && !('width' in props)) {
    			console.warn("<LottiePlayer> was created without expected prop 'width'");
    		}
    	}

    	get autoplay() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set autoplay(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get background() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set background(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get controls() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set controls(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get controlsLayout() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set controlsLayout(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultFrame() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultFrame(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hover() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hover(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loop() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loop(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onToggleZoom() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onToggleZoom(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renderer() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renderer(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get speed() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set speed(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get src() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<LottiePlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get load() {
    		return this.$$.ctx[42];
    	}

    	set load(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getLottie() {
    		return this.$$.ctx[43];
    	}

    	set getLottie(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get play() {
    		return this.$$.ctx[8];
    	}

    	set play(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pause() {
    		return this.$$.ctx[9];
    	}

    	set pause(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stop() {
    		return this.$$.ctx[10];
    	}

    	set stop(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get freeze() {
    		return this.$$.ctx[11];
    	}

    	set freeze(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resize() {
    		return this.$$.ctx[44];
    	}

    	set resize(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get seek() {
    		return this.$$.ctx[12];
    	}

    	set seek(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get snapshot() {
    		return this.$$.ctx[13];
    	}

    	set snapshot(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setLooping() {
    		return this.$$.ctx[14];
    	}

    	set setLooping(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setSpeed() {
    		return this.$$.ctx[15];
    	}

    	set setSpeed(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setDirection() {
    		return this.$$.ctx[16];
    	}

    	set setDirection(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get togglePlay() {
    		return this.$$.ctx[17];
    	}

    	set togglePlay(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleLooping() {
    		return this.$$.ctx[18];
    	}

    	set toggleLooping(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get setBackground() {
    		return this.$$.ctx[19];
    	}

    	set setBackground(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get toggleZoom() {
    		return this.$$.ctx[20];
    	}

    	set toggleZoom(value) {
    		throw new Error("<LottiePlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Link.svelte generated by Svelte v3.44.2 */

    const file$f = "src/components/Link.svelte";

    function create_fragment$f(ctx) {
    	let div;
    	let p0;
    	let t;
    	let p1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);
    	const default_slot_template_1 = /*#slots*/ ctx[4].default;
    	const default_slot_1 = create_slot(default_slot_template_1, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			if (default_slot) default_slot.c();
    			t = space();
    			p1 = element("p");
    			if (default_slot_1) default_slot_1.c();
    			attr_dev(p0, "class", "link--hover-modifier svelte-unj3zt");
    			add_location(p0, file$f, 17, 4, 387);
    			attr_dev(p1, "class", "link svelte-unj3zt");
    			add_location(p1, file$f, 18, 4, 441);
    			attr_dev(div, "class", "links svelte-unj3zt");
    			add_location(div, file$f, 16, 0, 343);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);

    			if (default_slot) {
    				default_slot.m(p0, null);
    			}

    			append_dev(div, t);
    			append_dev(div, p1);

    			if (default_slot_1) {
    				default_slot_1.m(p1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*callback*/ ctx[0], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}

    			if (default_slot_1) {
    				if (default_slot_1.p && (!current || dirty & /*$$scope*/ 8)) {
    					update_slot_base(
    						default_slot_1,
    						default_slot_template_1,
    						ctx,
    						/*$$scope*/ ctx[3],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
    						: get_slot_changes(default_slot_template_1, /*$$scope*/ ctx[3], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(default_slot_1, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(default_slot_1, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			if (default_slot_1) default_slot_1.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Link', slots, ['default']);
    	let { onClick } = $$props;
    	let { href } = $$props;

    	function callback() {
    		if (href) {
    			const aElement = document.createElement('a');
    			aElement.href = href;
    			aElement.target = '_blank';
    			aElement.click();
    		} else if (onClick) {
    			onClick();
    		}
    	}

    	const writable_props = ['onClick', 'href'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Link> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('onClick' in $$props) $$invalidate(1, onClick = $$props.onClick);
    		if ('href' in $$props) $$invalidate(2, href = $$props.href);
    		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ onClick, href, callback });

    	$$self.$inject_state = $$props => {
    		if ('onClick' in $$props) $$invalidate(1, onClick = $$props.onClick);
    		if ('href' in $$props) $$invalidate(2, href = $$props.href);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [callback, onClick, href, $$scope, slots];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { onClick: 1, href: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*onClick*/ ctx[1] === undefined && !('onClick' in props)) {
    			console.warn("<Link> was created without expected prop 'onClick'");
    		}

    		if (/*href*/ ctx[2] === undefined && !('href' in props)) {
    			console.warn("<Link> was created without expected prop 'href'");
    		}
    	}

    	get onClick() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/AsyncSvg.svelte generated by Svelte v3.44.2 */

    const file$e = "src/components/AsyncSvg.svelte";

    function create_fragment$e(ctx) {
    	let div;
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*hint*/ ctx[1]);
    			add_location(img, file$e, 15, 4, 387);
    			attr_dev(div, "class", "async-svg svelte-93asln");
    			add_location(div, file$e, 14, 0, 339);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			/*div_binding*/ ctx[4](div);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*src*/ 1 && !src_url_equal(img.src, img_src_value = /*src*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*hint*/ 2) {
    				attr_dev(img, "alt", /*hint*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AsyncSvg', slots, []);
    	let { src } = $$props;
    	let { hint } = $$props;
    	let { fill } = $$props;
    	let element;

    	fetch(src).then(response => response.text()).then(svg => {
    		$$invalidate(2, element.innerHTML = svg, element);
    		if (hint) element.setAttribute('data-hint', hint);
    		if (fill) element.querySelector('svg').setAttribute('fill', fill);
    	});

    	const writable_props = ['src', 'hint', 'fill'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AsyncSvg> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(2, element);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('src' in $$props) $$invalidate(0, src = $$props.src);
    		if ('hint' in $$props) $$invalidate(1, hint = $$props.hint);
    		if ('fill' in $$props) $$invalidate(3, fill = $$props.fill);
    	};

    	$$self.$capture_state = () => ({ src, hint, fill, element });

    	$$self.$inject_state = $$props => {
    		if ('src' in $$props) $$invalidate(0, src = $$props.src);
    		if ('hint' in $$props) $$invalidate(1, hint = $$props.hint);
    		if ('fill' in $$props) $$invalidate(3, fill = $$props.fill);
    		if ('element' in $$props) $$invalidate(2, element = $$props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [src, hint, element, fill, div_binding];
    }

    class AsyncSvg extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { src: 0, hint: 1, fill: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsyncSvg",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*src*/ ctx[0] === undefined && !('src' in props)) {
    			console.warn("<AsyncSvg> was created without expected prop 'src'");
    		}

    		if (/*hint*/ ctx[1] === undefined && !('hint' in props)) {
    			console.warn("<AsyncSvg> was created without expected prop 'hint'");
    		}

    		if (/*fill*/ ctx[3] === undefined && !('fill' in props)) {
    			console.warn("<AsyncSvg> was created without expected prop 'fill'");
    		}
    	}

    	get src() {
    		throw new Error("<AsyncSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set src(value) {
    		throw new Error("<AsyncSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hint() {
    		throw new Error("<AsyncSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hint(value) {
    		throw new Error("<AsyncSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fill() {
    		throw new Error("<AsyncSvg>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fill(value) {
    		throw new Error("<AsyncSvg>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Header.svelte generated by Svelte v3.44.2 */
    const file$d = "src/components/Header.svelte";

    // (21:12) <Link onClick={() => scrollTo(document.querySelector('#about-me'))}>
    function create_default_slot_2$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("About me");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(21:12) <Link onClick={() => scrollTo(document.querySelector('#about-me'))}>",
    		ctx
    	});

    	return block;
    }

    // (22:12) <Link onClick={() => scrollTo(document.querySelector('#projects'))}>
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Projects");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(22:12) <Link onClick={() => scrollTo(document.querySelector('#projects'))}>",
    		ctx
    	});

    	return block;
    }

    // (23:12) <Link onClick={() => scrollTo(document.querySelector('#contact'))}>
    function create_default_slot$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Contact");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(23:12) <Link onClick={() => scrollTo(document.querySelector('#contact'))}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let header;
    	let div0;
    	let asyncsvg0;
    	let t0;
    	let nav;
    	let div1;
    	let link0;
    	let t1;
    	let link1;
    	let t2;
    	let link2;
    	let t3;
    	let div5;
    	let div2;
    	let a0;
    	let asyncsvg1;
    	let t4;
    	let div3;
    	let a1;
    	let asyncsvg2;
    	let t5;
    	let div4;
    	let a2;
    	let asyncsvg3;
    	let current;

    	asyncsvg0 = new AsyncSvg({
    			props: { src: "assets/svg/logo.svg", hint: "" },
    			$$inline: true
    		});

    	link0 = new Link({
    			props: {
    				onClick: /*func*/ ctx[0],
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				onClick: /*func_1*/ ctx[1],
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				onClick: /*func_2*/ ctx[2],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	asyncsvg1 = new AsyncSvg({
    			props: {
    				src: "assets/svg/icons/twitter.svg",
    				hint: "Twitter",
    				fill: "#E4E6E7"
    			},
    			$$inline: true
    		});

    	asyncsvg2 = new AsyncSvg({
    			props: {
    				src: "assets/svg/icons/linkedin.svg",
    				hint: "LinkedIn",
    				fill: "#E4E6E7"
    			},
    			$$inline: true
    		});

    	asyncsvg3 = new AsyncSvg({
    			props: {
    				src: "assets/svg/icons/github.svg",
    				hint: "GitHub",
    				fill: "#E4E6E7"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			header = element("header");
    			div0 = element("div");
    			create_component(asyncsvg0.$$.fragment);
    			t0 = space();
    			nav = element("nav");
    			div1 = element("div");
    			create_component(link0.$$.fragment);
    			t1 = space();
    			create_component(link1.$$.fragment);
    			t2 = space();
    			create_component(link2.$$.fragment);
    			t3 = space();
    			div5 = element("div");
    			div2 = element("div");
    			a0 = element("a");
    			create_component(asyncsvg1.$$.fragment);
    			t4 = space();
    			div3 = element("div");
    			a1 = element("a");
    			create_component(asyncsvg2.$$.fragment);
    			t5 = space();
    			div4 = element("div");
    			a2 = element("a");
    			create_component(asyncsvg3.$$.fragment);
    			attr_dev(div0, "class", "logo svelte-1hsf7w6");
    			add_location(div0, file$d, 15, 4, 311);
    			attr_dev(div1, "class", "section-links svelte-1hsf7w6");
    			add_location(div1, file$d, 19, 8, 414);
    			attr_dev(nav, "class", "svelte-1hsf7w6");
    			add_location(nav, file$d, 18, 4, 400);
    			attr_dev(a0, "href", "https://twitter.com/f_arthr");
    			attr_dev(a0, "target", "_blank");
    			add_location(a0, file$d, 26, 13, 793);
    			add_location(div2, file$d, 26, 8, 788);
    			attr_dev(a1, "href", "https://www.linkedin.com/in/arthur-fontaine/");
    			attr_dev(a1, "target", "_blank");
    			add_location(a1, file$d, 29, 13, 970);
    			add_location(div3, file$d, 29, 8, 965);
    			attr_dev(a2, "href", "https://github.com/arthur-fontaine");
    			attr_dev(a2, "target", "_blank");
    			add_location(a2, file$d, 32, 13, 1166);
    			add_location(div4, file$d, 32, 8, 1161);
    			attr_dev(div5, "class", "socials svelte-1hsf7w6");
    			add_location(div5, file$d, 25, 4, 758);
    			attr_dev(header, "class", "svelte-1hsf7w6");
    			add_location(header, file$d, 14, 0, 298);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, div0);
    			mount_component(asyncsvg0, div0, null);
    			append_dev(header, t0);
    			append_dev(header, nav);
    			append_dev(nav, div1);
    			mount_component(link0, div1, null);
    			append_dev(div1, t1);
    			mount_component(link1, div1, null);
    			append_dev(div1, t2);
    			mount_component(link2, div1, null);
    			append_dev(header, t3);
    			append_dev(header, div5);
    			append_dev(div5, div2);
    			append_dev(div2, a0);
    			mount_component(asyncsvg1, a0, null);
    			append_dev(div5, t4);
    			append_dev(div5, div3);
    			append_dev(div3, a1);
    			mount_component(asyncsvg2, a1, null);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div4, a2);
    			mount_component(asyncsvg3, a2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope*/ 8) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(asyncsvg0.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(asyncsvg1.$$.fragment, local);
    			transition_in(asyncsvg2.$$.fragment, local);
    			transition_in(asyncsvg3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(asyncsvg0.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(asyncsvg1.$$.fragment, local);
    			transition_out(asyncsvg2.$$.fragment, local);
    			transition_out(asyncsvg3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			destroy_component(asyncsvg0);
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(link2);
    			destroy_component(asyncsvg1);
    			destroy_component(asyncsvg2);
    			destroy_component(asyncsvg3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function scrollTo(element) {
    	if (element) {
    		window.scrollTo({
    			top: element.offsetTop,
    			behavior: 'smooth'
    		});
    	}
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Header', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	const func = () => scrollTo(document.querySelector('#about-me'));
    	const func_1 = () => scrollTo(document.querySelector('#projects'));
    	const func_2 = () => scrollTo(document.querySelector('#contact'));
    	$$self.$capture_state = () => ({ Link, AsyncSvg, scrollTo });
    	return [func, func_1, func_2];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    /*
     * anime.js v3.2.1
     * (c) 2020 Julian Garnier
     * Released under the MIT license
     * animejs.com
     */

    // Defaults

    var defaultInstanceSettings = {
      update: null,
      begin: null,
      loopBegin: null,
      changeBegin: null,
      change: null,
      changeComplete: null,
      loopComplete: null,
      complete: null,
      loop: 1,
      direction: 'normal',
      autoplay: true,
      timelineOffset: 0
    };

    var defaultTweenSettings = {
      duration: 1000,
      delay: 0,
      endDelay: 0,
      easing: 'easeOutElastic(1, .5)',
      round: 0
    };

    var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d'];

    // Caching

    var cache = {
      CSS: {},
      springs: {}
    };

    // Utils

    function minMax(val, min, max) {
      return Math.min(Math.max(val, min), max);
    }

    function stringContains(str, text) {
      return str.indexOf(text) > -1;
    }

    function applyArguments(func, args) {
      return func.apply(null, args);
    }

    var is = {
      arr: function (a) { return Array.isArray(a); },
      obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
      pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
      svg: function (a) { return a instanceof SVGElement; },
      inp: function (a) { return a instanceof HTMLInputElement; },
      dom: function (a) { return a.nodeType || is.svg(a); },
      str: function (a) { return typeof a === 'string'; },
      fnc: function (a) { return typeof a === 'function'; },
      und: function (a) { return typeof a === 'undefined'; },
      nil: function (a) { return is.und(a) || a === null; },
      hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
      rgb: function (a) { return /^rgb/.test(a); },
      hsl: function (a) { return /^hsl/.test(a); },
      col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
      key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; },
    };

    // Easings

    function parseEasingParameters(string) {
      var match = /\(([^)]+)\)/.exec(string);
      return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
    }

    // Spring solver inspired by Webkit Copyright  2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

    function spring(string, duration) {

      var params = parseEasingParameters(string);
      var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
      var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
      var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
      var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
      var w0 = Math.sqrt(stiffness / mass);
      var zeta = damping / (2 * Math.sqrt(stiffness * mass));
      var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
      var a = 1;
      var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

      function solver(t) {
        var progress = duration ? (duration * t) / 1000 : t;
        if (zeta < 1) {
          progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
        } else {
          progress = (a + b * progress) * Math.exp(-progress * w0);
        }
        if (t === 0 || t === 1) { return t; }
        return 1 - progress;
      }

      function getDuration() {
        var cached = cache.springs[string];
        if (cached) { return cached; }
        var frame = 1/6;
        var elapsed = 0;
        var rest = 0;
        while(true) {
          elapsed += frame;
          if (solver(elapsed) === 1) {
            rest++;
            if (rest >= 16) { break; }
          } else {
            rest = 0;
          }
        }
        var duration = elapsed * frame * 1000;
        cache.springs[string] = duration;
        return duration;
      }

      return duration ? solver : getDuration;

    }

    // Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

    function steps(steps) {
      if ( steps === void 0 ) steps = 10;

      return function (t) { return Math.ceil((minMax(t, 0.000001, 1)) * steps) * (1 / steps); };
    }

    // BezierEasing https://github.com/gre/bezier-easing

    var bezier = (function () {

      var kSplineTableSize = 11;
      var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

      function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
      function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
      function C(aA1)      { return 3.0 * aA1 }

      function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
      function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

      function binarySubdivide(aX, aA, aB, mX1, mX2) {
        var currentX, currentT, i = 0;
        do {
          currentT = aA + (aB - aA) / 2.0;
          currentX = calcBezier(currentT, mX1, mX2) - aX;
          if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
        } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
        return currentT;
      }

      function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
        for (var i = 0; i < 4; ++i) {
          var currentSlope = getSlope(aGuessT, mX1, mX2);
          if (currentSlope === 0.0) { return aGuessT; }
          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
          aGuessT -= currentX / currentSlope;
        }
        return aGuessT;
      }

      function bezier(mX1, mY1, mX2, mY2) {

        if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
        var sampleValues = new Float32Array(kSplineTableSize);

        if (mX1 !== mY1 || mX2 !== mY2) {
          for (var i = 0; i < kSplineTableSize; ++i) {
            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
          }
        }

        function getTForX(aX) {

          var intervalStart = 0;
          var currentSample = 1;
          var lastSample = kSplineTableSize - 1;

          for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
            intervalStart += kSampleStepSize;
          }

          --currentSample;

          var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
          var guessForT = intervalStart + dist * kSampleStepSize;
          var initialSlope = getSlope(guessForT, mX1, mX2);

          if (initialSlope >= 0.001) {
            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
          } else if (initialSlope === 0.0) {
            return guessForT;
          } else {
            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
          }

        }

        return function (x) {
          if (mX1 === mY1 && mX2 === mY2) { return x; }
          if (x === 0 || x === 1) { return x; }
          return calcBezier(getTForX(x), mY1, mY2);
        }

      }

      return bezier;

    })();

    var penner = (function () {

      // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

      var eases = { linear: function () { return function (t) { return t; }; } };

      var functionEasings = {
        Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
        Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
        Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
        Bounce: function () { return function (t) {
          var pow2, b = 4;
          while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
          return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
        }; },
        Elastic: function (amplitude, period) {
          if ( amplitude === void 0 ) amplitude = 1;
          if ( period === void 0 ) period = .5;

          var a = minMax(amplitude, 1, 10);
          var p = minMax(period, .1, 2);
          return function (t) {
            return (t === 0 || t === 1) ? t : 
              -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
          }
        }
      };

      var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

      baseEasings.forEach(function (name, i) {
        functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
      });

      Object.keys(functionEasings).forEach(function (name) {
        var easeIn = functionEasings[name];
        eases['easeIn' + name] = easeIn;
        eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
        eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
          1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
        eases['easeOutIn' + name] = function (a, b) { return function (t) { return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : 
          (easeIn(a, b)(t * 2 - 1) + 1) / 2; }; };
      });

      return eases;

    })();

    function parseEasings(easing, duration) {
      if (is.fnc(easing)) { return easing; }
      var name = easing.split('(')[0];
      var ease = penner[name];
      var args = parseEasingParameters(easing);
      switch (name) {
        case 'spring' : return spring(easing, duration);
        case 'cubicBezier' : return applyArguments(bezier, args);
        case 'steps' : return applyArguments(steps, args);
        default : return applyArguments(ease, args);
      }
    }

    // Strings

    function selectString(str) {
      try {
        var nodes = document.querySelectorAll(str);
        return nodes;
      } catch(e) {
        return;
      }
    }

    // Arrays

    function filterArray(arr, callback) {
      var len = arr.length;
      var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
      var result = [];
      for (var i = 0; i < len; i++) {
        if (i in arr) {
          var val = arr[i];
          if (callback.call(thisArg, val, i, arr)) {
            result.push(val);
          }
        }
      }
      return result;
    }

    function flattenArray(arr) {
      return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
    }

    function toArray(o) {
      if (is.arr(o)) { return o; }
      if (is.str(o)) { o = selectString(o) || o; }
      if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
      return [o];
    }

    function arrayContains(arr, val) {
      return arr.some(function (a) { return a === val; });
    }

    // Objects

    function cloneObject(o) {
      var clone = {};
      for (var p in o) { clone[p] = o[p]; }
      return clone;
    }

    function replaceObjectProps(o1, o2) {
      var o = cloneObject(o1);
      for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
      return o;
    }

    function mergeObjects(o1, o2) {
      var o = cloneObject(o1);
      for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
      return o;
    }

    // Colors

    function rgbToRgba(rgbValue) {
      var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
      return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
    }

    function hexToRgba(hexValue) {
      var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
      var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      var r = parseInt(rgb[1], 16);
      var g = parseInt(rgb[2], 16);
      var b = parseInt(rgb[3], 16);
      return ("rgba(" + r + "," + g + "," + b + ",1)");
    }

    function hslToRgba(hslValue) {
      var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
      var h = parseInt(hsl[1], 10) / 360;
      var s = parseInt(hsl[2], 10) / 100;
      var l = parseInt(hsl[3], 10) / 100;
      var a = hsl[4] || 1;
      function hue2rgb(p, q, t) {
        if (t < 0) { t += 1; }
        if (t > 1) { t -= 1; }
        if (t < 1/6) { return p + (q - p) * 6 * t; }
        if (t < 1/2) { return q; }
        if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
        return p;
      }
      var r, g, b;
      if (s == 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
    }

    function colorToRgb(val) {
      if (is.rgb(val)) { return rgbToRgba(val); }
      if (is.hex(val)) { return hexToRgba(val); }
      if (is.hsl(val)) { return hslToRgba(val); }
    }

    // Units

    function getUnit(val) {
      var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
      if (split) { return split[1]; }
    }

    function getTransformUnit(propName) {
      if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
      if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
    }

    // Values

    function getFunctionValue(val, animatable) {
      if (!is.fnc(val)) { return val; }
      return val(animatable.target, animatable.id, animatable.total);
    }

    function getAttribute(el, prop) {
      return el.getAttribute(prop);
    }

    function convertPxToUnit(el, value, unit) {
      var valueUnit = getUnit(value);
      if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
      var cached = cache.CSS[value + unit];
      if (!is.und(cached)) { return cached; }
      var baseline = 100;
      var tempEl = document.createElement(el.tagName);
      var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
      parentEl.appendChild(tempEl);
      tempEl.style.position = 'absolute';
      tempEl.style.width = baseline + unit;
      var factor = baseline / tempEl.offsetWidth;
      parentEl.removeChild(tempEl);
      var convertedUnit = factor * parseFloat(value);
      cache.CSS[value + unit] = convertedUnit;
      return convertedUnit;
    }

    function getCSSValue(el, prop, unit) {
      if (prop in el.style) {
        var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
        return unit ? convertPxToUnit(el, value, unit) : value;
      }
    }

    function getAnimationType(el, prop) {
      if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || (is.svg(el) && el[prop]))) { return 'attribute'; }
      if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
      if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
      if (el[prop] != null) { return 'object'; }
    }

    function getElementTransforms(el) {
      if (!is.dom(el)) { return; }
      var str = el.style.transform || '';
      var reg  = /(\w+)\(([^)]*)\)/g;
      var transforms = new Map();
      var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
      return transforms;
    }

    function getTransformValue(el, propName, animatable, unit) {
      var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
      var value = getElementTransforms(el).get(propName) || defaultVal;
      if (animatable) {
        animatable.transforms.list.set(propName, value);
        animatable.transforms['last'] = propName;
      }
      return unit ? convertPxToUnit(el, value, unit) : value;
    }

    function getOriginalTargetValue(target, propName, unit, animatable) {
      switch (getAnimationType(target, propName)) {
        case 'transform': return getTransformValue(target, propName, animatable, unit);
        case 'css': return getCSSValue(target, propName, unit);
        case 'attribute': return getAttribute(target, propName);
        default: return target[propName] || 0;
      }
    }

    function getRelativeValue(to, from) {
      var operator = /^(\*=|\+=|-=)/.exec(to);
      if (!operator) { return to; }
      var u = getUnit(to) || 0;
      var x = parseFloat(from);
      var y = parseFloat(to.replace(operator[0], ''));
      switch (operator[0][0]) {
        case '+': return x + y + u;
        case '-': return x - y + u;
        case '*': return x * y + u;
      }
    }

    function validateValue(val, unit) {
      if (is.col(val)) { return colorToRgb(val); }
      if (/\s/g.test(val)) { return val; }
      var originalUnit = getUnit(val);
      var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
      if (unit) { return unitLess + unit; }
      return unitLess;
    }

    // getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
    // adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

    function getDistance(p1, p2) {
      return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
    }

    function getCircleLength(el) {
      return Math.PI * 2 * getAttribute(el, 'r');
    }

    function getRectLength(el) {
      return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
    }

    function getLineLength(el) {
      return getDistance(
        {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
        {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
      );
    }

    function getPolylineLength(el) {
      var points = el.points;
      var totalLength = 0;
      var previousPos;
      for (var i = 0 ; i < points.numberOfItems; i++) {
        var currentPos = points.getItem(i);
        if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
        previousPos = currentPos;
      }
      return totalLength;
    }

    function getPolygonLength(el) {
      var points = el.points;
      return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
    }

    // Path animation

    function getTotalLength(el) {
      if (el.getTotalLength) { return el.getTotalLength(); }
      switch(el.tagName.toLowerCase()) {
        case 'circle': return getCircleLength(el);
        case 'rect': return getRectLength(el);
        case 'line': return getLineLength(el);
        case 'polyline': return getPolylineLength(el);
        case 'polygon': return getPolygonLength(el);
      }
    }

    function setDashoffset(el) {
      var pathLength = getTotalLength(el);
      el.setAttribute('stroke-dasharray', pathLength);
      return pathLength;
    }

    // Motion path

    function getParentSvgEl(el) {
      var parentEl = el.parentNode;
      while (is.svg(parentEl)) {
        if (!is.svg(parentEl.parentNode)) { break; }
        parentEl = parentEl.parentNode;
      }
      return parentEl;
    }

    function getParentSvg(pathEl, svgData) {
      var svg = svgData || {};
      var parentSvgEl = svg.el || getParentSvgEl(pathEl);
      var rect = parentSvgEl.getBoundingClientRect();
      var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
      var width = rect.width;
      var height = rect.height;
      var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
      return {
        el: parentSvgEl,
        viewBox: viewBox,
        x: viewBox[0] / 1,
        y: viewBox[1] / 1,
        w: width,
        h: height,
        vW: viewBox[2],
        vH: viewBox[3]
      }
    }

    function getPath(path, percent) {
      var pathEl = is.str(path) ? selectString(path)[0] : path;
      var p = percent || 100;
      return function(property) {
        return {
          property: property,
          el: pathEl,
          svg: getParentSvg(pathEl),
          totalLength: getTotalLength(pathEl) * (p / 100)
        }
      }
    }

    function getPathProgress(path, progress, isPathTargetInsideSVG) {
      function point(offset) {
        if ( offset === void 0 ) offset = 0;

        var l = progress + offset >= 1 ? progress + offset : 0;
        return path.el.getPointAtLength(l);
      }
      var svg = getParentSvg(path.el, path.svg);
      var p = point();
      var p0 = point(-1);
      var p1 = point(+1);
      var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
      var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
      switch (path.property) {
        case 'x': return (p.x - svg.x) * scaleX;
        case 'y': return (p.y - svg.y) * scaleY;
        case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
      }
    }

    // Decompose value

    function decomposeValue(val, unit) {
      // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
      // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
      var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
      var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
      return {
        original: value,
        numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
        strings: (is.str(val) || unit) ? value.split(rgx) : []
      }
    }

    // Animatables

    function parseTargets(targets) {
      var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
      return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
    }

    function getAnimatables(targets) {
      var parsed = parseTargets(targets);
      return parsed.map(function (t, i) {
        return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
      });
    }

    // Properties

    function normalizePropertyTweens(prop, tweenSettings) {
      var settings = cloneObject(tweenSettings);
      // Override duration if easing is a spring
      if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
      if (is.arr(prop)) {
        var l = prop.length;
        var isFromTo = (l === 2 && !is.obj(prop[0]));
        if (!isFromTo) {
          // Duration divided by the number of tweens
          if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
        } else {
          // Transform [from, to] values shorthand to a valid tween value
          prop = {value: prop};
        }
      }
      var propArray = is.arr(prop) ? prop : [prop];
      return propArray.map(function (v, i) {
        var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
        // Default delay value should only be applied to the first tween
        if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
        // Default endDelay value should only be applied to the last tween
        if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
        return obj;
      }).map(function (k) { return mergeObjects(k, settings); });
    }


    function flattenKeyframes(keyframes) {
      var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
      .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
      var properties = {};
      var loop = function ( i ) {
        var propName = propertyNames[i];
        properties[propName] = keyframes.map(function (key) {
          var newKey = {};
          for (var p in key) {
            if (is.key(p)) {
              if (p == propName) { newKey.value = key[p]; }
            } else {
              newKey[p] = key[p];
            }
          }
          return newKey;
        });
      };

      for (var i = 0; i < propertyNames.length; i++) loop( i );
      return properties;
    }

    function getProperties(tweenSettings, params) {
      var properties = [];
      var keyframes = params.keyframes;
      if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
      for (var p in params) {
        if (is.key(p)) {
          properties.push({
            name: p,
            tweens: normalizePropertyTweens(params[p], tweenSettings)
          });
        }
      }
      return properties;
    }

    // Tweens

    function normalizeTweenValues(tween, animatable) {
      var t = {};
      for (var p in tween) {
        var value = getFunctionValue(tween[p], animatable);
        if (is.arr(value)) {
          value = value.map(function (v) { return getFunctionValue(v, animatable); });
          if (value.length === 1) { value = value[0]; }
        }
        t[p] = value;
      }
      t.duration = parseFloat(t.duration);
      t.delay = parseFloat(t.delay);
      return t;
    }

    function normalizeTweens(prop, animatable) {
      var previousTween;
      return prop.tweens.map(function (t) {
        var tween = normalizeTweenValues(t, animatable);
        var tweenValue = tween.value;
        var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
        var toUnit = getUnit(to);
        var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
        var previousValue = previousTween ? previousTween.to.original : originalValue;
        var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
        var fromUnit = getUnit(from) || getUnit(originalValue);
        var unit = toUnit || fromUnit;
        if (is.und(to)) { to = previousValue; }
        tween.from = decomposeValue(from, unit);
        tween.to = decomposeValue(getRelativeValue(to, from), unit);
        tween.start = previousTween ? previousTween.end : 0;
        tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
        tween.easing = parseEasings(tween.easing, tween.duration);
        tween.isPath = is.pth(tweenValue);
        tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
        tween.isColor = is.col(tween.from.original);
        if (tween.isColor) { tween.round = 1; }
        previousTween = tween;
        return tween;
      });
    }

    // Tween progress

    var setProgressValue = {
      css: function (t, p, v) { return t.style[p] = v; },
      attribute: function (t, p, v) { return t.setAttribute(p, v); },
      object: function (t, p, v) { return t[p] = v; },
      transform: function (t, p, v, transforms, manual) {
        transforms.list.set(p, v);
        if (p === transforms.last || manual) {
          var str = '';
          transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
          t.style.transform = str;
        }
      }
    };

    // Set Value helper

    function setTargetsValue(targets, properties) {
      var animatables = getAnimatables(targets);
      animatables.forEach(function (animatable) {
        for (var property in properties) {
          var value = getFunctionValue(properties[property], animatable);
          var target = animatable.target;
          var valueUnit = getUnit(value);
          var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
          var unit = valueUnit || getUnit(originalValue);
          var to = getRelativeValue(validateValue(value, unit), originalValue);
          var animType = getAnimationType(target, property);
          setProgressValue[animType](target, property, to, animatable.transforms, true);
        }
      });
    }

    // Animations

    function createAnimation(animatable, prop) {
      var animType = getAnimationType(animatable.target, prop.name);
      if (animType) {
        var tweens = normalizeTweens(prop, animatable);
        var lastTween = tweens[tweens.length - 1];
        return {
          type: animType,
          property: prop.name,
          animatable: animatable,
          tweens: tweens,
          duration: lastTween.end,
          delay: tweens[0].delay,
          endDelay: lastTween.endDelay
        }
      }
    }

    function getAnimations(animatables, properties) {
      return filterArray(flattenArray(animatables.map(function (animatable) {
        return properties.map(function (prop) {
          return createAnimation(animatable, prop);
        });
      })), function (a) { return !is.und(a); });
    }

    // Create Instance

    function getInstanceTimings(animations, tweenSettings) {
      var animLength = animations.length;
      var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
      var timings = {};
      timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
      timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
      timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
      return timings;
    }

    var instanceID = 0;

    function createNewInstance(params) {
      var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
      var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
      var properties = getProperties(tweenSettings, params);
      var animatables = getAnimatables(params.targets);
      var animations = getAnimations(animatables, properties);
      var timings = getInstanceTimings(animations, tweenSettings);
      var id = instanceID;
      instanceID++;
      return mergeObjects(instanceSettings, {
        id: id,
        children: [],
        animatables: animatables,
        animations: animations,
        duration: timings.duration,
        delay: timings.delay,
        endDelay: timings.endDelay
      });
    }

    // Core

    var activeInstances = [];

    var engine = (function () {
      var raf;

      function play() {
        if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
          raf = requestAnimationFrame(step);
        }
      }
      function step(t) {
        // memo on algorithm issue:
        // dangerous iteration over mutable `activeInstances`
        // (that collection may be updated from within callbacks of `tick`-ed animation instances)
        var activeInstancesLength = activeInstances.length;
        var i = 0;
        while (i < activeInstancesLength) {
          var activeInstance = activeInstances[i];
          if (!activeInstance.paused) {
            activeInstance.tick(t);
            i++;
          } else {
            activeInstances.splice(i, 1);
            activeInstancesLength--;
          }
        }
        raf = i > 0 ? requestAnimationFrame(step) : undefined;
      }

      function handleVisibilityChange() {
        if (!anime.suspendWhenDocumentHidden) { return; }

        if (isDocumentHidden()) {
          // suspend ticks
          raf = cancelAnimationFrame(raf);
        } else { // is back to active tab
          // first adjust animations to consider the time that ticks were suspended
          activeInstances.forEach(
            function (instance) { return instance ._onDocumentVisibility(); }
          );
          engine();
        }
      }
      if (typeof document !== 'undefined') {
        document.addEventListener('visibilitychange', handleVisibilityChange);
      }

      return play;
    })();

    function isDocumentHidden() {
      return !!document && document.hidden;
    }

    // Public Instance

    function anime(params) {
      if ( params === void 0 ) params = {};


      var startTime = 0, lastTime = 0, now = 0;
      var children, childrenLength = 0;
      var resolve = null;

      function makePromise(instance) {
        var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
        instance.finished = promise;
        return promise;
      }

      var instance = createNewInstance(params);
      makePromise(instance);

      function toggleInstanceDirection() {
        var direction = instance.direction;
        if (direction !== 'alternate') {
          instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
        }
        instance.reversed = !instance.reversed;
        children.forEach(function (child) { return child.reversed = instance.reversed; });
      }

      function adjustTime(time) {
        return instance.reversed ? instance.duration - time : time;
      }

      function resetTime() {
        startTime = 0;
        lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
      }

      function seekChild(time, child) {
        if (child) { child.seek(time - child.timelineOffset); }
      }

      function syncInstanceChildren(time) {
        if (!instance.reversePlayback) {
          for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
        } else {
          for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
        }
      }

      function setAnimationsProgress(insTime) {
        var i = 0;
        var animations = instance.animations;
        var animationsLength = animations.length;
        while (i < animationsLength) {
          var anim = animations[i];
          var animatable = anim.animatable;
          var tweens = anim.tweens;
          var tweenLength = tweens.length - 1;
          var tween = tweens[tweenLength];
          // Only check for keyframes if there is more than one tween
          if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
          var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
          var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
          var strings = tween.to.strings;
          var round = tween.round;
          var numbers = [];
          var toNumbersLength = tween.to.numbers.length;
          var progress = (void 0);
          for (var n = 0; n < toNumbersLength; n++) {
            var value = (void 0);
            var toNumber = tween.to.numbers[n];
            var fromNumber = tween.from.numbers[n] || 0;
            if (!tween.isPath) {
              value = fromNumber + (eased * (toNumber - fromNumber));
            } else {
              value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
            }
            if (round) {
              if (!(tween.isColor && n > 2)) {
                value = Math.round(value * round) / round;
              }
            }
            numbers.push(value);
          }
          // Manual Array.reduce for better performances
          var stringsLength = strings.length;
          if (!stringsLength) {
            progress = numbers[0];
          } else {
            progress = strings[0];
            for (var s = 0; s < stringsLength; s++) {
              strings[s];
              var b = strings[s + 1];
              var n$1 = numbers[s];
              if (!isNaN(n$1)) {
                if (!b) {
                  progress += n$1 + ' ';
                } else {
                  progress += n$1 + b;
                }
              }
            }
          }
          setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
          anim.currentValue = progress;
          i++;
        }
      }

      function setCallback(cb) {
        if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
      }

      function countIteration() {
        if (instance.remaining && instance.remaining !== true) {
          instance.remaining--;
        }
      }

      function setInstanceProgress(engineTime) {
        var insDuration = instance.duration;
        var insDelay = instance.delay;
        var insEndDelay = insDuration - instance.endDelay;
        var insTime = adjustTime(engineTime);
        instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
        instance.reversePlayback = insTime < instance.currentTime;
        if (children) { syncInstanceChildren(insTime); }
        if (!instance.began && instance.currentTime > 0) {
          instance.began = true;
          setCallback('begin');
        }
        if (!instance.loopBegan && instance.currentTime > 0) {
          instance.loopBegan = true;
          setCallback('loopBegin');
        }
        if (insTime <= insDelay && instance.currentTime !== 0) {
          setAnimationsProgress(0);
        }
        if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
          setAnimationsProgress(insDuration);
        }
        if (insTime > insDelay && insTime < insEndDelay) {
          if (!instance.changeBegan) {
            instance.changeBegan = true;
            instance.changeCompleted = false;
            setCallback('changeBegin');
          }
          setCallback('change');
          setAnimationsProgress(insTime);
        } else {
          if (instance.changeBegan) {
            instance.changeCompleted = true;
            instance.changeBegan = false;
            setCallback('changeComplete');
          }
        }
        instance.currentTime = minMax(insTime, 0, insDuration);
        if (instance.began) { setCallback('update'); }
        if (engineTime >= insDuration) {
          lastTime = 0;
          countIteration();
          if (!instance.remaining) {
            instance.paused = true;
            if (!instance.completed) {
              instance.completed = true;
              setCallback('loopComplete');
              setCallback('complete');
              if (!instance.passThrough && 'Promise' in window) {
                resolve();
                makePromise(instance);
              }
            }
          } else {
            startTime = now;
            setCallback('loopComplete');
            instance.loopBegan = false;
            if (instance.direction === 'alternate') {
              toggleInstanceDirection();
            }
          }
        }
      }

      instance.reset = function() {
        var direction = instance.direction;
        instance.passThrough = false;
        instance.currentTime = 0;
        instance.progress = 0;
        instance.paused = true;
        instance.began = false;
        instance.loopBegan = false;
        instance.changeBegan = false;
        instance.completed = false;
        instance.changeCompleted = false;
        instance.reversePlayback = false;
        instance.reversed = direction === 'reverse';
        instance.remaining = instance.loop;
        children = instance.children;
        childrenLength = children.length;
        for (var i = childrenLength; i--;) { instance.children[i].reset(); }
        if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
        setAnimationsProgress(instance.reversed ? instance.duration : 0);
      };

      // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)
      instance._onDocumentVisibility = resetTime;

      // Set Value helper

      instance.set = function(targets, properties) {
        setTargetsValue(targets, properties);
        return instance;
      };

      instance.tick = function(t) {
        now = t;
        if (!startTime) { startTime = now; }
        setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
      };

      instance.seek = function(time) {
        setInstanceProgress(adjustTime(time));
      };

      instance.pause = function() {
        instance.paused = true;
        resetTime();
      };

      instance.play = function() {
        if (!instance.paused) { return; }
        if (instance.completed) { instance.reset(); }
        instance.paused = false;
        activeInstances.push(instance);
        resetTime();
        engine();
      };

      instance.reverse = function() {
        toggleInstanceDirection();
        instance.completed = instance.reversed ? false : true;
        resetTime();
      };

      instance.restart = function() {
        instance.reset();
        instance.play();
      };

      instance.remove = function(targets) {
        var targetsArray = parseTargets(targets);
        removeTargetsFromInstance(targetsArray, instance);
      };

      instance.reset();

      if (instance.autoplay) { instance.play(); }

      return instance;

    }

    // Remove targets from animation

    function removeTargetsFromAnimations(targetsArray, animations) {
      for (var a = animations.length; a--;) {
        if (arrayContains(targetsArray, animations[a].animatable.target)) {
          animations.splice(a, 1);
        }
      }
    }

    function removeTargetsFromInstance(targetsArray, instance) {
      var animations = instance.animations;
      var children = instance.children;
      removeTargetsFromAnimations(targetsArray, animations);
      for (var c = children.length; c--;) {
        var child = children[c];
        var childAnimations = child.animations;
        removeTargetsFromAnimations(targetsArray, childAnimations);
        if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
      }
      if (!animations.length && !children.length) { instance.pause(); }
    }

    function removeTargetsFromActiveInstances(targets) {
      var targetsArray = parseTargets(targets);
      for (var i = activeInstances.length; i--;) {
        var instance = activeInstances[i];
        removeTargetsFromInstance(targetsArray, instance);
      }
    }

    // Stagger helpers

    function stagger(val, params) {
      if ( params === void 0 ) params = {};

      var direction = params.direction || 'normal';
      var easing = params.easing ? parseEasings(params.easing) : null;
      var grid = params.grid;
      var axis = params.axis;
      var fromIndex = params.from || 0;
      var fromFirst = fromIndex === 'first';
      var fromCenter = fromIndex === 'center';
      var fromLast = fromIndex === 'last';
      var isRange = is.arr(val);
      var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
      var val2 = isRange ? parseFloat(val[1]) : 0;
      var unit = getUnit(isRange ? val[1] : val) || 0;
      var start = params.start || 0 + (isRange ? val1 : 0);
      var values = [];
      var maxValue = 0;
      return function (el, i, t) {
        if (fromFirst) { fromIndex = 0; }
        if (fromCenter) { fromIndex = (t - 1) / 2; }
        if (fromLast) { fromIndex = t - 1; }
        if (!values.length) {
          for (var index = 0; index < t; index++) {
            if (!grid) {
              values.push(Math.abs(fromIndex - index));
            } else {
              var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
              var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
              var toX = index%grid[0];
              var toY = Math.floor(index/grid[0]);
              var distanceX = fromX - toX;
              var distanceY = fromY - toY;
              var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
              if (axis === 'x') { value = -distanceX; }
              if (axis === 'y') { value = -distanceY; }
              values.push(value);
            }
            maxValue = Math.max.apply(Math, values);
          }
          if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
          if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
        }
        var spacing = isRange ? (val2 - val1) / maxValue : val1;
        return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
      }
    }

    // Timeline

    function timeline(params) {
      if ( params === void 0 ) params = {};

      var tl = anime(params);
      tl.duration = 0;
      tl.add = function(instanceParams, timelineOffset) {
        var tlIndex = activeInstances.indexOf(tl);
        var children = tl.children;
        if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
        function passThrough(ins) { ins.passThrough = true; }
        for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
        var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
        insParams.targets = insParams.targets || params.targets;
        var tlDuration = tl.duration;
        insParams.autoplay = false;
        insParams.direction = tl.direction;
        insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
        passThrough(tl);
        tl.seek(insParams.timelineOffset);
        var ins = anime(insParams);
        passThrough(ins);
        children.push(ins);
        var timings = getInstanceTimings(children, params);
        tl.delay = timings.delay;
        tl.endDelay = timings.endDelay;
        tl.duration = timings.duration;
        tl.seek(0);
        tl.reset();
        if (tl.autoplay) { tl.play(); }
        return tl;
      };
      return tl;
    }

    anime.version = '3.2.1';
    anime.speed = 1;
    // TODO:#review: naming, documentation
    anime.suspendWhenDocumentHidden = true;
    anime.running = activeInstances;
    anime.remove = removeTargetsFromActiveInstances;
    anime.get = getOriginalTargetValue;
    anime.set = setTargetsValue;
    anime.convertPx = convertPxToUnit;
    anime.path = getPath;
    anime.setDashoffset = setDashoffset;
    anime.stagger = stagger;
    anime.timeline = timeline;
    anime.easing = parseEasings;
    anime.penner = penner;
    anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

    /**
     * This function returns the width and height of an element without showing it.
     * @param {HTMLElement} element - The element to measure.
     * @param {Object?} style - The parent element.
     * @returns {Object} The width and height of the element.
     */
    function measureElement(element, style = {}) {
        Object.assign(element.style, {
            ...style,
            visibility: 'hidden',
            display: 'block',
            position: 'absolute',
            left: '-9999px',
            right: '-9999px',
            width: 'max-content',
            height: 'auto',
        });

        document.body.appendChild(element);

        const width = element.offsetWidth;
        const height = element.offsetHeight;

        document.body.removeChild(element);

        return { width, height };
    }

    /**
     * This function returns a random number between `min` and `max`
     * @param {number} min
     * @param {number} max
     * @param {number} decimalPlaces
     * @returns {number}
     */
    function randomNumber(min, max, decimalPlaces = 2) {
      return Number((Math.random() * (max - min) + min).toFixed(decimalPlaces));
    }

    /* src/components/BackgroundTextRow.svelte generated by Svelte v3.44.2 */
    const file$c = "src/components/BackgroundTextRow.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[15] = list;
    	child_ctx[16] = i;
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[18] = i;
    	return child_ctx;
    }

    // (72:16) {#each Array(numberOfTextInARow * 3) as _, j}
    function create_each_block_1$2(ctx) {
    	let p;
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(/*text*/ ctx[0]);

    			attr_dev(p, "class", "background__text " + (/*j*/ ctx[18] % 2
    			? 'background__text--condensed'
    			: 'background__text--normal') + " svelte-3zy5a6");

    			add_location(p, file$c, 72, 20, 2653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*text*/ 1) set_data_dev(t, /*text*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(72:16) {#each Array(numberOfTextInARow * 3) as _, j}",
    		ctx
    	});

    	return block;
    }

    // (65:4) {#each Array(numberOfLines * 2) as _, i}
    function create_each_block$2(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let i = /*i*/ ctx[16];
    	let each_value_1 = Array(/*numberOfTextInARow*/ ctx[3] * 3);
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const assign_div1 = () => /*div1_binding*/ ctx[4](div1, i);
    	const unassign_div1 = () => /*div1_binding*/ ctx[4](null, i);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			attr_dev(div0, "class", "background__text-row svelte-3zy5a6");

    			attr_dev(div0, "style", `transform: translateX(${randomNumber(0, 1, 0) === 0
			? randomNumber(-25, -1, 1) - 25
			: randomNumber(1, 25, 1) + 25}vw)`);

    			add_location(div0, file$c, 70, 12, 2408);
    			attr_dev(div1, "class", "background__text-moving svelte-3zy5a6");
    			attr_dev(div1, "data-moving-direction", randomNumber(0, 1, 0) === 0 ? -1 : 1);
    			attr_dev(div1, "data-motion-resistance", randomNumber(0.25, 1, 2));
    			attr_dev(div1, "style", `animation-duration: ${randomNumber(60, 120, 0)}s`);
    			add_location(div1, file$c, 65, 8, 2104);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div1, t);
    			assign_div1();
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*text*/ 1) {
    				each_value_1 = Array(/*numberOfTextInARow*/ ctx[3] * 3);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (i !== /*i*/ ctx[16]) {
    				unassign_div1();
    				i = /*i*/ ctx[16];
    				assign_div1();
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			unassign_div1();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(65:4) {#each Array(numberOfLines * 2) as _, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let each_value = Array(/*numberOfLines*/ ctx[2] * 2);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "background svelte-3zy5a6");
    			add_location(div, file$c, 63, 0, 2026);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*randomNumber, _textMotions, Array, numberOfTextInARow, text*/ 11) {
    				each_value = Array(/*numberOfLines*/ ctx[2] * 2);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const fontSize = '5rem';

    function instance$c($$self, $$props, $$invalidate) {
    	let textMotions;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BackgroundTextRow', slots, []);
    	let { text } = $$props;
    	let _textMotions = [];

    	onMount(() => {
    		document.querySelector('main.app').addEventListener('scrollprogress', e => {
    			const viewportProgress = e.target.scrollProgress * e.target.offsetHeight / window.innerHeight - 1;

    			textMotions.forEach(textMotion => {
    				anime({
    					targets: textMotion,
    					duration: 10,
    					translateX: `${textMotion.getAttribute('data-moving-direction') * textMotion.getAttribute('data-motion-resistance') * viewportProgress * 100}vh`,
    					easing: 'linear'
    				});
    			});
    		});
    	});

    	const textStyles = {
    		normal: {
    			fontFamily: '"Roboto Condensed", sans-serif',
    			fontSize,
    			fontWeight: "700"
    		},
    		condensed: {
    			fontFamily: '"Roboto", sans-serif',
    			fontSize,
    			fontWeight: "300"
    		}
    	};

    	onMount(() => {
    		document.querySelector('.background').style.setProperty('--font-size', fontSize);
    	});

    	const condensedP = document.createElement("p");
    	condensedP.innerText = text;
    	const condensedPSize = measureElement(condensedP, textStyles.condensed);
    	const normalP = document.createElement("p");
    	normalP.innerText = text;
    	const normalPSize = measureElement(normalP, textStyles.normal);

    	const pSize = condensedPSize.width > normalPSize.width
    	? condensedPSize
    	: normalPSize;

    	const screenWidth = window.innerWidth;
    	const screenHeight = window.innerHeight;
    	const numberOfLines = Math.ceil(screenHeight / pSize.height);
    	const numberOfTextInARow = Math.ceil(screenWidth / pSize.width);
    	const writable_props = ['text'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BackgroundTextRow> was created with unknown prop '${key}'`);
    	});

    	function div1_binding($$value, i) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			_textMotions[i] = $$value;
    			$$invalidate(1, _textMotions);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    	};

    	$$self.$capture_state = () => ({
    		anime,
    		measureElement,
    		randomNumber,
    		onMount,
    		text,
    		_textMotions,
    		fontSize,
    		textStyles,
    		condensedP,
    		condensedPSize,
    		normalP,
    		normalPSize,
    		pSize,
    		screenWidth,
    		screenHeight,
    		numberOfLines,
    		numberOfTextInARow,
    		textMotions
    	});

    	$$self.$inject_state = $$props => {
    		if ('text' in $$props) $$invalidate(0, text = $$props.text);
    		if ('_textMotions' in $$props) $$invalidate(1, _textMotions = $$props._textMotions);
    		if ('textMotions' in $$props) textMotions = $$props.textMotions;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*_textMotions*/ 2) {
    			textMotions = _textMotions.filter(Boolean);
    		}
    	};

    	return [text, _textMotions, numberOfLines, numberOfTextInARow, div1_binding];
    }

    class BackgroundTextRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { text: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BackgroundTextRow",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*text*/ ctx[0] === undefined && !('text' in props)) {
    			console.warn("<BackgroundTextRow> was created without expected prop 'text'");
    		}
    	}

    	get text() {
    		throw new Error("<BackgroundTextRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<BackgroundTextRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/sections/Home.svelte generated by Svelte v3.44.2 */
    const file$b = "src/sections/Home.svelte";

    function create_fragment$b(ctx) {
    	let section;
    	let header;
    	let t0;
    	let backgroundtextrow;
    	let t1;
    	let img;
    	let img_src_value;
    	let current;
    	header = new Header({ $$inline: true });

    	backgroundtextrow = new BackgroundTextRow({
    			props: { text: "Arthur Fontaine" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(header.$$.fragment);
    			t0 = space();
    			create_component(backgroundtextrow.$$.fragment);
    			t1 = space();
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "assets/png/portrait.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "data-parallax-amplitude", "0");
    			attr_dev(img, "class", "svelte-tbj6c9");
    			add_location(img, file$b, 26, 4, 834);
    			attr_dev(section, "class", "home svelte-tbj6c9");
    			add_location(section, file$b, 23, 0, 743);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(header, section, null);
    			append_dev(section, t0);
    			mount_component(backgroundtextrow, section, null);
    			append_dev(section, t1);
    			append_dev(section, img);
    			/*img_binding*/ ctx[1](img);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(backgroundtextrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(backgroundtextrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(header);
    			destroy_component(backgroundtextrow);
    			/*img_binding*/ ctx[1](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Home', slots, []);
    	let portrait;

    	onMount(() => {
    		document.querySelector('main.app').addEventListener('scrollprogress', e => {
    			const pixelScrolled = e.target.scrollProgress * e.target.offsetHeight - window.innerHeight;

    			anime({
    				targets: portrait,
    				duration: 10,
    				translateX: '-50%',
    				translateY: `${-portrait.getAttribute('data-parallax-amplitude') * pixelScrolled}px`,
    				easing: 'linear'
    			});
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
    	});

    	function img_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			portrait = $$value;
    			$$invalidate(0, portrait);
    		});
    	}

    	$$self.$capture_state = () => ({
    		Header,
    		BackgroundTextRow,
    		onMount,
    		anime,
    		portrait
    	});

    	$$self.$inject_state = $$props => {
    		if ('portrait' in $$props) $$invalidate(0, portrait = $$props.portrait);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [portrait, img_binding];
    }

    class Home extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Home",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* src/components/CustomTitle.svelte generated by Svelte v3.44.2 */

    const file$a = "src/components/CustomTitle.svelte";

    function create_fragment$a(ctx) {
    	let h2;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			if (default_slot) default_slot.c();
    			attr_dev(h2, "class", "custom-title svelte-1x2lkj8");
    			add_location(h2, file$a, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);

    			if (default_slot) {
    				default_slot.m(h2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomTitle', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomTitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class CustomTitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomTitle",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* src/components/CustomText.svelte generated by Svelte v3.44.2 */

    const file$9 = "src/components/CustomText.svelte";

    function create_fragment$9(ctx) {
    	let p;
    	let p_style_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			p = element("p");
    			if (default_slot) default_slot.c();
    			attr_dev(p, "class", "custom-text svelte-7juzv9");
    			attr_dev(p, "style", p_style_value = /*underline*/ ctx[0] ? 'text-decoration: underline' : '');
    			add_location(p, file$9, 4, 0, 54);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*underline*/ 1 && p_style_value !== (p_style_value = /*underline*/ ctx[0] ? 'text-decoration: underline' : '')) {
    				attr_dev(p, "style", p_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomText', slots, ['default']);
    	let { underline = false } = $$props;
    	const writable_props = ['underline'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomText> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('underline' in $$props) $$invalidate(0, underline = $$props.underline);
    		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ underline });

    	$$self.$inject_state = $$props => {
    		if ('underline' in $$props) $$invalidate(0, underline = $$props.underline);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [underline, $$scope, slots];
    }

    class CustomText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { underline: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomText",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get underline() {
    		throw new Error("<CustomText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set underline(value) {
    		throw new Error("<CustomText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function convertRemToPixels (rem) {
        return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
    }

    /* src/components/CurriculumPart.svelte generated by Svelte v3.44.2 */
    const file$8 = "src/components/CurriculumPart.svelte";

    function create_fragment$8(ctx) {
    	let div4;
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let div1_style_value;
    	let div2_resize_listener;
    	let t1;
    	let div3;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			t1 = space();
    			div3 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "curriculum-part__circle svelte-1og9fl8");
    			add_location(div0, file$8, 44, 8, 1350);
    			attr_dev(div1, "class", "curriculum-part__stroke svelte-1og9fl8");
    			attr_dev(div1, "style", div1_style_value = `transform: scaleY(${/*getBorderWidth*/ ctx[5]() * 2 / /*barHeight*/ ctx[3] + 1})`);
    			add_location(div1, file$8, 45, 8, 1402);
    			attr_dev(div2, "class", "curriculum-part__bar svelte-1og9fl8");
    			add_render_callback(() => /*div2_elementresize_handler*/ ctx[10].call(div2));
    			toggle_class(div2, "curriculum-part__bar--is-active", /*active*/ ctx[0]);
    			toggle_class(div2, "curriculum-part__bar--is-inactive", !/*active*/ ctx[0]);
    			add_location(div2, file$8, 36, 4, 1053);
    			attr_dev(div3, "class", "curriculum-part__description");
    			toggle_class(div3, "curriculum-part__description--hidden", !/*active*/ ctx[0]);
    			add_location(div3, file$8, 47, 4, 1530);
    			attr_dev(div4, "class", "curriculum-part svelte-1og9fl8");
    			add_location(div4, file$8, 35, 0, 1019);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			/*div2_binding*/ ctx[9](div2);
    			div2_resize_listener = add_resize_listener(div2, /*div2_elementresize_handler*/ ctx[10].bind(div2));
    			append_dev(div4, t1);
    			append_dev(div4, div3);

    			if (default_slot) {
    				default_slot.m(div3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div2, "click", /*changeActive*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*barHeight*/ 8 && div1_style_value !== (div1_style_value = `transform: scaleY(${/*getBorderWidth*/ ctx[5]() * 2 / /*barHeight*/ ctx[3] + 1})`)) {
    				attr_dev(div1, "style", div1_style_value);
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div2, "curriculum-part__bar--is-active", /*active*/ ctx[0]);
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div2, "curriculum-part__bar--is-inactive", !/*active*/ ctx[0]);
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[7],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
    						null
    					);
    				}
    			}

    			if (dirty & /*active*/ 1) {
    				toggle_class(div3, "curriculum-part__description--hidden", !/*active*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			/*div2_binding*/ ctx[9](null);
    			div2_resize_listener();
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CurriculumPart', slots, ['default']);
    	let { active = false } = $$props;
    	let { clickActive = true } = $$props;
    	let bar;
    	let barWidth;
    	let barHeight;
    	const dispatch = createEventDispatcher();

    	function changeActive() {
    		if (clickActive) {
    			$$invalidate(0, active = !active);
    			dispatch('changeActive', { active, element: self });
    		}
    	}

    	function getBorderWidth() {
    		const stroke = bar
    		? bar.querySelector('.curriculum-part__stroke')
    		: undefined;

    		const borderWidth = stroke
    		? getComputedStyle(stroke)?.borderWidth?.replace('px', '')
    		: undefined;

    		return borderWidth ? parseInt(borderWidth) * 2 : 16;
    	}

    	onMount(() => {
    		const hidden_descriptions = document.querySelectorAll('.curriculum-part__description--hidden');

    		hidden_descriptions.forEach(description => {
    			description.style.display = 'none';
    		});
    	});

    	const writable_props = ['active', 'clickActive'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CurriculumPart> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			bar = $$value;
    			$$invalidate(1, bar);
    		});
    	}

    	function div2_elementresize_handler() {
    		barHeight = this.offsetHeight;
    		barWidth = this.offsetWidth;
    		$$invalidate(3, barHeight);
    		$$invalidate(2, barWidth);
    	}

    	$$self.$$set = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('clickActive' in $$props) $$invalidate(6, clickActive = $$props.clickActive);
    		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		convertRemToPixels,
    		active,
    		clickActive,
    		bar,
    		barWidth,
    		barHeight,
    		dispatch,
    		changeActive,
    		getBorderWidth
    	});

    	$$self.$inject_state = $$props => {
    		if ('active' in $$props) $$invalidate(0, active = $$props.active);
    		if ('clickActive' in $$props) $$invalidate(6, clickActive = $$props.clickActive);
    		if ('bar' in $$props) $$invalidate(1, bar = $$props.bar);
    		if ('barWidth' in $$props) $$invalidate(2, barWidth = $$props.barWidth);
    		if ('barHeight' in $$props) $$invalidate(3, barHeight = $$props.barHeight);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		active,
    		bar,
    		barWidth,
    		barHeight,
    		changeActive,
    		getBorderWidth,
    		clickActive,
    		$$scope,
    		slots,
    		div2_binding,
    		div2_elementresize_handler
    	];
    }

    class CurriculumPart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { active: 0, clickActive: 6 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CurriculumPart",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get active() {
    		throw new Error("<CurriculumPart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set active(value) {
    		throw new Error("<CurriculumPart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get clickActive() {
    		throw new Error("<CurriculumPart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set clickActive(value) {
    		throw new Error("<CurriculumPart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/CurriculumBarSubtitle.svelte generated by Svelte v3.44.2 */

    const file$7 = "src/components/CurriculumBarSubtitle.svelte";

    function create_fragment$7(ctx) {
    	let h2;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			if (default_slot) default_slot.c();
    			attr_dev(h2, "class", "curriculum-bar-subtitle svelte-61azhg");
    			add_location(h2, file$7, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);

    			if (default_slot) {
    				default_slot.m(h2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[0],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CurriculumBarSubtitle', slots, ['default']);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CurriculumBarSubtitle> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, slots];
    }

    class CurriculumBarSubtitle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CurriculumBarSubtitle",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/Curriculum.svelte generated by Svelte v3.44.2 */
    const file$6 = "src/components/Curriculum.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (111:20) <CurriculumBarSubtitle>
    function create_default_slot_4$2(ctx) {
    	let t_value = /*experience*/ ctx[6].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(111:20) <CurriculumBarSubtitle>",
    		ctx
    	});

    	return block;
    }

    // (112:20) <CustomText>
    function create_default_slot_3$2(ctx) {
    	let t0_value = /*experience*/ ctx[6].school + "";
    	let t0;
    	let br;
    	let t1_value = /*experience*/ ctx[6].location + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text(t0_value);
    			br = element("br");
    			t1 = text(t1_value);
    			add_location(br, file$6, 111, 51, 4145);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(112:20) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (114:24) <CustomText underline={true}>
    function create_default_slot_2$2(ctx) {
    	let t_value = (new Date().getTime() > /*experience*/ ctx[6].end.getTime()
    	? `Diploma${/*experience*/ ctx[6].diplomas.length > 1 ? 's' : ''} obtained`
    	: `Diploma${/*experience*/ ctx[6].diplomas.length > 1 ? 's' : ''} goal`) + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(114:24) <CustomText underline={true}>",
    		ctx
    	});

    	return block;
    }

    // (117:36) <CustomText>
    function create_default_slot_1$3(ctx) {
    	let t_value = /*diploma*/ ctx[9] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(117:36) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (116:28) {#each experience.diplomas as diploma}
    function create_each_block_1$1(ctx) {
    	let li;
    	let customtext;
    	let current;

    	customtext = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(customtext.$$.fragment);
    			attr_dev(li, "class", "svelte-1vqtpkj");
    			add_location(li, file$6, 116, 32, 4582);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(customtext, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const customtext_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				customtext_changes.$$scope = { dirty, ctx };
    			}

    			customtext.$set(customtext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customtext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customtext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(customtext);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(116:28) {#each experience.diplomas as diploma}",
    		ctx
    	});

    	return block;
    }

    // (109:12) <CurriculumPart active={i === activeExperience} clickActive={!isAnimating} on:changeActive={(event) => changeActive(event, i)}>
    function create_default_slot$3(ctx) {
    	let div1;
    	let curriculumbarsubtitle;
    	let t0;
    	let customtext0;
    	let t1;
    	let div0;
    	let customtext1;
    	let t2;
    	let ul;
    	let current;

    	curriculumbarsubtitle = new CurriculumBarSubtitle({
    			props: {
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext0 = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext1 = new CustomText({
    			props: {
    				underline: true,
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*experience*/ ctx[6].diplomas;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(curriculumbarsubtitle.$$.fragment);
    			t0 = space();
    			create_component(customtext0.$$.fragment);
    			t1 = space();
    			div0 = element("div");
    			create_component(customtext1.$$.fragment);
    			t2 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1vqtpkj");
    			add_location(ul, file$6, 114, 24, 4478);
    			add_location(div0, file$6, 112, 20, 4206);
    			add_location(div1, file$6, 109, 16, 4002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(curriculumbarsubtitle, div1, null);
    			append_dev(div1, t0);
    			mount_component(customtext0, div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			mount_component(customtext1, div0, null);
    			append_dev(div0, t2);
    			append_dev(div0, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const curriculumbarsubtitle_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				curriculumbarsubtitle_changes.$$scope = { dirty, ctx };
    			}

    			curriculumbarsubtitle.$set(curriculumbarsubtitle_changes);
    			const customtext0_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				customtext0_changes.$$scope = { dirty, ctx };
    			}

    			customtext0.$set(customtext0_changes);
    			const customtext1_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				customtext1_changes.$$scope = { dirty, ctx };
    			}

    			customtext1.$set(customtext1_changes);

    			if (dirty & /*curriculum*/ 4) {
    				each_value_1 = /*experience*/ ctx[6].diplomas;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curriculumbarsubtitle.$$.fragment, local);
    			transition_in(customtext0.$$.fragment, local);
    			transition_in(customtext1.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curriculumbarsubtitle.$$.fragment, local);
    			transition_out(customtext0.$$.fragment, local);
    			transition_out(customtext1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(curriculumbarsubtitle);
    			destroy_component(customtext0);
    			destroy_component(customtext1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(109:12) <CurriculumPart active={i === activeExperience} clickActive={!isAnimating} on:changeActive={(event) => changeActive(event, i)}>",
    		ctx
    	});

    	return block;
    }

    // (107:4) {#each curriculum as experience, i}
    function create_each_block$1(ctx) {
    	let div;
    	let curriculumpart;
    	let t;
    	let current;

    	function changeActive_handler(...args) {
    		return /*changeActive_handler*/ ctx[4](/*i*/ ctx[8], ...args);
    	}

    	curriculumpart = new CurriculumPart({
    			props: {
    				active: /*i*/ ctx[8] === /*activeExperience*/ ctx[0],
    				clickActive: !/*isAnimating*/ ctx[1],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	curriculumpart.$on("changeActive", changeActive_handler);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(curriculumpart.$$.fragment);
    			t = space();
    			attr_dev(div, "style", `z-index: ${/*i*/ ctx[8]}`);
    			attr_dev(div, "class", "svelte-1vqtpkj");
    			add_location(div, file$6, 107, 8, 3816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(curriculumpart, div, null);
    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const curriculumpart_changes = {};
    			if (dirty & /*activeExperience*/ 1) curriculumpart_changes.active = /*i*/ ctx[8] === /*activeExperience*/ ctx[0];
    			if (dirty & /*isAnimating*/ 2) curriculumpart_changes.clickActive = !/*isAnimating*/ ctx[1];

    			if (dirty & /*$$scope*/ 4096) {
    				curriculumpart_changes.$$scope = { dirty, ctx };
    			}

    			curriculumpart.$set(curriculumpart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(curriculumpart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(curriculumpart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(curriculumpart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(107:4) {#each curriculum as experience, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div;
    	let current;
    	let each_value = /*curriculum*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "curriculum svelte-1vqtpkj");
    			add_location(div, file$6, 105, 0, 3743);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeExperience, isAnimating, changeActive, curriculum, Date*/ 15) {
    				each_value = /*curriculum*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Curriculum', slots, []);

    	const curriculum = [
    		{
    			title: "Middle school",
    			school: "Collge Jeanne dArc",
    			location: "Argentan, France",
    			start: new Date(2014, 9),
    			end: new Date(2018, 6),
    			diplomas: ["BIA (Aeronautical initiation certificate)"]
    		},
    		{
    			title: "High school",
    			school: "Lyce Jeanne dArc",
    			location: "Argentan, France",
    			start: new Date(2018, 9),
    			end: new Date(2021, 6),
    			diplomas: ["General baccalaureate with honors"]
    		},
    		{
    			title: "University",
    			school: "HETIC",
    			location: "Paris, France",
    			start: new Date(2021, 9),
    			end: new Date(2024, 6),
    			diplomas: ["Bachelor Data and AI"]
    		}
    	];

    	let activeExperience = 0;
    	let isAnimating = false;
    	let lastCurriculumChange = Date.now();

    	setInterval(
    		() => {
    			if (isAnimating) return;
    			if (Date.now() - lastCurriculumChange < 10000) return;
    			const newActiveExperience = (activeExperience + 1) % curriculum.length;
    			document.querySelectorAll('.curriculum-part .curriculum-part__bar')[newActiveExperience].click();
    		},
    		500
    	);

    	function changeActive(event, i) {
    		lastCurriculumChange = Date.now();
    		const currentActiveExperience = activeExperience;
    		const { active } = event.detail;
    		if (active) $$invalidate(0, activeExperience = i);

    		if (currentActiveExperience !== activeExperience) {
    			const newElement = document.querySelectorAll('.curriculum .curriculum-part')[i];
    			const currentElement = document.querySelectorAll('.curriculum .curriculum-part')[currentActiveExperience];
    			const newElementDesc = newElement.querySelector('.curriculum-part__description');
    			const currentElementDesc = currentElement.querySelector('.curriculum-part__description');

    			// const stageDiff = activeExperience - currentActiveExperience;
    			// const duration = 500 * Math.abs(stageDiff);
    			const duration = 500;

    			const easing = 'easeInOutCirc';
    			$$invalidate(1, isAnimating = true);

    			anime({
    				targets: currentElementDesc,
    				translateY: [
    					0,
    					`${newElement.getBoundingClientRect().y - currentElement.getBoundingClientRect().y}px`
    				],
    				opacity: [1, 0],
    				duration,
    				easing,
    				begin: () => {
    					currentElementDesc.style.height = '0';
    				},
    				complete: () => {
    					currentElementDesc.style.display = 'none';
    					currentElementDesc.style.height = 'auto';
    					currentElementDesc.style.transform = 'translateY(0)';
    				}
    			});

    			anime({
    				targets: newElementDesc,
    				translateY: [
    					`${currentElement.getBoundingClientRect().y - newElement.getBoundingClientRect().y}px`,
    					0
    				],
    				opacity: [0, 1],
    				duration,
    				easing,
    				begin: () => {
    					newElementDesc.style.height = 'auto';
    					newElementDesc.style.display = 'block';
    				},
    				complete: () => {
    					$$invalidate(1, isAnimating = false);
    				}
    			});
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Curriculum> was created with unknown prop '${key}'`);
    	});

    	const changeActive_handler = (i, event) => changeActive(event, i);

    	$$self.$capture_state = () => ({
    		CurriculumPart,
    		CurriculumBarSubtitle,
    		CustomText,
    		anime,
    		curriculum,
    		activeExperience,
    		isAnimating,
    		lastCurriculumChange,
    		changeActive
    	});

    	$$self.$inject_state = $$props => {
    		if ('activeExperience' in $$props) $$invalidate(0, activeExperience = $$props.activeExperience);
    		if ('isAnimating' in $$props) $$invalidate(1, isAnimating = $$props.isAnimating);
    		if ('lastCurriculumChange' in $$props) lastCurriculumChange = $$props.lastCurriculumChange;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [activeExperience, isAnimating, curriculum, changeActive, changeActive_handler];
    }

    class Curriculum extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Curriculum",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/components/CustomButton.svelte generated by Svelte v3.44.2 */

    const file$5 = "src/components/CustomButton.svelte";

    function create_fragment$5(ctx) {
    	let div1;
    	let p;
    	let t0;
    	let div0;
    	let svg0;
    	let line0;
    	let polyline0;
    	let t1;
    	let svg1;
    	let line1;
    	let polyline1;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			p = element("p");
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div0 = element("div");
    			svg0 = svg_element("svg");
    			line0 = svg_element("line");
    			polyline0 = svg_element("polyline");
    			t1 = space();
    			svg1 = svg_element("svg");
    			line1 = svg_element("line");
    			polyline1 = svg_element("polyline");
    			attr_dev(p, "class", "svelte-1qzqx90");
    			add_location(p, file$5, 19, 4, 502);
    			attr_dev(line0, "x1", "5");
    			attr_dev(line0, "y1", "12");
    			attr_dev(line0, "x2", "19");
    			attr_dev(line0, "y2", "12");
    			attr_dev(line0, "class", "svelte-1qzqx90");
    			add_location(line0, file$5, 21, 255, 811);
    			attr_dev(polyline0, "points", "12 5 19 12 12 19");
    			attr_dev(polyline0, "class", "svelte-1qzqx90");
    			add_location(polyline0, file$5, 21, 299, 855);
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "width", "24");
    			attr_dev(svg0, "height", "24");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			attr_dev(svg0, "fill", "none");
    			attr_dev(svg0, "stroke", "currentColor");
    			attr_dev(svg0, "stroke-width", "2");
    			attr_dev(svg0, "stroke-linecap", "round");
    			attr_dev(svg0, "stroke-linejoin", "round");
    			attr_dev(svg0, "class", "feather feather-arrow-right button__arrow--hover-modifier svelte-1qzqx90");
    			add_location(svg0, file$5, 21, 8, 564);
    			attr_dev(line1, "x1", "5");
    			attr_dev(line1, "y1", "12");
    			attr_dev(line1, "x2", "19");
    			attr_dev(line1, "y2", "12");
    			attr_dev(line1, "class", "svelte-1qzqx90");
    			add_location(line1, file$5, 22, 239, 1148);
    			attr_dev(polyline1, "points", "12 5 19 12 12 19");
    			attr_dev(polyline1, "class", "svelte-1qzqx90");
    			add_location(polyline1, file$5, 22, 283, 1192);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "width", "24");
    			attr_dev(svg1, "height", "24");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			attr_dev(svg1, "fill", "none");
    			attr_dev(svg1, "stroke", "currentColor");
    			attr_dev(svg1, "stroke-width", "2");
    			attr_dev(svg1, "stroke-linecap", "round");
    			attr_dev(svg1, "stroke-linejoin", "round");
    			attr_dev(svg1, "class", "feather feather-arrow-right button__arrow svelte-1qzqx90");
    			add_location(svg1, file$5, 22, 8, 917);
    			attr_dev(div0, "class", "button__arrows svelte-1qzqx90");
    			add_location(div0, file$5, 20, 4, 527);
    			attr_dev(div1, "class", "button svelte-1qzqx90");
    			attr_dev(div1, "style", /*style*/ ctx[1]);
    			toggle_class(div1, "button--download", /*download*/ ctx[0]);
    			add_location(div1, file$5, 18, 0, 410);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, p);

    			if (default_slot) {
    				default_slot.m(p, null);
    			}

    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, svg0);
    			append_dev(svg0, line0);
    			append_dev(svg0, polyline0);
    			append_dev(div0, t1);
    			append_dev(div0, svg1);
    			append_dev(svg1, line1);
    			append_dev(svg1, polyline1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					div1,
    					"click",
    					function () {
    						if (is_function(/*onClick*/ ctx[2])) /*onClick*/ ctx[2].apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, [dirty]) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 16)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[4],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[4])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[4], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div1, "style", /*style*/ ctx[1]);
    			}

    			if (dirty & /*download*/ 1) {
    				toggle_class(div1, "button--download", /*download*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CustomButton', slots, ['default']);
    	let { download = false } = $$props;
    	let { href = '' } = $$props;
    	let { style = '' } = $$props;

    	let { onClick = () => {
    		const aElement = document.createElement('a');
    		aElement.setAttribute('href', href);
    		aElement.setAttribute('target', '_blank');

    		if (download) {
    			aElement.setAttribute('download', '');
    		}

    		aElement.click();
    	} } = $$props;

    	const writable_props = ['download', 'href', 'style', 'onClick'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CustomButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('download' in $$props) $$invalidate(0, download = $$props.download);
    		if ('href' in $$props) $$invalidate(3, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
    		if ('$$scope' in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ download, href, style, onClick });

    	$$self.$inject_state = $$props => {
    		if ('download' in $$props) $$invalidate(0, download = $$props.download);
    		if ('href' in $$props) $$invalidate(3, href = $$props.href);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('onClick' in $$props) $$invalidate(2, onClick = $$props.onClick);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [download, style, onClick, href, $$scope, slots];
    }

    class CustomButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			download: 0,
    			href: 3,
    			style: 1,
    			onClick: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CustomButton",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get download() {
    		throw new Error("<CustomButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set download(value) {
    		throw new Error("<CustomButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get href() {
    		throw new Error("<CustomButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set href(value) {
    		throw new Error("<CustomButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<CustomButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<CustomButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get onClick() {
    		throw new Error("<CustomButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set onClick(value) {
    		throw new Error("<CustomButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/sections/AboutMe.svelte generated by Svelte v3.44.2 */
    const file$4 = "src/sections/AboutMe.svelte";

    // (10:8) <CustomTitle>
    function create_default_slot_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("About Me");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(10:8) <CustomTitle>",
    		ctx
    	});

    	return block;
    }

    // (15:12) <CustomText>
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("I am Arthur, a 18 years old french full-stack developer.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(15:12) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (16:12) <CustomText>
    function create_default_slot_3$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Student at HETIC, development school, I have been developing websites and mobile applications for 2 years.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(16:12) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (17:12) <CustomText>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Having chosen to study a Bachelor's degree in Data and Artificial Intelligence, I plan to specialize in a field with great perspectives.");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(17:12) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (18:12) <CustomText>
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("To date, I use and have learned Python, Typescript (with Nuxt.js / Svelte / Node.js) and Dart (with Flutter).");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(18:12) <CustomText>",
    		ctx
    	});

    	return block;
    }

    // (19:12) <CustomButton href="resume.pdf" download>
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Download my resume");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(19:12) <CustomButton href=\\\"resume.pdf\\\" download>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let section;
    	let header;
    	let customtitle;
    	let t0;
    	let div1;
    	let div0;
    	let customtext0;
    	let t1;
    	let customtext1;
    	let t2;
    	let customtext2;
    	let t3;
    	let customtext3;
    	let t4;
    	let custombutton;
    	let t5;
    	let curriculum;
    	let current;

    	customtitle = new CustomTitle({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext0 = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext1 = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext2 = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	customtext3 = new CustomText({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	custombutton = new CustomButton({
    			props: {
    				href: "resume.pdf",
    				download: true,
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	curriculum = new Curriculum({ $$inline: true });

    	const block = {
    		c: function create() {
    			section = element("section");
    			header = element("header");
    			create_component(customtitle.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			create_component(customtext0.$$.fragment);
    			t1 = space();
    			create_component(customtext1.$$.fragment);
    			t2 = space();
    			create_component(customtext2.$$.fragment);
    			t3 = space();
    			create_component(customtext3.$$.fragment);
    			t4 = space();
    			create_component(custombutton.$$.fragment);
    			t5 = space();
    			create_component(curriculum.$$.fragment);
    			add_location(header, file$4, 8, 4, 304);
    			attr_dev(div0, "class", "about-me__description svelte-1577bse");
    			add_location(div0, file$4, 13, 8, 408);
    			attr_dev(div1, "class", "parts-row svelte-1577bse");
    			add_location(div1, file$4, 12, 4, 376);
    			attr_dev(section, "id", "about-me");
    			attr_dev(section, "class", "svelte-1577bse");
    			add_location(section, file$4, 7, 0, 276);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, header);
    			mount_component(customtitle, header, null);
    			append_dev(section, t0);
    			append_dev(section, div1);
    			append_dev(div1, div0);
    			mount_component(customtext0, div0, null);
    			append_dev(div0, t1);
    			mount_component(customtext1, div0, null);
    			append_dev(div0, t2);
    			mount_component(customtext2, div0, null);
    			append_dev(div0, t3);
    			mount_component(customtext3, div0, null);
    			append_dev(div0, t4);
    			mount_component(custombutton, div0, null);
    			append_dev(div1, t5);
    			mount_component(curriculum, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const customtitle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtitle_changes.$$scope = { dirty, ctx };
    			}

    			customtitle.$set(customtitle_changes);
    			const customtext0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtext0_changes.$$scope = { dirty, ctx };
    			}

    			customtext0.$set(customtext0_changes);
    			const customtext1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtext1_changes.$$scope = { dirty, ctx };
    			}

    			customtext1.$set(customtext1_changes);
    			const customtext2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtext2_changes.$$scope = { dirty, ctx };
    			}

    			customtext2.$set(customtext2_changes);
    			const customtext3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtext3_changes.$$scope = { dirty, ctx };
    			}

    			customtext3.$set(customtext3_changes);
    			const custombutton_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				custombutton_changes.$$scope = { dirty, ctx };
    			}

    			custombutton.$set(custombutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customtitle.$$.fragment, local);
    			transition_in(customtext0.$$.fragment, local);
    			transition_in(customtext1.$$.fragment, local);
    			transition_in(customtext2.$$.fragment, local);
    			transition_in(customtext3.$$.fragment, local);
    			transition_in(custombutton.$$.fragment, local);
    			transition_in(curriculum.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customtitle.$$.fragment, local);
    			transition_out(customtext0.$$.fragment, local);
    			transition_out(customtext1.$$.fragment, local);
    			transition_out(customtext2.$$.fragment, local);
    			transition_out(customtext3.$$.fragment, local);
    			transition_out(custombutton.$$.fragment, local);
    			transition_out(curriculum.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(customtitle);
    			destroy_component(customtext0);
    			destroy_component(customtext1);
    			destroy_component(customtext2);
    			destroy_component(customtext3);
    			destroy_component(custombutton);
    			destroy_component(curriculum);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AboutMe', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AboutMe> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CustomTitle,
    		CustomText,
    		Curriculum,
    		CustomButton
    	});

    	return [];
    }

    class AboutMe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AboutMe",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src/sections/Projects.svelte generated by Svelte v3.44.2 */
    const file$3 = "src/sections/Projects.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (159:8) <CustomTitle>
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Projects");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(159:8) <CustomTitle>",
    		ctx
    	});

    	return block;
    }

    // (174:16) {:else}
    function create_else_block(ctx) {
    	let ul;
    	let current;
    	let each_value_1 = /*project*/ ctx[1].links;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "project__links svelte-1tgsrjx");
    			add_location(ul, file$3, 174, 20, 6466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*projects*/ 1) {
    				each_value_1 = /*project*/ ctx[1].links;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(174:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (170:16) {#if project.isInDevelopment}
    function create_if_block_1(ctx) {
    	let div;
    	let p;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "(in development)";
    			attr_dev(p, "class", "svelte-1tgsrjx");
    			add_location(p, file$3, 171, 24, 6371);
    			attr_dev(div, "class", "project__in-dev svelte-1tgsrjx");
    			add_location(div, file$3, 170, 20, 6317);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(170:16) {#if project.isInDevelopment}",
    		ctx
    	});

    	return block;
    }

    // (185:28) {:else}
    function create_else_block_1(ctx) {
    	let li;
    	let custombutton;
    	let t;
    	let current;

    	custombutton = new CustomButton({
    			props: {
    				href: /*link*/ ctx[4].url,
    				style: "font-size: 1.1rem; color: var(--custom-button-color, #ffffff)",
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(custombutton.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "svelte-1tgsrjx");
    			add_location(li, file$3, 185, 32, 7174);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(custombutton, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const custombutton_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				custombutton_changes.$$scope = { dirty, ctx };
    			}

    			custombutton.$set(custombutton_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(custombutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(custombutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(custombutton);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(185:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (177:28) {#if link.mainCallToAction}
    function create_if_block_2(ctx) {
    	let li;
    	let div;
    	let a;
    	let t0_value = /*link*/ ctx[4].name + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(a, "href", /*link*/ ctx[4].url);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "rel", "noopener noreferrer");
    			attr_dev(a, "class", "project__links--main-call-to-action svelte-1tgsrjx");
    			add_location(a, file$3, 179, 40, 6818);
    			attr_dev(div, "class", "project__links__mouse-over-container svelte-1tgsrjx");
    			add_location(div, file$3, 178, 36, 6727);
    			set_style(li, "--hover-text-color", /*link*/ ctx[4].hoverTextColor);
    			attr_dev(li, "class", "svelte-1tgsrjx");
    			add_location(li, file$3, 177, 32, 6636);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div);
    			append_dev(div, a);
    			append_dev(a, t0);
    			append_dev(li, t1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(177:28) {#if link.mainCallToAction}",
    		ctx
    	});

    	return block;
    }

    // (187:36) <CustomButton href={link.url} style="font-size: 1.1rem; color: var(--custom-button-color, #ffffff)">
    function create_default_slot$1(ctx) {
    	let t_value = /*link*/ ctx[4].name + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(187:36) <CustomButton href={link.url} style=\\\"font-size: 1.1rem; color: var(--custom-button-color, #ffffff)\\\">",
    		ctx
    	});

    	return block;
    }

    // (176:24) {#each project.links as link}
    function create_each_block_1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*link*/ ctx[4].mainCallToAction) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(176:24) {#each project.links as link}",
    		ctx
    	});

    	return block;
    }

    // (194:12) {#if i < projects.length - 1}
    function create_if_block(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "project__separator svelte-1tgsrjx");
    			add_location(div, file$3, 194, 16, 7571);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(194:12) {#if i < projects.length - 1}",
    		ctx
    	});

    	return block;
    }

    // (163:8) {#each projects as project, i}
    function create_each_block(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let h3;
    	let t1_value = /*project*/ ctx[1].name + "";
    	let t1;
    	let t2;
    	let p;
    	let t3_value = /*project*/ ctx[1].description + "";
    	let t3;
    	let t4;
    	let current_block_type_index;
    	let if_block0;
    	let t5;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*project*/ ctx[1].isInDevelopment) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = /*i*/ ctx[3] < /*projects*/ ctx[0].length - 1 && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			h3 = element("h3");
    			t1 = text(t1_value);
    			t2 = space();
    			p = element("p");
    			t3 = text(t3_value);
    			t4 = space();
    			if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(div0, "class", "project__background svelte-1tgsrjx");
    			add_location(div0, file$3, 164, 16, 6022);
    			attr_dev(h3, "class", "project__name svelte-1tgsrjx");
    			add_location(h3, file$3, 166, 20, 6104);
    			attr_dev(p, "class", "project__description svelte-1tgsrjx");
    			add_location(p, file$3, 167, 20, 6170);
    			attr_dev(div1, "class", "svelte-1tgsrjx");
    			add_location(div1, file$3, 165, 16, 6078);
    			attr_dev(div2, "class", "project svelte-1tgsrjx");
    			set_style(div2, "--hover-gradient", /*project*/ ctx[1].hoverGradient);
    			add_location(div2, file$3, 163, 12, 5872);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t1);
    			append_dev(div1, t2);
    			append_dev(div1, p);
    			append_dev(p, t3);
    			append_dev(div2, t4);
    			if_blocks[current_block_type_index].m(div2, null);
    			insert_dev(target, t5, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div2, "mouseover", projectMouseover, false, false, false),
    					listen_dev(div2, "mouseout", projectMouseout, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if_block0.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t5);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(163:8) {#each projects as project, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let section;
    	let header;
    	let customtitle;
    	let t;
    	let div;
    	let current;

    	customtitle = new CustomTitle({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*projects*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			section = element("section");
    			header = element("header");
    			create_component(customtitle.$$.fragment);
    			t = space();
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(header, "class", "svelte-1tgsrjx");
    			add_location(header, file$3, 157, 4, 5743);
    			attr_dev(div, "class", "svelte-1tgsrjx");
    			add_location(div, file$3, 161, 4, 5815);
    			attr_dev(section, "id", "projects");
    			attr_dev(section, "class", "svelte-1tgsrjx");
    			add_location(section, file$3, 156, 0, 5715);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, header);
    			mount_component(customtitle, header, null);
    			append_dev(section, t);
    			append_dev(section, div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const customtitle_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				customtitle_changes.$$scope = { dirty, ctx };
    			}

    			customtitle.$set(customtitle_changes);

    			if (dirty & /*projects, projectMouseover, projectMouseout*/ 1) {
    				each_value = /*projects*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customtitle.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customtitle.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(customtitle);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getProjectInParent(element) {
    	let currentElement = element;

    	if (currentElement.classList.contains("project")) {
    		return currentElement;
    	}

    	while (currentElement.parentElement) {
    		if (currentElement.parentElement.classList.contains("project")) {
    			return currentElement.parentElement;
    		}

    		currentElement = currentElement.parentElement;
    	}
    }

    function applyPositionAndSize(event) {
    	event.target.querySelector('.project__background').style.left = event.offsetX - event.target.querySelector('.project__background').offsetWidth / 2 + 'px';

    	if (event.offsetY > event.target.offsetHeight / 2) {
    		event.target.querySelector('.project__background').style.top = event.target.offsetHeight - event.target.querySelector('.project__background').offsetHeight / 2 + 'px';
    	} else {
    		event.target.querySelector('.project__background').style.top = -event.target.querySelector('.project__background').offsetHeight / 2 + 'px';
    	}
    }

    function checkProjectMouseout() {
    	document.querySelectorAll('.project--hover').forEach(element => {
    		if (!element.matches(':hover')) {
    			try {
    				applyPositionAndSize(event);
    			} catch {
    				
    			}

    			element.classList.remove('project--hover');
    		}
    	});
    }

    function projectMouseover(event) {
    	const target = getProjectInParent(event.target);

    	if (target.matches(':hover') && !target.classList.contains('project--hover')) {
    		try {
    			applyPositionAndSize(event);
    		} catch {
    			
    		}

    		event.target.classList.add('project--hover');
    	}
    }

    function projectMouseout(event) {
    	const target = getProjectInParent(event.target);

    	if (target) {
    		if (!target.matches(':hover')) {
    			try {
    				applyPositionAndSize(event);
    			} catch {
    				
    			}

    			event.target.classList.remove('project--hover');
    		}
    	} else {
    		checkProjectMouseout();
    	}
    }

    function followMouseTransforms(x, y, el) {
    	let box = el.getBoundingClientRect();
    	let constrainX = 150;
    	let constrainY = 6;
    	let calcX = -(y - box.y - box.height / 2) / constrainY;
    	let calcY = (x - box.x - box.width / 2) / constrainX;
    	return "perspective(100px) " + "   rotateX(" + calcX + "deg) " + "   rotateY(" + calcY + "deg) ";
    }

    function followMouseTransformElement(el, xyEl) {
    	el.style.transform = followMouseTransforms.apply(null, xyEl);
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Projects', slots, []);

    	const projects = [
    		{
    			name: "HiberFile",
    			description: "A free, open source and privacy friendly file host.",
    			isInDevelopment: false,
    			links: [
    				{
    					name: "See the project",
    					url: "https://hiberfile.com",
    					mainCallToAction: true,
    					hoverTextColor: '#2D56D5'
    				},
    				{
    					name: "View on GitHub",
    					url: "https://github.com/hiberfile/hiberfile"
    				}
    			],
    			hoverGradient: "radial-gradient(100% 2722.12% at 0% 0%, #009BF5 0%, #2D56D5 100%)"
    		},
    		{
    			name: "Quice",
    			description: "An application that analyzes your dietary needs and your tastes to suggest the best meals among thousands.",
    			isInDevelopment: true,
    			hoverGradient: "radial-gradient(circle at left top, #84CAD6, #6AAAB5)"
    		},
    		{
    			name: "Rosas",
    			description: "A free RSS reader that allows you to read your favorite news sources and play your favorite podcasts.",
    			isInDevelopment: true,
    			hoverGradient: "radial-gradient(circle at left top, #F65045, #F53F32)"
    		}
    	];

    	onMount(() => {
    		setInterval(checkProjectMouseout, 100);
    	});

    	onMount(() => {
    		document.querySelectorAll('.project__links__mouse-over-container').forEach(el => {
    			el.addEventListener('mousemove', event => {
    				let elementToTransform = event.target;

    				if (!elementToTransform.classList.contains('.project__links--main-call-to-action')) {
    					elementToTransform = elementToTransform.parentElement;
    				}

    				let position = [event.clientX, event.clientY, elementToTransform];

    				window.requestAnimationFrame(function () {
    					followMouseTransformElement(elementToTransform, position);
    				});
    			});

    			el.addEventListener('mouseout', event => {
    				let elementToTransform = event.target;

    				if (!elementToTransform.classList.contains('.project__links--main-call-to-action')) {
    					elementToTransform = elementToTransform.parentElement;
    				}

    				window.requestAnimationFrame(function () {
    					elementToTransform.style.transition = '0.5s';
    					elementToTransform.style.transform = 'perspective(100px) rotateX(0deg) rotateY(0deg)';

    					setTimeout(
    						() => {
    							elementToTransform.style.transition = '';
    						},
    						500
    					);
    				});
    			});
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Projects> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CustomTitle,
    		CustomButton,
    		onMount,
    		projects,
    		getProjectInParent,
    		applyPositionAndSize,
    		checkProjectMouseout,
    		projectMouseover,
    		projectMouseout,
    		followMouseTransforms,
    		followMouseTransformElement
    	});

    	return [projects];
    }

    class Projects extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Projects",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/sections/Contact.svelte generated by Svelte v3.44.2 */
    const file$2 = "src/sections/Contact.svelte";

    // (8:8) <CustomTitle>
    function create_default_slot_4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Contact");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(8:8) <CustomTitle>",
    		ctx
    	});

    	return block;
    }

    // (13:16) <Link href="mailto:0arthur.fontaine@gmail.com">
    function create_default_slot_3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("0arthur.fontaine@gmail.com");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(13:16) <Link href=\\\"mailto:0arthur.fontaine@gmail.com\\\">",
    		ctx
    	});

    	return block;
    }

    // (14:16) <Link href="tel:+33771715509">
    function create_default_slot_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("+33 7 71 71 55 09");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(14:16) <Link href=\\\"tel:+33771715509\\\">",
    		ctx
    	});

    	return block;
    }

    // (16:16) <Link href="https://twitter.com/f_arthr">
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("https://twitter.com/f_arthr");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(16:16) <Link href=\\\"https://twitter.com/f_arthr\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:16) <Link href="https://t.me/arthur-fontaine">
    function create_default_slot(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("https://t.me/arthur-fontaine");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(17:16) <Link href=\\\"https://t.me/arthur-fontaine\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let section;
    	let header;
    	let customtitle;
    	let t0;
    	let div;
    	let ul;
    	let li0;
    	let link0;
    	let t1;
    	let li1;
    	let link1;
    	let t2;
    	let li2;
    	let t3;
    	let li3;
    	let link2;
    	let t4;
    	let li4;
    	let link3;
    	let current;

    	customtitle = new CustomTitle({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link0 = new Link({
    			props: {
    				href: "mailto:0arthur.fontaine@gmail.com",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link1 = new Link({
    			props: {
    				href: "tel:+33771715509",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link2 = new Link({
    			props: {
    				href: "https://twitter.com/f_arthr",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	link3 = new Link({
    			props: {
    				href: "https://t.me/arthur-fontaine",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			header = element("header");
    			create_component(customtitle.$$.fragment);
    			t0 = space();
    			div = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			create_component(link0.$$.fragment);
    			t1 = space();
    			li1 = element("li");
    			create_component(link1.$$.fragment);
    			t2 = space();
    			li2 = element("li");
    			t3 = space();
    			li3 = element("li");
    			create_component(link2.$$.fragment);
    			t4 = space();
    			li4 = element("li");
    			create_component(link3.$$.fragment);
    			add_location(header, file$2, 6, 4, 161);
    			attr_dev(li0, "class", "svelte-13gnr0r");
    			add_location(li0, file$2, 12, 12, 286);
    			attr_dev(li1, "class", "svelte-13gnr0r");
    			add_location(li1, file$2, 13, 12, 388);
    			attr_dev(li2, "class", "contact__link-separator svelte-13gnr0r");
    			add_location(li2, file$2, 14, 12, 464);
    			attr_dev(li3, "class", "svelte-13gnr0r");
    			add_location(li3, file$2, 15, 12, 518);
    			attr_dev(li4, "class", "svelte-13gnr0r");
    			add_location(li4, file$2, 16, 12, 615);
    			attr_dev(ul, "class", "svelte-13gnr0r");
    			add_location(ul, file$2, 11, 8, 269);
    			attr_dev(div, "class", "contact__links svelte-13gnr0r");
    			add_location(div, file$2, 10, 4, 232);
    			attr_dev(section, "id", "contact");
    			attr_dev(section, "class", "svelte-13gnr0r");
    			add_location(section, file$2, 5, 0, 134);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, header);
    			mount_component(customtitle, header, null);
    			append_dev(section, t0);
    			append_dev(section, div);
    			append_dev(div, ul);
    			append_dev(ul, li0);
    			mount_component(link0, li0, null);
    			append_dev(ul, t1);
    			append_dev(ul, li1);
    			mount_component(link1, li1, null);
    			append_dev(ul, t2);
    			append_dev(ul, li2);
    			append_dev(ul, t3);
    			append_dev(ul, li3);
    			mount_component(link2, li3, null);
    			append_dev(ul, t4);
    			append_dev(ul, li4);
    			mount_component(link3, li4, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const customtitle_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				customtitle_changes.$$scope = { dirty, ctx };
    			}

    			customtitle.$set(customtitle_changes);
    			const link0_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link0_changes.$$scope = { dirty, ctx };
    			}

    			link0.$set(link0_changes);
    			const link1_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link1_changes.$$scope = { dirty, ctx };
    			}

    			link1.$set(link1_changes);
    			const link2_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link2_changes.$$scope = { dirty, ctx };
    			}

    			link2.$set(link2_changes);
    			const link3_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				link3_changes.$$scope = { dirty, ctx };
    			}

    			link3.$set(link3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(customtitle.$$.fragment, local);
    			transition_in(link0.$$.fragment, local);
    			transition_in(link1.$$.fragment, local);
    			transition_in(link2.$$.fragment, local);
    			transition_in(link3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(customtitle.$$.fragment, local);
    			transition_out(link0.$$.fragment, local);
    			transition_out(link1.$$.fragment, local);
    			transition_out(link2.$$.fragment, local);
    			transition_out(link3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(customtitle);
    			destroy_component(link0);
    			destroy_component(link1);
    			destroy_component(link2);
    			destroy_component(link3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Contact', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Contact> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ CustomTitle, Link });
    	return [];
    }

    class Contact extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Contact",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/components/Cursor.svelte generated by Svelte v3.44.2 */

    const { Object: Object_1 } = globals;
    const file$1 = "src/components/Cursor.svelte";

    function create_fragment$1(ctx) {
    	let div1;
    	let div0;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "cx", "15");
    			attr_dev(circle, "cy", "15");
    			attr_dev(circle, "r", "12");
    			attr_dev(circle, "stroke-width", "0");
    			attr_dev(circle, "class", "svelte-g3ikqw");
    			add_location(circle, file$1, 179, 12, 5837);
    			attr_dev(svg, "height", "30");
    			attr_dev(svg, "width", "30");
    			add_location(svg, file$1, 178, 8, 5796);
    			attr_dev(div0, "class", "cursor__ball svelte-g3ikqw");
    			add_location(div0, file$1, 177, 4, 5738);
    			attr_dev(div1, "class", "cursor svelte-g3ikqw");
    			add_location(div1, file$1, 176, 0, 5713);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, svg);
    			append_dev(svg, circle);
    			/*div0_binding*/ ctx[1](div0);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*div0_binding*/ ctx[1](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function areElementsHovering(targets) {
    	if (typeof targets === 'string') {
    		targets = document.querySelectorAll(targets);
    	}

    	for (let i = 0; i < targets.length; i++) {
    		if (targets[i].matches(':hover')) return targets[i];
    	}

    	return false;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cursor', slots, []);
    	let cursorBall;
    	let elementsAnimating = {};
    	let elementsHovering = {};
    	let lastElementHovering = null;

    	const cursorAnimations = {
    		'.links': {
    			'cursor': {
    				'in': { scale: 0.2 },
    				'out': { scale: 1 }
    			}
    		},
    		'.project': {
    			'cursor': {
    				'in': { scale: 0.2 },
    				'out': { scale: 1 }
    			}
    		},
    		'.curriculum-part__bar': {
    			'cursor': {
    				'in': { scale: 0.2 },
    				'out': { scale: 1 }
    			}
    		},
    		'.button': {
    			'cursor': {
    				'in': { scale: 0.2 },
    				'out': { scale: 1 }
    			}
    		},
    		'.socials .async-svg': {
    			'cursor': { 'in': { scale: 0 }, 'out': { scale: 1 } }
    		},
    		'.socials .async-svg[data-hint="Twitter"] svg': {
    			'element': {
    				'in': { fill: '#1DA1F2' },
    				'out': { fill: '#E4E6E7' }
    			}
    		},
    		'.socials .async-svg[data-hint="LinkedIn"] svg': {
    			'element': {
    				'in': { fill: '#0077B5' },
    				'out': { fill: '#E4E6E7' }
    			}
    		},
    		'.socials .async-svg[data-hint="GitHub"] svg': {
    			'element': {
    				'in': {
    					fill: '#171515',
    					stroke: '#E4E6E7',
    					strokeWidth: '1'
    				},
    				'out': {
    					fill: '#E4E6E7',
    					stroke: 'none',
    					strokeWidth: '0'
    				}
    			}
    		}
    	};

    	function checkHovering() {
    		// console.log(elementsAnimating);
    		for (let key in cursorAnimations) {
    			const elementHovering = areElementsHovering(key);

    			if (elementHovering && !elementsAnimating[key]) {
    				if (cursorAnimations[key]['element']?.['in']) {
    					// console.log(elementHovering, cursorAnimations[key]['element']['in'])
    					anime({
    						targets: elementHovering,
    						...cursorAnimations[key]['element']['in'],
    						duration: 100,
    						easing: 'easeInOutQuad',
    						begin: () => {
    							elementsAnimating[key] = true;
    						},
    						complete: () => {
    							elementsAnimating[key] = false;
    						}
    					});
    				}
    			}

    			if (elementHovering) {
    				lastElementHovering = elementHovering;
    				elementsHovering[key] = true;
    			}

    			if (elementHovering && !elementsAnimating['.cursor']) {
    				if (cursorAnimations[key]['cursor']?.['in']) anime({
    					targets: cursorBall,
    					...cursorAnimations[key]['cursor']['in'],
    					duration: 100,
    					easing: 'easeInOutQuad',
    					begin: () => {
    						elementsAnimating['.cursor'] = true;
    					},
    					complete: () => {
    						elementsAnimating['.cursor'] = false;
    					}
    				});

    				return;
    			} else if (!elementsAnimating['.cursor']) {
    				if (cursorAnimations[key]['cursor']?.['out']) anime({
    					targets: cursorBall,
    					...cursorAnimations[key]['cursor']['out'],
    					duration: 100,
    					easing: 'easeInOutQuad',
    					begin: () => {
    						elementsAnimating['.cursor'] = true;
    					},
    					complete: () => {
    						elementsAnimating['.cursor'] = false;
    					}
    				});
    			}
    		}
    	}

    	setInterval(
    		() => {
    			Object.entries(elementsHovering).filter(([key, value]) => value).forEach(([key, value]) => {
    				const elementHovering = areElementsHovering(key);

    				if (!elementHovering) {
    					elementsHovering[key] = false;

    					if (cursorAnimations[key]['element']?.['out']) {
    						anime({
    							targets: key,
    							...cursorAnimations[key]['element']['out'],
    							duration: 100,
    							easing: 'easeInOutQuad',
    							begin: () => {
    								elementsAnimating[key] = true;
    							},
    							complete: () => {
    								elementsAnimating[key] = false;
    							}
    						});
    					}
    				}
    			});
    		},
    		100
    	);

    	function moveCursor(x, y) {
    		$$invalidate(0, cursorBall.style.left = x - cursorBall.offsetWidth / 2 + 'px', cursorBall);
    		$$invalidate(0, cursorBall.style.top = y - cursorBall.offsetHeight / 2 + 'px', cursorBall);
    	}

    	function onMouseMove(event) {
    		moveCursor(event.pageX, event.pageY);
    		checkHovering();
    	}

    	document.addEventListener("mousemove", onMouseMove);

    	function onScroll(event) {
    		moveCursor(event.pageX, event.pageY);
    	}

    	document.addEventListener("wheel", onScroll);
    	const writable_props = [];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cursor> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			cursorBall = $$value;
    			$$invalidate(0, cursorBall);
    		});
    	}

    	$$self.$capture_state = () => ({
    		anime,
    		cursorBall,
    		elementsAnimating,
    		elementsHovering,
    		lastElementHovering,
    		cursorAnimations,
    		areElementsHovering,
    		checkHovering,
    		moveCursor,
    		onMouseMove,
    		onScroll
    	});

    	$$self.$inject_state = $$props => {
    		if ('cursorBall' in $$props) $$invalidate(0, cursorBall = $$props.cursorBall);
    		if ('elementsAnimating' in $$props) elementsAnimating = $$props.elementsAnimating;
    		if ('elementsHovering' in $$props) elementsHovering = $$props.elementsHovering;
    		if ('lastElementHovering' in $$props) lastElementHovering = $$props.lastElementHovering;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cursorBall, div0_binding];
    }

    class Cursor extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cursor",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.44.2 */
    const file = "src/App.svelte";

    function create_fragment(ctx) {
    	let div;
    	let lottieplayer;
    	let t0;
    	let main;
    	let cursor;
    	let t1;
    	let home;
    	let t2;
    	let aboutme;
    	let t3;
    	let projects;
    	let t4;
    	let contact;
    	let current;

    	lottieplayer = new LottiePlayer({
    			props: {
    				src: "assets/lottie/logo-in-out.json",
    				autoplay: true,
    				loop: true,
    				controls: false,
    				renderer: "svg",
    				background: "transparent",
    				controlsLayout: [],
    				style: "position: relative;\n               max-width: 16rem;\n               margin: auto;\n               top: 50%;\n               transform: translateY(-50%);"
    			},
    			$$inline: true
    		});

    	lottieplayer.$on("load", /*load_handler*/ ctx[1]);
    	cursor = new Cursor({ $$inline: true });
    	home = new Home({ $$inline: true });
    	aboutme = new AboutMe({ $$inline: true });
    	projects = new Projects({ $$inline: true });
    	contact = new Contact({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(lottieplayer.$$.fragment);
    			t0 = space();
    			main = element("main");
    			create_component(cursor.$$.fragment);
    			t1 = space();
    			create_component(home.$$.fragment);
    			t2 = space();
    			create_component(aboutme.$$.fragment);
    			t3 = space();
    			create_component(projects.$$.fragment);
    			t4 = space();
    			create_component(contact.$$.fragment);
    			attr_dev(div, "class", "preloader");
    			add_location(div, file, 64, 0, 2012);
    			attr_dev(main, "class", "app svelte-12l4fbt");
    			attr_dev(main, "data-lg-smooth", "");
    			add_location(main, file, 82, 0, 2497);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(lottieplayer, div, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			mount_component(cursor, main, null);
    			append_dev(main, t1);
    			mount_component(home, main, null);
    			append_dev(main, t2);
    			mount_component(aboutme, main, null);
    			append_dev(main, t3);
    			mount_component(projects, main, null);
    			append_dev(main, t4);
    			mount_component(contact, main, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lottieplayer.$$.fragment, local);
    			transition_in(cursor.$$.fragment, local);
    			transition_in(home.$$.fragment, local);
    			transition_in(aboutme.$$.fragment, local);
    			transition_in(projects.$$.fragment, local);
    			transition_in(contact.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lottieplayer.$$.fragment, local);
    			transition_out(cursor.$$.fragment, local);
    			transition_out(home.$$.fragment, local);
    			transition_out(aboutme.$$.fragment, local);
    			transition_out(projects.$$.fragment, local);
    			transition_out(contact.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(lottieplayer);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(cursor);
    			destroy_component(home);
    			destroy_component(aboutme);
    			destroy_component(projects);
    			destroy_component(contact);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);

    	onDestroy(() => {
    		Os.lifecycle.refresh();
    	});

    	onMount(() => {
    		document.querySelector('main.app').style.opacity = 0;

    		if (document.querySelector('html').classList.contains('is-mobile')) document.querySelectorAll('*').forEach(el => {
    			el.classList.add('is-mobile');
    		});
    	});

    	let startLoading = undefined;
    	let animationDuration = undefined;
    	document.body.classList.add('loading');

    	onload = () => {
    		document.body.classList.remove('loading');

    		const next = () => {
    			anime({
    				targets: document.querySelector('.preloader'),
    				opacity: 0,
    				duration: 1000,
    				easing: 'easeInOutQuad',
    				complete: () => {
    					document.body.removeChild(document.querySelector('.preloader'));
    				}
    			});

    			anime({
    				targets: document.querySelector('main.app'),
    				opacity: 1,
    				duration: 1000,
    				easing: 'easeInOutQuad'
    			});

    			Os.scrollobserver.add(document.querySelector('main.app'));
    		};

    		if (startLoading && animationDuration) {
    			let animationStartedFrom = (Date.now() - startLoading.now()) / 1000;
    			let waitUntilAnimationCycle = animationStartedFrom % animationDuration;
    			setTimeout(next, waitUntilAnimationCycle * 1000);
    		} else {
    			next();
    		}
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	const load_handler = () => {
    		$$invalidate(0, startLoading = new Date());
    	};

    	$$self.$capture_state = () => ({
    		luge: Os,
    		LottiePlayer,
    		Home,
    		onDestroy,
    		onMount,
    		anime,
    		AboutMe,
    		Projects,
    		Contact,
    		Cursor,
    		startLoading,
    		animationDuration
    	});

    	$$self.$inject_state = $$props => {
    		if ('startLoading' in $$props) $$invalidate(0, startLoading = $$props.startLoading);
    		if ('animationDuration' in $$props) animationDuration = $$props.animationDuration;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [startLoading, load_handler];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({ target: document.body });

    return app;

})();
//# sourceMappingURL=bundle.js.map
